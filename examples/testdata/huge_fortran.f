

MODULE ppm_module_particles_typedef














USE ppm_module_alloc
USE ppm_module_typedef
USE ppm_module_data, ONLY: ppm_rank,ppm_dim,ppm_comm
USE ppm_module_error
USE ppm_module_write
USE ppm_module_substart
USE ppm_module_substop

IMPLICIT NONE
PRIVATE

!User parameters 
INTEGER, PARAMETER, PUBLIC :: ppm_param_part_init_cartesian = 1
INTEGER, PARAMETER, PUBLIC :: ppm_param_part_init_random = 2


!PPM internal parameters used only to access entries in the
!particle data structure.
INTEGER,PARAMETER   :: ppm_part_ghosts = 1
INTEGER,PARAMETER   :: ppm_part_partial = 2
INTEGER,PARAMETER   :: ppm_part_reqput = 3
INTEGER,PARAMETER   :: ppm_part_areinside = 4
INTEGER,PARAMETER   :: ppm_part_cartesian = 5
INTEGER,PARAMETER   :: ppm_part_neighlists = 6
INTEGER,PARAMETER   :: ppm_part_global_index = 7
INTEGER,PARAMETER   :: ppm_param_length_partflags = 7

!PPM internal parameters used only to access entries in the
!particle's property data structure.
INTEGER,PARAMETER,PUBLIC   :: ppm_ppt_ghosts = 1
INTEGER,PARAMETER,PUBLIC   :: ppm_ppt_partial = 2
INTEGER,PARAMETER,PUBLIC   :: ppm_ppt_reqput = 3
INTEGER,PARAMETER,PUBLIC   :: ppm_ppt_map_parts = 4
INTEGER,PARAMETER,PUBLIC   :: ppm_ppt_map_ghosts = 5
INTEGER,PARAMETER,PUBLIC   :: ppm_param_length_pptflags = 5

!PPM internal parameters used only to access entries in the
!particle's property data structure.
INTEGER,PARAMETER,PUBLIC   :: ppm_ops_inc_ghosts = 1
INTEGER,PARAMETER,PUBLIC   :: ppm_ops_interp = 2
INTEGER,PARAMETER,PUBLIC   :: ppm_ops_iscomputed = 3
INTEGER,PARAMETER,PUBLIC   :: ppm_ops_isdefined = 4
INTEGER,PARAMETER,PUBLIC   :: ppm_ops_vector = 5
INTEGER,PARAMETER,PUBLIC   :: ppm_param_length_opsflags = 5

!PPM internal parameters for default storage IDs of some DS.
INTEGER, PARAMETER,PUBLIC :: ppm_param_default_nlID = 1


!----------------------------------------------------------------------
! Global variables 
!----------------------------------------------------------------------

INTEGER                               :: ppm_particles_seedsize
INTEGER,  DIMENSION(:  ), POINTER     :: ppm_particles_seed => NULL()

TYPE ppm_t_part_prop_s
    !!! Data structure for particle properties
    INTEGER                                        :: data_type
    !!! type of the property
    !!! One of:
    !!!     ppm_param_...
    !!! 
    CHARACTER(len=ppm_char)                        :: name
    !!! name of the property
    LOGICAL, DIMENSION(ppm_param_length_pptflags)  :: flags
    !!! logical flags
    !!!    ppm_ppt_ghosts
    !!!          true if ghost values are up-to-date
    !!!    ppm_ppt_partial
    !!!          true if there is a one-to-one mapping with the particles
    !!!    ppm_ppt_reqput
    !!!    ppm_ppt_map_parts
    !!!          true if partial mappings are desired for this property (default)
    !!!          (if false, the array for this property is not reallocated when
    !!!           particles move to a different processor or when they are
    !!!           interpolated from one distribution to another)
    !!!    ppm_ppt_map_ghosts
    !!!          true if ghost mappings are desired for this property (default)
    INTEGER                                        :: lda
    !!! leading dimension of the data array
    !!!
    !!! pointers to arrays where the scalar-value properties are stored
    INTEGER, DIMENSION(:), POINTER                 :: data_1d_i =>NULL()
    !!! if the data is 1d integer
    INTEGER, DIMENSION(:,:), POINTER               :: data_2d_i =>NULL()
    !!! if the data is 2d integer
    INTEGER(ppm_kind_int64),DIMENSION(:), POINTER  :: data_1d_li =>NULL()
    !!! if the data is 1d long integer
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER :: data_2d_li =>NULL()
    !!! if the data is 2d long integer
    REAL(ppm_kind_single), DIMENSION(:), POINTER                :: data_1d_r => NULL()
    !!! if the data is 1d real
    REAL(ppm_kind_single), DIMENSION(:,:), POINTER              :: data_2d_r =>NULL()
    !!! if the data is 2d real
    COMPLEX(ppm_kind_single), DIMENSION(:), POINTER             :: data_1d_c => NULL()
    !!! if the data is 1d complex
    COMPLEX(ppm_kind_single), DIMENSION(:,:), POINTER           :: data_2d_c =>NULL()
    !!! if the data is 2d complex
    LOGICAL, DIMENSION(:), POINTER                 :: data_1d_l => NULL()
    !!! if the data is 1d logical
    LOGICAL, DIMENSION(:,:), POINTER               :: data_2d_l =>NULL()
    !!! if the data is 2d logical

    CONTAINS
        PRIVATE
        PROCEDURE :: create => prop_create_s
        PROCEDURE :: destroy => prop_destroy_s
        PROCEDURE :: print_info => prop_print_info_s

END TYPE ppm_t_part_prop_s
!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold neighlists
!----------------------------------------------------------------------
TYPE ppm_ptr_part_prop_s
    TYPE(ppm_t_part_prop_s), POINTER  :: t => NULL()
END TYPE ppm_ptr_part_prop_s

TYPE ppm_t_neighlist_s
    CHARACTER(len=ppm_char)                        :: name
    !!! name of the neighbour list
    INTEGER                                         :: P_id = 0
    !!! Id of the set of particles that this neighbour list refers to
    !!! The default, 0, stands for "self".
    REAL(ppm_kind_single)                                        :: cutoff 
    !!! cutoff radius
    REAL(ppm_kind_single)                                        :: skin
    !!! skin layer around the particles
    INTEGER                                         :: isymm
    !!! using symmetry
    INTEGER              , DIMENSION(:  ), POINTER  :: nvlist=> NULL()
    !!! Number of neighbors of each particles
    INTEGER              , DIMENSION(:,:), POINTER  :: vlist=> NULL()
    !!! Neighbor lists
    LOGICAL                                         :: uptodate = .FALSE.
    !!! true if the neighbor lists have been computed
    INTEGER                                         :: nneighmin = 0
    !!! smallest number of neighbors on this processor
    INTEGER                                         :: nneighmax = 0
    !!! highest number of neighbors on this processor

    CONTAINS
        PRIVATE
        PROCEDURE :: destroy => neigh_destroy_s

END TYPE ppm_t_neighlist_s

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold neighlists
!----------------------------------------------------------------------
TYPE ppm_ptr_t_neighlist_s
    TYPE(ppm_t_neighlist_s), POINTER  :: t => NULL()
END TYPE ppm_ptr_t_neighlist_s


TYPE ppm_t_opdesc_s
    !!! Data structure to describe differential operator
    !!!  It only contains semantic information on the operator
    INTEGER, DIMENSION(:), POINTER                 :: degree =>NULL()
    !!! degree of each term in the linear combination of differential ops 
    INTEGER, DIMENSION(:), POINTER                 :: order =>NULL()
    !!! approximation order of each term 
    REAL(ppm_kind_single), DIMENSION(:), POINTER                :: coeffs =>NULL()
    !!! array where the coefficients in linear combinations of 
    !!! differential ops are stored
    INTEGER                                        :: nterms
    !!! number of terms
    CHARACTER(LEN=ppm_char)                        :: name
    !!! name of the vector-valued property

    CONTAINS
        PRIVATE
        PROCEDURE :: create => desc_create_s
        PROCEDURE :: destroy => desc_destroy_s

END TYPE ppm_t_opdesc_s

TYPE ppm_t_operator_s
    !!! Data structure containing all diff operators for a particle set
    !!! 
    REAL(ppm_kind_single),DIMENSION(:,:),               POINTER :: ker => NULL()
    !!! where the operators are stored
    TYPE(ppm_t_opdesc_s),             POINTER :: desc => NULL()
    !!! small matrices that describe what each operator does
    INTEGER                                        :: P_id = 0
    !!! Id of the set of particles that this operator takes data from.
    !!! The default, 0, stands for "self" (the operator is computed
    !!! on the same set of particles than the one which contains the data).
    INTEGER                                        :: neigh_id = 1
    !!! Id of the neighbour list that should be used
    !!! The default, 1, refers to "self": the list of neighbours within
    !!! the same set of particles. 

    LOGICAL, DIMENSION(ppm_param_length_opsflags)  :: flags
    !!! logical flags
    !!!    ppm_ops_inc_ghosts
    !!!           true if the operator should be computed for ghost 
    !!!           particles too.  Note that the resulting values 
    !!!           will be wrong for the ghost particles
    !!!           that have some neighbours outside the ghost layers. 
    !!!           Default is false.
    !!!    ppm_ops_interp
    !!!          true if the op interpolates data from one set of particles
    !!!    ppm_ops_iscomputed
    !!!          true if the operator has been computed and is uptodate
    !!!    ppm_ops_isdefined
    !!!          true if the operator has been defined 
    !!!    ppm_ops_vector
    !!!          true if each term represents a component (ie the result
    !!!          of the operator should be a vector field, like for gradients)
    !!!          false if the components are added up (like for the divergence)

    CONTAINS
        PRIVATE
        PROCEDURE :: create => op_create_s
        PROCEDURE :: destroy => op_destroy_s

END TYPE ppm_t_operator_s

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold operators
!----------------------------------------------------------------------
TYPE ppm_ptr_ops_s
    TYPE(ppm_t_operator_s), POINTER :: t => NULL()
END TYPE ppm_ptr_ops_s

TYPE particles_stats_s
    !!! Data structure containing statistics about a particle set
    !!! 
    INTEGER                                          :: nb_nl = 0
    !!! number of neighbour lists constructions
    INTEGER                                          :: nb_inl = 0
    !!! number of inhomogeneous neighbour lists constructions
    INTEGER                                          :: nb_cinl = 0
    !!! number of conventional (old and depreciated) inl constructions
    INTEGER                                          :: nb_xset_inl = 0
    !!! number of xset inhomogeneous neighbour lists constructions
    INTEGER                                          :: nb_xset_nl = 0
    !!! number of xset neighbour lists constructions
    INTEGER                                          :: nb_dc_comp = 0
    !!! number of DC operators computation (matrix inversions)
    INTEGER                                          :: nb_dc_apply = 0
    !!! number of DC operators evaluation (no matrix inversions)
    INTEGER                                          :: nb_kdtree = 0
    !!! number of kdtree constructions
    INTEGER                                          :: nb_global_map = 0
    !!! number of global mappings
    INTEGER                                          :: nb_part_map = 0
    !!! number of partial mappings
    INTEGER                                          :: nb_ghost_get = 0
    !!! number of partial mappings
    INTEGER                                          :: nb_ghost_push = 0
    !!! number of partial mappings
    REAL(ppm_kind_single)                                       :: t_nl = 0._ppm_kind_single
    !!! time spent for neighbour lists constructions
    REAL(ppm_kind_single)                                       :: t_inl = 0._ppm_kind_single
    !!! time spent for inhomogeneous neighbour lists constructions
    REAL(ppm_kind_single)                                       :: t_cinl = 0._ppm_kind_single
    !!! time spent for conventional (old and depreciated) inl constructions
    REAL(ppm_kind_single)                                       :: t_xset_inl = 0._ppm_kind_single
    !!! time spent for xset inhomogeneous neighbour lists constructions
    REAL(ppm_kind_single)                                       :: t_xset_nl = 0._ppm_kind_single
    !!! time spent for xset neighbour lists constructions
    REAL(ppm_kind_single)                                       :: t_dc_comp = 0._ppm_kind_single
    !!! time spent for DC operators computation (matrix inversions)
    REAL(ppm_kind_single)                                       :: t_dc_apply = 0._ppm_kind_single
    !!! time spent for DC operators evaluation (no matrix inversions)
    REAL(ppm_kind_single)                                       :: t_kdtree = 0._ppm_kind_single
    !!! time spent for kdtree constructions
    REAL(ppm_kind_single)                                       :: t_global_map = 0._ppm_kind_single
    !!! time spent for global mappings
    REAL(ppm_kind_single)                                       :: t_part_map = 0._ppm_kind_single
    !!! time spent for partial mappings
    REAL(ppm_kind_single)                                       :: t_ghost_get = 0._ppm_kind_single
    !!! time spent for partial mappings
    REAL(ppm_kind_single)                                       :: t_ghost_push = 0._ppm_kind_single
    !!! time spent for partial mappings

    INTEGER                                          :: nb_ls = 0
    REAL(ppm_kind_single)                                       :: t_ls = 0._ppm_kind_single
    REAL(ppm_kind_single)                                       :: t_add = 0._ppm_kind_single
    REAL(ppm_kind_single)                                       :: t_del = 0._ppm_kind_single
    REAL(ppm_kind_single)                                       :: t_compD = 0._ppm_kind_single

END TYPE particles_stats_s

!----------------------------------------------------------------------
! Container class
!----------------------------------------------------------------------
TYPE, ABSTRACT :: ppm_t_container_s
    INTEGER                                         :: nb = 0
    !!! number of different instances
    INTEGER                                         :: iter_id = 0
    !!! index at which the iterator is currently pointing
    INTEGER                                         :: min_id = HUGE(1)
    !!! smallest non-null index in the array
    INTEGER                                         :: max_id = 0
    !!! highest non-null index in the array
    INTEGER                                         :: vec_size = 0
    !!! current allocated size of the array
    CONTAINS
        PROCEDURE       :: exists => part_DS_exists_s
END TYPE ppm_t_container_s

!ABSTRACT INTERFACE
!    FUNCTION begin_s(this) RESULT(iterator)
!        IMPORT ppm_t_container_s
!        CLASS(ppm_t_container_s), INTENT(IN) :: this
!        CLASS(*), POINTER    :: iterator
!    END FUNCTION begin_s
!END INTERFACE
!ABSTRACT INTERFACE
!    FUNCTION next_s(this) RESULT(iterator)
!        IMPORT ppm_t_container_s
!        CLASS(ppm_t_container_s), INTENT(IN) :: this
!        CLASS(*), POINTER  :: iterator
!    END FUNCTION next_s
!END INTERFACE

!----------------------------------------------------------------------
! Container for properties
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_s) ::  ppm_c_props_s
    TYPE(ppm_ptr_part_prop_s),DIMENSION(:),POINTER :: vec => NULL()
    !!! array with pointers to each property for this particle set
    TYPE(ppm_t_part_prop_s),              POINTER  :: iterator => NULL()
    CONTAINS
        PRIVATE
        PROCEDURE, PUBLIC       :: begin => begin_prop_s
        PROCEDURE, PUBLIC       :: next => next_prop_s
        PROCEDURE       :: last => last_prop_s
        PROCEDURE       :: prev => prev_prop_s
        PROCEDURE       :: destroy => prop_container_destroy_s

        PROCEDURE     :: data_1d_i_check_s
        PROCEDURE     :: data_2d_i_check_s
        PROCEDURE     :: data_1d_li_check_s
        PROCEDURE     :: data_2d_li_check_s
        PROCEDURE     :: data_1d_r_check_s
        PROCEDURE     :: data_2d_r_check_s
        PROCEDURE     :: data_1d_c_check_s
        PROCEDURE     :: data_2d_c_check_s
        PROCEDURE     :: data_1d_l_check_s
        PROCEDURE     :: data_2d_l_check_s


        !NOTE: for some reason, this does not work
        ! (ifort crashes at compile time if there is a call
        !  to this%checktype(wp,wpid,info) )
        ! One can call the not-overloaded procedures directly,
        ! but thats very annoying...
        GENERIC, PUBLIC :: checktype => & 
            data_1d_i_check_s,&
            data_2d_i_check_s,&
            data_1d_li_check_s,&
            data_2d_li_check_s,&
            data_1d_r_check_s,&
            data_2d_r_check_s,&
            data_1d_c_check_s,&
            data_2d_c_check_s,&
            data_1d_l_check_s,&
            data_2d_l_check_s
END TYPE ppm_c_props_s
!----------------------------------------------------------------------
! Container for operators
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_s) ::  ppm_c_operators_s
    TYPE(ppm_ptr_ops_s),DIMENSION(:),POINTER :: vec => NULL()
    !!! array with pointers to each differential operator for this particle set
    TYPE(ppm_t_operator_s),          POINTER :: iterator => NULL()
    CONTAINS
        PROCEDURE       :: begin => begin_op_s
        PROCEDURE       :: next => next_op_s
        PROCEDURE       :: last => last_op_s
        PROCEDURE       :: prev => prev_op_s
        PROCEDURE       :: destroy => op_container_destroy_s
END TYPE ppm_c_operators_s
!----------------------------------------------------------------------
! Container for neighbour lists
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_s) ::  ppm_c_neighlists_s
    TYPE(ppm_ptr_t_neighlist_s),DIMENSION(:),POINTER :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    TYPE(ppm_t_neighlist_s),                 POINTER :: iterator => NULL()
    CONTAINS
        PROCEDURE       :: begin => begin_neigh_s
        PROCEDURE       :: next => next_neigh_s
        PROCEDURE       :: last => last_neigh_s
        PROCEDURE       :: prev => prev_neigh_s
        PROCEDURE       :: destroy => neigh_container_destroy_s
END TYPE ppm_c_neighlists_s

!----------------------------------------------------------------------
! Container for lists of (pointers to) Particle clouds
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_s) ::  ppm_c_Pc_s
    TYPE(ppm_ptr_t_particles_s),DIMENSION(:), POINTER :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    CLASS(ppm_t_particles_s),                 POINTER :: iterator => NULL()
!    CONTAINS
!        PROCEDURE       :: begin => begin_pc_s
!        PROCEDURE       :: next => next_pc_s
!        PROCEDURE       :: last => last_pc_s
!        PROCEDURE       :: prev => prev_pc_s
!        PROCEDURE       :: destroy => pc_container_destroy_s
END TYPE ppm_c_Pc_s

!----------------------------------------------------------------------
! Container for particle mappings
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_s) ::  ppm_c_pmaps_s
    TYPE(ppm_ptr_t_part_mapping_s),DIMENSION(:), POINTER :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    CLASS(ppm_t_part_mapping_s),                 POINTER :: iterator => NULL()
!    CONTAINS
!        PROCEDURE       :: begin => begin_pc_s
!        PROCEDURE       :: next => next_pc_s
!        PROCEDURE       :: last => last_pc_s
!        PROCEDURE       :: prev => prev_pc_s
!        PROCEDURE       :: destroy => pc_container_destroy_s
END TYPE ppm_c_pmaps_s

!----------------------------------------------------------------------
! Container for lists of (pointers to) adaptive Particle clouds
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_s) ::  ppm_c_aPc_s
    TYPE(ppm_ptr_t_sop_s),DIMENSION(:),POINTER  :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    CLASS(ppm_t_sop_s),                 POINTER :: iterator => NULL()
!    CONTAINS
!        PROCEDURE       :: begin => begin_pc_s
!        PROCEDURE       :: next => next_pc_s
!        PROCEDURE       :: last => last_pc_s
!        PROCEDURE       :: prev => prev_pc_s
!        PROCEDURE       :: destroy => pc_container_destroy_s
END TYPE ppm_c_aPc_s

TYPE ppm_t_particles_s
    !!! Data structure for a particle set

    CHARACTER(LEN=ppm_char)                         :: name
    !!! name for this particle set
    REAL(ppm_kind_single), DIMENSION(:,:), POINTER               :: xp => NULL()
    !!! positions of the particles
    INTEGER                                         :: Npart
    !!! Number of real particles on this processor
    INTEGER                                         :: Mpart
    !!! Number of particles (including ghosts) on this processor
    LOGICAL, DIMENSION(ppm_param_length_partflags)  :: flags
    !!! logical flags
    !!!    ppm_part_ghosts
    !!!          true if ghost values are up-to-date
    !!!    ppm_part_partial
    !!!          true if the particles have been mapped on the active topology
    !!!    ppm_part_reqput
    !!!    ppm_part_areinside
    !!!          true if all the particles are inside the comp. domain
    !!!    ppm_part_cartesian
    !!!          true if the particles form a Cartesian grid
    !!!    ppm_part_neighlists
    !!!          true if neighbour lists within this particle cloud are
    !!!          up-to-date
    !!!    ppm_part_global_index
    !!!          true if particles have an uptodate global index


    ! Topology (links between Particles and topologies)
    INTEGER                                         :: active_topoid
    !!! Topology on which particles are currently mapped

    ! Special data IDs
    INTEGER                                         :: gi_ID
    !!! Global index


    !ghost layers
    REAL(ppm_kind_single)                                        :: ghostlayer
    !!! ghost layer size used for ghost mapping
    !!! (note: could in principle be different from the cutoff used to 
    !!!  compute the neighbour lists)
    INTEGER                                         :: isymm

    ! Container for Particles properties
    TYPE(ppm_c_props_s)                        :: props


    ! Container for Neighbor lists
    TYPE(ppm_c_neighlists_s)                   :: neighs


    ! Container for differential operators
    TYPE(ppm_c_operators_s)                    :: ops


    ! Container for particle mappings
    TYPE(ppm_c_pmaps_s)                        :: maps

    ! Container for lists of (pointers to) other particle clouds
    TYPE(ppm_c_Pc_s)                           :: set_Pc


    ! Load balancing
    REAL(ppm_kind_single), DIMENSION(:), POINTER                 :: pcost=> NULL()
    !!! cost associated to each particle 


    ! stats
    TYPE(particles_stats_s)                    :: stats
    !!! runtime statistics (e.g. timings, memory)


    ! clocks
    REAL(ppm_kind_single)                                        :: time
    !!! clock for this set of particles
    INTEGER                                         :: itime
    !!! iteration number for this set of particles


    !------------miscellaneous----------

    ! spacings between particles
    REAL(ppm_kind_single)                                      :: h_avg
    !!! (global) average distance between particles
    REAL(ppm_kind_single)                                      :: h_min
    !!! (global) minimum distance between particles
    
    CONTAINS
        PRIVATE
        PROCEDURE     :: create => part_create_s
        PROCEDURE     :: destroy => part_destroy_s
        PROCEDURE     :: initialize => part_initialize_s
        PROCEDURE     :: del_parts => part_del_parts_s

        PROCEDURE     :: create_prop => part_prop_create_s
        PROCEDURE     :: destroy_prop => part_prop_destroy_s
        PROCEDURE     :: realloc_prop => part_prop_realloc_s

        PROCEDURE     :: create_neighlist => part_neigh_create_s
        PROCEDURE     :: set_cutoff => part_set_cutoff_s
        PROCEDURE     :: destroy_neighlist => part_neigh_destroy_s
        PROCEDURE     :: comp_neighlist => part_neighlist_s
        PROCEDURE     :: get_nvlist => get_nvlist_s
        PROCEDURE     :: get_vlist => get_vlist_s

        PROCEDURE     :: create_op => part_op_create_s
        PROCEDURE     :: destroy_op => part_op_destroy_s
        PROCEDURE     :: ppm_dcop_compute2d_s
        PROCEDURE     :: ppm_dcop_compute3d_s
        PROCEDURE     :: comp_op => part_op_compute_s
        PROCEDURE     :: apply_op => part_op_apply_s
 !       PROCEDURE     :: updated_positions => part_updated_positions_s

        PROCEDURE     :: map_part_push_legacy => part_prop_push_s
        PROCEDURE     :: map_part_pop_legacy => part_prop_pop_s
        PROCEDURE     :: map => part_mapping_s
        PROCEDURE     :: map_ghosts => part_mapping_ghosts_s

        PROCEDURE     :: move => part_move_s
        PROCEDURE     :: apply_bc => part_apply_bc_s


        PROCEDURE     :: print_info => part_print_info_s

        PROCEDURE     :: comp_global_index => part_comp_global_index_s

        PROCEDURE     :: get_xp => get_xp_s
        PROCEDURE     :: set_xp => set_xp_s
        PROCEDURE     :: get_dcop => get_dcop_s
        PROCEDURE     :: set_dcop => set_dcop_s
        PROCEDURE     :: data_1d_i_get_s
        PROCEDURE     :: data_2d_i_get_s
        PROCEDURE     :: data_1d_li_get_s
        PROCEDURE     :: data_2d_li_get_s
        PROCEDURE     :: data_1d_r_get_s
        PROCEDURE     :: data_2d_r_get_s
        PROCEDURE     :: data_1d_c_get_s
        PROCEDURE     :: data_2d_c_get_s
        PROCEDURE     :: data_1d_l_get_s
        PROCEDURE     :: data_2d_l_get_s

        PROCEDURE     :: data_1d_i_set_s
        PROCEDURE     :: data_2d_i_set_s
        PROCEDURE     :: data_1d_li_set_s
        PROCEDURE     :: data_2d_li_set_s
        PROCEDURE     :: data_1d_r_set_s
        PROCEDURE     :: data_2d_r_set_s
        PROCEDURE     :: data_1d_c_set_s
        PROCEDURE     :: data_2d_c_set_s
        PROCEDURE     :: data_1d_l_set_s
        PROCEDURE     :: data_2d_l_set_s
        GENERIC, PUBLIC :: get =>  &
            data_1d_i_get_s,&
            data_2d_i_get_s,&
            data_1d_li_get_s,&
            data_2d_li_get_s,&
            data_1d_r_get_s,&
            data_2d_r_get_s,&
            data_1d_c_get_s,&
            data_2d_c_get_s,&
            data_1d_l_get_s,&
            data_2d_l_get_s
        GENERIC, PUBLIC :: set =>  &
            data_1d_i_set_s,&
            data_2d_i_set_s,&
            data_1d_li_set_s,&
            data_2d_li_set_s,&
            data_1d_r_set_s,&
            data_2d_r_set_s,&
            data_1d_c_set_s,&
            data_2d_c_set_s,&
            data_1d_l_set_s,&
            data_2d_l_set_s

        PROCEDURE       :: create_map => part_map_create_s
        PROCEDURE       :: destroy_map => part_map_destroy_s
        PROCEDURE       :: map_part_send_s

        PROCEDURE       :: map_part_pop_1d_s
        PROCEDURE       :: map_part_pop_1dc_s
        PROCEDURE       :: map_part_pop_1di_s
        PROCEDURE       :: map_part_pop_1dl_s
        PROCEDURE       :: map_part_pop_2d_s
        PROCEDURE       :: map_part_pop_2dc_s
        PROCEDURE       :: map_part_pop_2di_s
        PROCEDURE       :: map_part_pop_2dl_s
        PROCEDURE       :: map_part_push_1d_s
        PROCEDURE       :: map_part_push_1dc_s
        PROCEDURE       :: map_part_push_1di_s
        PROCEDURE       :: map_part_push_1dl_s
        PROCEDURE       :: map_part_push_2d_s
        PROCEDURE       :: map_part_push_2dc_s
        PROCEDURE       :: map_part_push_2di_s
        PROCEDURE       :: map_part_push_2dl_s

        GENERIC, PUBLIC ::  map_part_pop => &
            map_part_pop_1d_s,&
            map_part_pop_1dc_s,&
            map_part_pop_1di_s,&
            map_part_pop_1dl_s,&
            map_part_pop_2d_s,&
            map_part_pop_2dc_s,&
            map_part_pop_2di_s,&
            map_part_pop_2dl_s
        GENERIC, PUBLIC ::  map_part_push => &
            map_part_push_1d_s,&
            map_part_push_1dc_s,&
            map_part_push_1di_s,&
            map_part_push_1dl_s,&
            map_part_push_2d_s,&
            map_part_push_2dc_s,&
            map_part_push_2di_s,&
            map_part_push_2dl_s

END TYPE ppm_t_particles_s

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold ppm_t_particles
!----------------------------------------------------------------------
TYPE ppm_ptr_t_particles_s
    TYPE(ppm_t_particles_s), POINTER  :: t => NULL()
END TYPE ppm_ptr_t_particles_s


TYPE, EXTENDS(ppm_t_particles_s) :: ppm_t_sop_s
    !!! an extension of the Particle cloud data structure
    !!! for Self-Organizing Particles

    INTEGER                                         :: nn_sq_id
    !!! index of the wps array where nearest-neighbour distances are stored

    ! Adaptive particles
    LOGICAL                                         :: adaptive
    !!! true if the particles have their own cutoff radii
    !!! in this case, the cutoff will be stored in wps(rcp_id)%vec
    INTEGER                                         :: rcp_id
    !!! index of the wps array where the cutoff radius is stored
    INTEGER                                         :: D_id
    !!! index of the wps array where D is stored
    INTEGER                                         :: Dtilde_id
    !!! index of the wps array where D_tilde is stored
    INTEGER                                         :: adapt_wpid
    !!! index of the wps array where is stored the property on 
    !!! which adaptation is based 
    !!! default is first 1d property that is not rcp_id (if any)
    !!! otherwise, it is rcp_id
    !    INTEGER                                         :: adapt_wpgradid
    !    !!! index of the wpv array where is stored the gradient of the property 
    !    !!! on which adaptation is based (if needed)
    LOGICAL                                         :: level_set
    !!! true if particles carry a level-set function
    INTEGER                                         :: level_id
    !!! index of the wps array where the level-set is stored
    !    INTEGER                                         :: level_old_id
    !!! index of the wps array where the level-set is backed up before adapt

    INTEGER                                         :: level_grad_id
    !!! index of the wps array where the gradient of the level-set is stored
    !    INTEGER                                         :: level_grad_old_id
    !!! index of the wps array where the gradient of the level-set 
    !!! is backed up before adapt


    ! Container for lists of (pointers to) other adaptive particle clouds
    TYPE(ppm_c_aPc_s)                          :: set_aPc


    ! Anisotropic particles
    LOGICAL                                         :: anisotropic
    !!! true if the particles have their own cutoff radii
    !!! in this case, the G tensor will be stored in wpv(G_id)%vec
    INTEGER                                         :: G_id
    !!! index where G is stored

!    CONTAINS
!        PRIVATE
!        PROCEDURE     :: create => sop_part_create_s


END TYPE ppm_t_sop_s

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold ppm_t_sop
!----------------------------------------------------------------------
TYPE ppm_ptr_t_sop_s
    TYPE(ppm_t_sop_s), POINTER  :: t => NULL()
END TYPE ppm_ptr_t_sop_s


TYPE ppm_t_part_prop_d
    !!! Data structure for particle properties
    INTEGER                                        :: data_type
    !!! type of the property
    !!! One of:
    !!!     ppm_param_...
    !!! 
    CHARACTER(len=ppm_char)                        :: name
    !!! name of the property
    LOGICAL, DIMENSION(ppm_param_length_pptflags)  :: flags
    !!! logical flags
    !!!    ppm_ppt_ghosts
    !!!          true if ghost values are up-to-date
    !!!    ppm_ppt_partial
    !!!          true if there is a one-to-one mapping with the particles
    !!!    ppm_ppt_reqput
    !!!    ppm_ppt_map_parts
    !!!          true if partial mappings are desired for this property (default)
    !!!          (if false, the array for this property is not reallocated when
    !!!           particles move to a different processor or when they are
    !!!           interpolated from one distribution to another)
    !!!    ppm_ppt_map_ghosts
    !!!          true if ghost mappings are desired for this property (default)
    INTEGER                                        :: lda
    !!! leading dimension of the data array
    !!!
    !!! pointers to arrays where the scalar-value properties are stored
    INTEGER, DIMENSION(:), POINTER                 :: data_1d_i =>NULL()
    !!! if the data is 1d integer
    INTEGER, DIMENSION(:,:), POINTER               :: data_2d_i =>NULL()
    !!! if the data is 2d integer
    INTEGER(ppm_kind_int64),DIMENSION(:), POINTER  :: data_1d_li =>NULL()
    !!! if the data is 1d long integer
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER :: data_2d_li =>NULL()
    !!! if the data is 2d long integer
    REAL(ppm_kind_double), DIMENSION(:), POINTER                :: data_1d_r => NULL()
    !!! if the data is 1d real
    REAL(ppm_kind_double), DIMENSION(:,:), POINTER              :: data_2d_r =>NULL()
    !!! if the data is 2d real
    COMPLEX(ppm_kind_double), DIMENSION(:), POINTER             :: data_1d_c => NULL()
    !!! if the data is 1d complex
    COMPLEX(ppm_kind_double), DIMENSION(:,:), POINTER           :: data_2d_c =>NULL()
    !!! if the data is 2d complex
    LOGICAL, DIMENSION(:), POINTER                 :: data_1d_l => NULL()
    !!! if the data is 1d logical
    LOGICAL, DIMENSION(:,:), POINTER               :: data_2d_l =>NULL()
    !!! if the data is 2d logical

    CONTAINS
        PRIVATE
        PROCEDURE :: create => prop_create_d
        PROCEDURE :: destroy => prop_destroy_d
        PROCEDURE :: print_info => prop_print_info_d

END TYPE ppm_t_part_prop_d
!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold neighlists
!----------------------------------------------------------------------
TYPE ppm_ptr_part_prop_d
    TYPE(ppm_t_part_prop_d), POINTER  :: t => NULL()
END TYPE ppm_ptr_part_prop_d

TYPE ppm_t_neighlist_d
    CHARACTER(len=ppm_char)                        :: name
    !!! name of the neighbour list
    INTEGER                                         :: P_id = 0
    !!! Id of the set of particles that this neighbour list refers to
    !!! The default, 0, stands for "self".
    REAL(ppm_kind_double)                                        :: cutoff 
    !!! cutoff radius
    REAL(ppm_kind_double)                                        :: skin
    !!! skin layer around the particles
    INTEGER                                         :: isymm
    !!! using symmetry
    INTEGER              , DIMENSION(:  ), POINTER  :: nvlist=> NULL()
    !!! Number of neighbors of each particles
    INTEGER              , DIMENSION(:,:), POINTER  :: vlist=> NULL()
    !!! Neighbor lists
    LOGICAL                                         :: uptodate = .FALSE.
    !!! true if the neighbor lists have been computed
    INTEGER                                         :: nneighmin = 0
    !!! smallest number of neighbors on this processor
    INTEGER                                         :: nneighmax = 0
    !!! highest number of neighbors on this processor

    CONTAINS
        PRIVATE
        PROCEDURE :: destroy => neigh_destroy_d

END TYPE ppm_t_neighlist_d

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold neighlists
!----------------------------------------------------------------------
TYPE ppm_ptr_t_neighlist_d
    TYPE(ppm_t_neighlist_d), POINTER  :: t => NULL()
END TYPE ppm_ptr_t_neighlist_d


TYPE ppm_t_opdesc_d
    !!! Data structure to describe differential operator
    !!!  It only contains semantic information on the operator
    INTEGER, DIMENSION(:), POINTER                 :: degree =>NULL()
    !!! degree of each term in the linear combination of differential ops 
    INTEGER, DIMENSION(:), POINTER                 :: order =>NULL()
    !!! approximation order of each term 
    REAL(ppm_kind_double), DIMENSION(:), POINTER                :: coeffs =>NULL()
    !!! array where the coefficients in linear combinations of 
    !!! differential ops are stored
    INTEGER                                        :: nterms
    !!! number of terms
    CHARACTER(LEN=ppm_char)                        :: name
    !!! name of the vector-valued property

    CONTAINS
        PRIVATE
        PROCEDURE :: create => desc_create_d
        PROCEDURE :: destroy => desc_destroy_d

END TYPE ppm_t_opdesc_d

TYPE ppm_t_operator_d
    !!! Data structure containing all diff operators for a particle set
    !!! 
    REAL(ppm_kind_double),DIMENSION(:,:),               POINTER :: ker => NULL()
    !!! where the operators are stored
    TYPE(ppm_t_opdesc_d),             POINTER :: desc => NULL()
    !!! small matrices that describe what each operator does
    INTEGER                                        :: P_id = 0
    !!! Id of the set of particles that this operator takes data from.
    !!! The default, 0, stands for "self" (the operator is computed
    !!! on the same set of particles than the one which contains the data).
    INTEGER                                        :: neigh_id = 1
    !!! Id of the neighbour list that should be used
    !!! The default, 1, refers to "self": the list of neighbours within
    !!! the same set of particles. 

    LOGICAL, DIMENSION(ppm_param_length_opsflags)  :: flags
    !!! logical flags
    !!!    ppm_ops_inc_ghosts
    !!!           true if the operator should be computed for ghost 
    !!!           particles too.  Note that the resulting values 
    !!!           will be wrong for the ghost particles
    !!!           that have some neighbours outside the ghost layers. 
    !!!           Default is false.
    !!!    ppm_ops_interp
    !!!          true if the op interpolates data from one set of particles
    !!!    ppm_ops_iscomputed
    !!!          true if the operator has been computed and is uptodate
    !!!    ppm_ops_isdefined
    !!!          true if the operator has been defined 
    !!!    ppm_ops_vector
    !!!          true if each term represents a component (ie the result
    !!!          of the operator should be a vector field, like for gradients)
    !!!          false if the components are added up (like for the divergence)

    CONTAINS
        PRIVATE
        PROCEDURE :: create => op_create_d
        PROCEDURE :: destroy => op_destroy_d

END TYPE ppm_t_operator_d

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold operators
!----------------------------------------------------------------------
TYPE ppm_ptr_ops_d
    TYPE(ppm_t_operator_d), POINTER :: t => NULL()
END TYPE ppm_ptr_ops_d

TYPE particles_stats_d
    !!! Data structure containing statistics about a particle set
    !!! 
    INTEGER                                          :: nb_nl = 0
    !!! number of neighbour lists constructions
    INTEGER                                          :: nb_inl = 0
    !!! number of inhomogeneous neighbour lists constructions
    INTEGER                                          :: nb_cinl = 0
    !!! number of conventional (old and depreciated) inl constructions
    INTEGER                                          :: nb_xset_inl = 0
    !!! number of xset inhomogeneous neighbour lists constructions
    INTEGER                                          :: nb_xset_nl = 0
    !!! number of xset neighbour lists constructions
    INTEGER                                          :: nb_dc_comp = 0
    !!! number of DC operators computation (matrix inversions)
    INTEGER                                          :: nb_dc_apply = 0
    !!! number of DC operators evaluation (no matrix inversions)
    INTEGER                                          :: nb_kdtree = 0
    !!! number of kdtree constructions
    INTEGER                                          :: nb_global_map = 0
    !!! number of global mappings
    INTEGER                                          :: nb_part_map = 0
    !!! number of partial mappings
    INTEGER                                          :: nb_ghost_get = 0
    !!! number of partial mappings
    INTEGER                                          :: nb_ghost_push = 0
    !!! number of partial mappings
    REAL(ppm_kind_double)                                       :: t_nl = 0._ppm_kind_double
    !!! time spent for neighbour lists constructions
    REAL(ppm_kind_double)                                       :: t_inl = 0._ppm_kind_double
    !!! time spent for inhomogeneous neighbour lists constructions
    REAL(ppm_kind_double)                                       :: t_cinl = 0._ppm_kind_double
    !!! time spent for conventional (old and depreciated) inl constructions
    REAL(ppm_kind_double)                                       :: t_xset_inl = 0._ppm_kind_double
    !!! time spent for xset inhomogeneous neighbour lists constructions
    REAL(ppm_kind_double)                                       :: t_xset_nl = 0._ppm_kind_double
    !!! time spent for xset neighbour lists constructions
    REAL(ppm_kind_double)                                       :: t_dc_comp = 0._ppm_kind_double
    !!! time spent for DC operators computation (matrix inversions)
    REAL(ppm_kind_double)                                       :: t_dc_apply = 0._ppm_kind_double
    !!! time spent for DC operators evaluation (no matrix inversions)
    REAL(ppm_kind_double)                                       :: t_kdtree = 0._ppm_kind_double
    !!! time spent for kdtree constructions
    REAL(ppm_kind_double)                                       :: t_global_map = 0._ppm_kind_double
    !!! time spent for global mappings
    REAL(ppm_kind_double)                                       :: t_part_map = 0._ppm_kind_double
    !!! time spent for partial mappings
    REAL(ppm_kind_double)                                       :: t_ghost_get = 0._ppm_kind_double
    !!! time spent for partial mappings
    REAL(ppm_kind_double)                                       :: t_ghost_push = 0._ppm_kind_double
    !!! time spent for partial mappings

    INTEGER                                          :: nb_ls = 0
    REAL(ppm_kind_double)                                       :: t_ls = 0._ppm_kind_double
    REAL(ppm_kind_double)                                       :: t_add = 0._ppm_kind_double
    REAL(ppm_kind_double)                                       :: t_del = 0._ppm_kind_double
    REAL(ppm_kind_double)                                       :: t_compD = 0._ppm_kind_double

END TYPE particles_stats_d

!----------------------------------------------------------------------
! Container class
!----------------------------------------------------------------------
TYPE, ABSTRACT :: ppm_t_container_d
    INTEGER                                         :: nb = 0
    !!! number of different instances
    INTEGER                                         :: iter_id = 0
    !!! index at which the iterator is currently pointing
    INTEGER                                         :: min_id = HUGE(1)
    !!! smallest non-null index in the array
    INTEGER                                         :: max_id = 0
    !!! highest non-null index in the array
    INTEGER                                         :: vec_size = 0
    !!! current allocated size of the array
    CONTAINS
        PROCEDURE       :: exists => part_DS_exists_d
END TYPE ppm_t_container_d

!ABSTRACT INTERFACE
!    FUNCTION begin_d(this) RESULT(iterator)
!        IMPORT ppm_t_container_d
!        CLASS(ppm_t_container_d), INTENT(IN) :: this
!        CLASS(*), POINTER    :: iterator
!    END FUNCTION begin_d
!END INTERFACE
!ABSTRACT INTERFACE
!    FUNCTION next_d(this) RESULT(iterator)
!        IMPORT ppm_t_container_d
!        CLASS(ppm_t_container_d), INTENT(IN) :: this
!        CLASS(*), POINTER  :: iterator
!    END FUNCTION next_d
!END INTERFACE

!----------------------------------------------------------------------
! Container for properties
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_d) ::  ppm_c_props_d
    TYPE(ppm_ptr_part_prop_d),DIMENSION(:),POINTER :: vec => NULL()
    !!! array with pointers to each property for this particle set
    TYPE(ppm_t_part_prop_d),              POINTER  :: iterator => NULL()
    CONTAINS
        PRIVATE
        PROCEDURE, PUBLIC       :: begin => begin_prop_d
        PROCEDURE, PUBLIC       :: next => next_prop_d
        PROCEDURE       :: last => last_prop_d
        PROCEDURE       :: prev => prev_prop_d
        PROCEDURE       :: destroy => prop_container_destroy_d

        PROCEDURE     :: data_1d_i_check_d
        PROCEDURE     :: data_2d_i_check_d
        PROCEDURE     :: data_1d_li_check_d
        PROCEDURE     :: data_2d_li_check_d
        PROCEDURE     :: data_1d_r_check_d
        PROCEDURE     :: data_2d_r_check_d
        PROCEDURE     :: data_1d_c_check_d
        PROCEDURE     :: data_2d_c_check_d
        PROCEDURE     :: data_1d_l_check_d
        PROCEDURE     :: data_2d_l_check_d


        !NOTE: for some reason, this does not work
        ! (ifort crashes at compile time if there is a call
        !  to this%checktype(wp,wpid,info) )
        ! One can call the not-overloaded procedures directly,
        ! but thats very annoying...
        GENERIC, PUBLIC :: checktype => & 
            data_1d_i_check_d,&
            data_2d_i_check_d,&
            data_1d_li_check_d,&
            data_2d_li_check_d,&
            data_1d_r_check_d,&
            data_2d_r_check_d,&
            data_1d_c_check_d,&
            data_2d_c_check_d,&
            data_1d_l_check_d,&
            data_2d_l_check_d
END TYPE ppm_c_props_d
!----------------------------------------------------------------------
! Container for operators
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_d) ::  ppm_c_operators_d
    TYPE(ppm_ptr_ops_d),DIMENSION(:),POINTER :: vec => NULL()
    !!! array with pointers to each differential operator for this particle set
    TYPE(ppm_t_operator_d),          POINTER :: iterator => NULL()
    CONTAINS
        PROCEDURE       :: begin => begin_op_d
        PROCEDURE       :: next => next_op_d
        PROCEDURE       :: last => last_op_d
        PROCEDURE       :: prev => prev_op_d
        PROCEDURE       :: destroy => op_container_destroy_d
END TYPE ppm_c_operators_d
!----------------------------------------------------------------------
! Container for neighbour lists
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_d) ::  ppm_c_neighlists_d
    TYPE(ppm_ptr_t_neighlist_d),DIMENSION(:),POINTER :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    TYPE(ppm_t_neighlist_d),                 POINTER :: iterator => NULL()
    CONTAINS
        PROCEDURE       :: begin => begin_neigh_d
        PROCEDURE       :: next => next_neigh_d
        PROCEDURE       :: last => last_neigh_d
        PROCEDURE       :: prev => prev_neigh_d
        PROCEDURE       :: destroy => neigh_container_destroy_d
END TYPE ppm_c_neighlists_d

!----------------------------------------------------------------------
! Container for lists of (pointers to) Particle clouds
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_d) ::  ppm_c_Pc_d
    TYPE(ppm_ptr_t_particles_d),DIMENSION(:), POINTER :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    CLASS(ppm_t_particles_d),                 POINTER :: iterator => NULL()
!    CONTAINS
!        PROCEDURE       :: begin => begin_pc_d
!        PROCEDURE       :: next => next_pc_d
!        PROCEDURE       :: last => last_pc_d
!        PROCEDURE       :: prev => prev_pc_d
!        PROCEDURE       :: destroy => pc_container_destroy_d
END TYPE ppm_c_Pc_d

!----------------------------------------------------------------------
! Container for particle mappings
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_d) ::  ppm_c_pmaps_d
    TYPE(ppm_ptr_t_part_mapping_d),DIMENSION(:), POINTER :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    CLASS(ppm_t_part_mapping_d),                 POINTER :: iterator => NULL()
!    CONTAINS
!        PROCEDURE       :: begin => begin_pc_d
!        PROCEDURE       :: next => next_pc_d
!        PROCEDURE       :: last => last_pc_d
!        PROCEDURE       :: prev => prev_pc_d
!        PROCEDURE       :: destroy => pc_container_destroy_d
END TYPE ppm_c_pmaps_d

!----------------------------------------------------------------------
! Container for lists of (pointers to) adaptive Particle clouds
!----------------------------------------------------------------------
TYPE, EXTENDS(ppm_t_container_d) ::  ppm_c_aPc_d
    TYPE(ppm_ptr_t_sop_d),DIMENSION(:),POINTER  :: vec => NULL()
    !!! array with pointers to each neighbor list for this particle set
    CLASS(ppm_t_sop_d),                 POINTER :: iterator => NULL()
!    CONTAINS
!        PROCEDURE       :: begin => begin_pc_d
!        PROCEDURE       :: next => next_pc_d
!        PROCEDURE       :: last => last_pc_d
!        PROCEDURE       :: prev => prev_pc_d
!        PROCEDURE       :: destroy => pc_container_destroy_d
END TYPE ppm_c_aPc_d

TYPE ppm_t_particles_d
    !!! Data structure for a particle set

    CHARACTER(LEN=ppm_char)                         :: name
    !!! name for this particle set
    REAL(ppm_kind_double), DIMENSION(:,:), POINTER               :: xp => NULL()
    !!! positions of the particles
    INTEGER                                         :: Npart
    !!! Number of real particles on this processor
    INTEGER                                         :: Mpart
    !!! Number of particles (including ghosts) on this processor
    LOGICAL, DIMENSION(ppm_param_length_partflags)  :: flags
    !!! logical flags
    !!!    ppm_part_ghosts
    !!!          true if ghost values are up-to-date
    !!!    ppm_part_partial
    !!!          true if the particles have been mapped on the active topology
    !!!    ppm_part_reqput
    !!!    ppm_part_areinside
    !!!          true if all the particles are inside the comp. domain
    !!!    ppm_part_cartesian
    !!!          true if the particles form a Cartesian grid
    !!!    ppm_part_neighlists
    !!!          true if neighbour lists within this particle cloud are
    !!!          up-to-date
    !!!    ppm_part_global_index
    !!!          true if particles have an uptodate global index


    ! Topology (links between Particles and topologies)
    INTEGER                                         :: active_topoid
    !!! Topology on which particles are currently mapped

    ! Special data IDs
    INTEGER                                         :: gi_ID
    !!! Global index


    !ghost layers
    REAL(ppm_kind_double)                                        :: ghostlayer
    !!! ghost layer size used for ghost mapping
    !!! (note: could in principle be different from the cutoff used to 
    !!!  compute the neighbour lists)
    INTEGER                                         :: isymm

    ! Container for Particles properties
    TYPE(ppm_c_props_d)                        :: props


    ! Container for Neighbor lists
    TYPE(ppm_c_neighlists_d)                   :: neighs


    ! Container for differential operators
    TYPE(ppm_c_operators_d)                    :: ops


    ! Container for particle mappings
    TYPE(ppm_c_pmaps_d)                        :: maps

    ! Container for lists of (pointers to) other particle clouds
    TYPE(ppm_c_Pc_d)                           :: set_Pc


    ! Load balancing
    REAL(ppm_kind_double), DIMENSION(:), POINTER                 :: pcost=> NULL()
    !!! cost associated to each particle 


    ! stats
    TYPE(particles_stats_d)                    :: stats
    !!! runtime statistics (e.g. timings, memory)


    ! clocks
    REAL(ppm_kind_double)                                        :: time
    !!! clock for this set of particles
    INTEGER                                         :: itime
    !!! iteration number for this set of particles


    !------------miscellaneous----------

    ! spacings between particles
    REAL(ppm_kind_double)                                      :: h_avg
    !!! (global) average distance between particles
    REAL(ppm_kind_double)                                      :: h_min
    !!! (global) minimum distance between particles
    
    CONTAINS
        PRIVATE
        PROCEDURE     :: create => part_create_d
        PROCEDURE     :: destroy => part_destroy_d
        PROCEDURE     :: initialize => part_initialize_d
        PROCEDURE     :: del_parts => part_del_parts_d

        PROCEDURE     :: create_prop => part_prop_create_d
        PROCEDURE     :: destroy_prop => part_prop_destroy_d
        PROCEDURE     :: realloc_prop => part_prop_realloc_d

        PROCEDURE     :: create_neighlist => part_neigh_create_d
        PROCEDURE     :: set_cutoff => part_set_cutoff_d
        PROCEDURE     :: destroy_neighlist => part_neigh_destroy_d
        PROCEDURE     :: comp_neighlist => part_neighlist_d
        PROCEDURE     :: get_nvlist => get_nvlist_d
        PROCEDURE     :: get_vlist => get_vlist_d

        PROCEDURE     :: create_op => part_op_create_d
        PROCEDURE     :: destroy_op => part_op_destroy_d
        PROCEDURE     :: ppm_dcop_compute2d_d
        PROCEDURE     :: ppm_dcop_compute3d_d
        PROCEDURE     :: comp_op => part_op_compute_d
        PROCEDURE     :: apply_op => part_op_apply_d
 !       PROCEDURE     :: updated_positions => part_updated_positions_d

        PROCEDURE     :: map_part_push_legacy => part_prop_push_d
        PROCEDURE     :: map_part_pop_legacy => part_prop_pop_d
        PROCEDURE     :: map => part_mapping_d
        PROCEDURE     :: map_ghosts => part_mapping_ghosts_d

        PROCEDURE     :: move => part_move_d
        PROCEDURE     :: apply_bc => part_apply_bc_d


        PROCEDURE     :: print_info => part_print_info_d

        PROCEDURE     :: comp_global_index => part_comp_global_index_d

        PROCEDURE     :: get_xp => get_xp_d
        PROCEDURE     :: set_xp => set_xp_d
        PROCEDURE     :: get_dcop => get_dcop_d
        PROCEDURE     :: set_dcop => set_dcop_d
        PROCEDURE     :: data_1d_i_get_d
        PROCEDURE     :: data_2d_i_get_d
        PROCEDURE     :: data_1d_li_get_d
        PROCEDURE     :: data_2d_li_get_d
        PROCEDURE     :: data_1d_r_get_d
        PROCEDURE     :: data_2d_r_get_d
        PROCEDURE     :: data_1d_c_get_d
        PROCEDURE     :: data_2d_c_get_d
        PROCEDURE     :: data_1d_l_get_d
        PROCEDURE     :: data_2d_l_get_d

        PROCEDURE     :: data_1d_i_set_d
        PROCEDURE     :: data_2d_i_set_d
        PROCEDURE     :: data_1d_li_set_d
        PROCEDURE     :: data_2d_li_set_d
        PROCEDURE     :: data_1d_r_set_d
        PROCEDURE     :: data_2d_r_set_d
        PROCEDURE     :: data_1d_c_set_d
        PROCEDURE     :: data_2d_c_set_d
        PROCEDURE     :: data_1d_l_set_d
        PROCEDURE     :: data_2d_l_set_d
        GENERIC, PUBLIC :: get =>  &
            data_1d_i_get_d,&
            data_2d_i_get_d,&
            data_1d_li_get_d,&
            data_2d_li_get_d,&
            data_1d_r_get_d,&
            data_2d_r_get_d,&
            data_1d_c_get_d,&
            data_2d_c_get_d,&
            data_1d_l_get_d,&
            data_2d_l_get_d
        GENERIC, PUBLIC :: set =>  &
            data_1d_i_set_d,&
            data_2d_i_set_d,&
            data_1d_li_set_d,&
            data_2d_li_set_d,&
            data_1d_r_set_d,&
            data_2d_r_set_d,&
            data_1d_c_set_d,&
            data_2d_c_set_d,&
            data_1d_l_set_d,&
            data_2d_l_set_d

        PROCEDURE       :: create_map => part_map_create_d
        PROCEDURE       :: destroy_map => part_map_destroy_d
        PROCEDURE       :: map_part_send_d

        PROCEDURE       :: map_part_pop_1d_d
        PROCEDURE       :: map_part_pop_1dc_d
        PROCEDURE       :: map_part_pop_1di_d
        PROCEDURE       :: map_part_pop_1dl_d
        PROCEDURE       :: map_part_pop_2d_d
        PROCEDURE       :: map_part_pop_2dc_d
        PROCEDURE       :: map_part_pop_2di_d
        PROCEDURE       :: map_part_pop_2dl_d
        PROCEDURE       :: map_part_push_1d_d
        PROCEDURE       :: map_part_push_1dc_d
        PROCEDURE       :: map_part_push_1di_d
        PROCEDURE       :: map_part_push_1dl_d
        PROCEDURE       :: map_part_push_2d_d
        PROCEDURE       :: map_part_push_2dc_d
        PROCEDURE       :: map_part_push_2di_d
        PROCEDURE       :: map_part_push_2dl_d

        GENERIC, PUBLIC ::  map_part_pop => &
            map_part_pop_1d_d,&
            map_part_pop_1dc_d,&
            map_part_pop_1di_d,&
            map_part_pop_1dl_d,&
            map_part_pop_2d_d,&
            map_part_pop_2dc_d,&
            map_part_pop_2di_d,&
            map_part_pop_2dl_d
        GENERIC, PUBLIC ::  map_part_push => &
            map_part_push_1d_d,&
            map_part_push_1dc_d,&
            map_part_push_1di_d,&
            map_part_push_1dl_d,&
            map_part_push_2d_d,&
            map_part_push_2dc_d,&
            map_part_push_2di_d,&
            map_part_push_2dl_d

END TYPE ppm_t_particles_d

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold ppm_t_particles
!----------------------------------------------------------------------
TYPE ppm_ptr_t_particles_d
    TYPE(ppm_t_particles_d), POINTER  :: t => NULL()
END TYPE ppm_ptr_t_particles_d


TYPE, EXTENDS(ppm_t_particles_d) :: ppm_t_sop_d
    !!! an extension of the Particle cloud data structure
    !!! for Self-Organizing Particles

    INTEGER                                         :: nn_sq_id
    !!! index of the wps array where nearest-neighbour distances are stored

    ! Adaptive particles
    LOGICAL                                         :: adaptive
    !!! true if the particles have their own cutoff radii
    !!! in this case, the cutoff will be stored in wps(rcp_id)%vec
    INTEGER                                         :: rcp_id
    !!! index of the wps array where the cutoff radius is stored
    INTEGER                                         :: D_id
    !!! index of the wps array where D is stored
    INTEGER                                         :: Dtilde_id
    !!! index of the wps array where D_tilde is stored
    INTEGER                                         :: adapt_wpid
    !!! index of the wps array where is stored the property on 
    !!! which adaptation is based 
    !!! default is first 1d property that is not rcp_id (if any)
    !!! otherwise, it is rcp_id
    !    INTEGER                                         :: adapt_wpgradid
    !    !!! index of the wpv array where is stored the gradient of the property 
    !    !!! on which adaptation is based (if needed)
    LOGICAL                                         :: level_set
    !!! true if particles carry a level-set function
    INTEGER                                         :: level_id
    !!! index of the wps array where the level-set is stored
    !    INTEGER                                         :: level_old_id
    !!! index of the wps array where the level-set is backed up before adapt

    INTEGER                                         :: level_grad_id
    !!! index of the wps array where the gradient of the level-set is stored
    !    INTEGER                                         :: level_grad_old_id
    !!! index of the wps array where the gradient of the level-set 
    !!! is backed up before adapt


    ! Container for lists of (pointers to) other adaptive particle clouds
    TYPE(ppm_c_aPc_d)                          :: set_aPc


    ! Anisotropic particles
    LOGICAL                                         :: anisotropic
    !!! true if the particles have their own cutoff radii
    !!! in this case, the G tensor will be stored in wpv(G_id)%vec
    INTEGER                                         :: G_id
    !!! index where G is stored

!    CONTAINS
!        PRIVATE
!        PROCEDURE     :: create => sop_part_create_d


END TYPE ppm_t_sop_d

!----------------------------------------------------------------------
! Wrapper type to be able to have a pointer array to hold ppm_t_sop
!----------------------------------------------------------------------
TYPE ppm_ptr_t_sop_d
    TYPE(ppm_t_sop_d), POINTER  :: t => NULL()
END TYPE ppm_ptr_t_sop_d


CHARACTER(LEN=ppm_char)         :: cbuf
CHARACTER(LEN=ppm_char)         :: line_of_stars='**************************'
INTEGER, PRIVATE, DIMENSION(3)    :: ldc
!!! Number of elements in all dimensions for allocation

PUBLIC :: ppm_t_particles_s, ppm_t_particles_d
PUBLIC :: ppm_t_sop_s, ppm_t_sop_d
PUBLIC :: ppm_t_part_prop_s, ppm_t_part_prop_d


CONTAINS


FUNCTION particles_dflt_partname(i)
    !!! Default name for a set of particles
    CHARACTER(LEN=ppm_char)   :: particles_dflt_partname
    INTEGER,OPTIONAL          :: i
    CHARACTER(LEN=ppm_char)   :: buf

    IF (PRESENT(i)) THEN
        WRITE(buf,*) i
        WRITE(particles_dflt_partname,*) 'Particles_',ADJUSTL(TRIM(buf))
    ELSE
        WRITE(particles_dflt_partname,*) 'Particles'
    ENDIF
    RETURN
END FUNCTION

FUNCTION particles_dflt_pptname(i,ndim)
    !!! Default name for a scalar or vector property
    CHARACTER(LEN=ppm_char)   :: particles_dflt_pptname
    INTEGER                   :: i,ndim
    CHARACTER(LEN=ppm_char)   :: buf

    WRITE(buf,*) i
    IF (ndim .EQ. 1) THEN
        WRITE(particles_dflt_pptname,*) 'property_s',ADJUSTL(TRIM(buf))
    ELSE
        WRITE(particles_dflt_pptname,*) 'property_v',ADJUSTL(TRIM(buf))
    ENDIF
    RETURN
END FUNCTION

FUNCTION particles_dflt_nlname(i)
    !!! Default name for an operator
    CHARACTER(LEN=ppm_char)   :: particles_dflt_nlname
    INTEGER                   :: i
    CHARACTER(LEN=ppm_char)   :: buf

    WRITE(buf,*) i
    WRITE(particles_dflt_nlname,*) 'neighlist_',ADJUSTL(TRIM(buf))
    RETURN
END FUNCTION


FUNCTION particles_dflt_opname(i)
    !!! Default name for an operator
    CHARACTER(LEN=ppm_char)   :: particles_dflt_opname
    INTEGER                   :: i
    CHARACTER(LEN=ppm_char)   :: buf

    WRITE(buf,*) i
    WRITE(particles_dflt_opname,*) 'operator_',ADJUSTL(TRIM(buf))
    RETURN
END FUNCTION

FUNCTION color_print(text,color)
    !!! Return a string that will appear in color if printed out to the terminal
    CHARACTER(LEN=ppm_char)   :: color_print
    CHARACTER(LEN=*)          :: text
    CHARACTER(LEN=10)         :: mycolor
    INTEGER                   :: color

    write(mycolor,'(A,I0,A)') '[',color,'m'
    color_print = achar(27)//TRIM(mycolor)//TRIM(ADJUSTL(text))//achar(27)//'[0m'
    RETURN

END FUNCTION


FUNCTION factorial_m(multi_ind,ndim)
    INTEGER                 :: factorial_m,i,ndim
    INTEGER,DIMENSION(ndim) :: multi_ind

    factorial_m = 1
    DO i=1,ndim
        factorial_m = factorial_m * factorial(multi_ind(i))
    ENDDO
END FUNCTION factorial_m

FUNCTION factorial(n)
    INTEGER    :: n,i
    INTEGER    :: factorial
    factorial = 1
    DO i=1,n
        factorial = i*factorial
    ENDDO
    RETURN
END FUNCTION factorial

FUNCTION binomial(n,k)
    INTEGER    :: n,k
    INTEGER    :: binomial
    binomial = factorial(n)/(factorial(k)*factorial(n-k))
END FUNCTION binomial





SUBROUTINE data_1d_i_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    INTEGER,DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_int&
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_i_check_s

SUBROUTINE data_1d_i_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER,DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_i_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_i(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_i(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_i(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_i(1)

END SUBROUTINE data_1d_i_get_s


SUBROUTINE data_1d_i_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER,DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_i_set_s



SUBROUTINE data_1d_li_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    INTEGER(ppm_kind_int64),DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_longint& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_li_check_s

SUBROUTINE data_1d_li_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER(ppm_kind_int64),DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_li_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_li(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_li(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_li(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_li(1)

END SUBROUTINE data_1d_li_get_s


SUBROUTINE data_1d_li_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER(ppm_kind_int64),DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_li_set_s



SUBROUTINE data_1d_r_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    REAL(ppm_kind_single),DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_real& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_r_check_s

SUBROUTINE data_1d_r_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    REAL(ppm_kind_single),DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_r_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_r(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_r(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_r(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_r(1)

END SUBROUTINE data_1d_r_get_s


SUBROUTINE data_1d_r_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    REAL(ppm_kind_single),DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_r_set_s



SUBROUTINE data_1d_c_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    COMPLEX(ppm_kind_single),DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_comp& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_c_check_s

SUBROUTINE data_1d_c_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    COMPLEX(ppm_kind_single),DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_c_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_c(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_c(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_c(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_c(1)

END SUBROUTINE data_1d_c_get_s


SUBROUTINE data_1d_c_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    COMPLEX(ppm_kind_single),DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_c_set_s



SUBROUTINE data_1d_l_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    LOGICAL,DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_logical& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_l_check_s

SUBROUTINE data_1d_l_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    LOGICAL,DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_l_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_l(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_l(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_l(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_l(1)

END SUBROUTINE data_1d_l_get_s


SUBROUTINE data_1d_l_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    LOGICAL,DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_l_set_s




SUBROUTINE data_2d_i_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    INTEGER,DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_int&
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_i_check_s

SUBROUTINE data_2d_i_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER,DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_i_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_i(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_i(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_i(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_i(1,1)

END SUBROUTINE data_2d_i_get_s


SUBROUTINE data_2d_i_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER,DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_i_set_s



SUBROUTINE data_2d_li_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_longint& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_li_check_s

SUBROUTINE data_2d_li_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_li_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_li(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_li(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_li(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_li(1,1)

END SUBROUTINE data_2d_li_get_s


SUBROUTINE data_2d_li_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_li_set_s



SUBROUTINE data_2d_r_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    REAL(ppm_kind_single),DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_real& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_r_check_s

SUBROUTINE data_2d_r_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    REAL(ppm_kind_single),DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_r_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_r(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_r(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_r(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_r(1,1)

END SUBROUTINE data_2d_r_get_s


SUBROUTINE data_2d_r_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    REAL(ppm_kind_single),DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_r_set_s



SUBROUTINE data_2d_c_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    COMPLEX(ppm_kind_single),DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_comp& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_c_check_s

SUBROUTINE data_2d_c_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    COMPLEX(ppm_kind_single),DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_c_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_c(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_c(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_c(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_c(1,1)

END SUBROUTINE data_2d_c_get_s


SUBROUTINE data_2d_c_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    COMPLEX(ppm_kind_single),DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_c_set_s



SUBROUTINE data_2d_l_check_s(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_s)                           :: props
    !!! Data structure containing the particles
    LOGICAL,DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_logical& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_l_check_s

SUBROUTINE data_2d_l_get_s(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER                         :: ppt_id
    LOGICAL,DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_l_check_s(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_l(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_l(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_l(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_l(1,1)

END SUBROUTINE data_2d_l_get_s


SUBROUTINE data_2d_l_set_s(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_s)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    LOGICAL,DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_l_set_s


SUBROUTINE get_xp_s(Pc,xp,with_ghosts)
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)         :: Pc
    LOGICAL,OPTIONAL                      :: with_ghosts
    REAL(MK),DIMENSION(:,:),     POINTER  :: xp
    INTEGER                               :: info

    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            IF (Pc%flags(ppm_part_ghosts)) THEN
                xp => Pc%xp(1:ppm_dim,1:Pc%Mpart)
            ELSE
                write(cbuf,*) 'WARNING: tried to get xp with ghosts ',&
                    'when ghosts are not up-to-date'
                CALL ppm_write(ppm_rank,'get_xp',cbuf,info)
                xp => NULL()
            ENDIF
            RETURN
        ENDIF
    ENDIF

    xp => Pc%xp(1:ppm_dim,1:Pc%Npart)

END SUBROUTINE get_xp_s

SUBROUTINE set_xp_s(Pc,xp,read_only,ghosts_ok)
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)    :: Pc
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    REAL(MK),DIMENSION(:,:),POINTER  :: xp
    INTEGER                          :: i

    TYPE(ppm_t_part_prop_s), POINTER :: prop => NULL()
    TYPE(ppm_t_neighlist_s), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_s),  POINTER :: op => NULL()

    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            xp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            xp => NULL()
            RETURN
        ENDIF
    ENDIF

    Pc%flags(ppm_part_areinside) = .FALSE.
    Pc%flags(ppm_part_partial) = .FALSE.
    Pc%flags(ppm_part_ghosts) = .FALSE.
    Pc%flags(ppm_part_cartesian) = .FALSE.

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        prop%flags(ppm_ppt_ghosts) = .FALSE.
        prop%flags(ppm_ppt_partial) = .FALSE.
        prop => Pc%props%next()
    ENDDO

    nl => Pc%neighs%begin()
    DO WHILE (ASSOCIATED(nl))
        nl%uptodate = .FALSE.
        nl => Pc%neighs%next()
    ENDDO

    op => Pc%ops%begin()
    DO WHILE (ASSOCIATED(op))
        op%flags(ppm_ops_iscomputed) = .FALSE.
        op => Pc%ops%next()
    ENDDO

    xp => NULL()

END SUBROUTINE set_xp_s

SUBROUTINE part_prop_create_s(Pc,id,datatype,info,&
        lda,name,zero,with_ghosts)
    !!! Adds a property to an existing particle set
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(  OUT) :: id
    INTEGER,                INTENT(IN   ) :: datatype
    INTEGER, OPTIONAL,      INTENT(IN   ) :: lda
    CHARACTER(LEN=*) , OPTIONAL           :: name
    !!! name to this property
    LOGICAL, OPTIONAL                     :: zero
    !!! if true, then initialise the data to zero
    LOGICAL, OPTIONAL                     :: with_ghosts
    !!! if true, then allocate with Mpart instead of the default size of Npart
    INTEGER,               INTENT(OUT)    :: info

    INTEGER                               :: lda2,vec_size,npart,i
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_prop_create'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_part_prop_s),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_part_prop_s),               POINTER  :: prop => NULL()
    LOGICAL, DIMENSION(ppm_param_length_pptflags):: flags

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%props )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of property pointers
            id = id + 1
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of property pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',123,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of property pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',134,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE

    IF (.NOT. ASSOCIATED(Pc%props%vec(id)%t)) THEN
        ALLOCATE(Pc%props%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating property pointer failed',159,info)
            GOTO 9999
        ENDIF
    ENDIF

    prop => Pc%props%vec(id)%t

    !
    lda2 = 1
    IF (PRESENT(lda)) THEN
        IF (lda.GE.2) THEN
            lda2 = lda
        ENDIF
    ENDIF

    IF (PRESENT(name)) THEN
        name2 = name
    ELSE
        name2 = particles_dflt_pptname(id,1)
    ENDIF

    npart = Pc%Npart
    flags = .FALSE.
    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            IF (Pc%flags(ppm_part_ghosts)) THEN
                npart = Pc%Mpart
                flags(ppm_ppt_ghosts) = .TRUE.
            ELSE
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,&
            'trying to init property for ghosts when ghosts are not computed',&
                    191,info)
                GOTO 9999
            ENDIF
        ENDIF
    ENDIF
    flags(ppm_ppt_partial) = .TRUE.
    flags(ppm_ppt_map_ghosts) = .TRUE.
    flags(ppm_ppt_map_parts) = .TRUE.


    ! Create the property
    CALL prop%create(datatype,npart,lda2,name2,flags,info,zero)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating property array failed',206,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_prop_create_s

SUBROUTINE part_prop_destroy_s(Pc,id,info)
    !!! Destroy a property from an existing particle set
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_prop_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%props)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'property id larger than size of properties array',&
                231,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            259,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE


    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_prop_destroy_s

SUBROUTINE part_prop_realloc_s(Pc,id,info,with_ghosts,datatype,lda)
    !!! Reallocate the property array to the correct size
    !!! (e.g. if the number of particles has changed or if the type
    !!! of the data changes)
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(IN   ) :: id
    INTEGER,               INTENT(OUT)    :: info
    LOGICAL, OPTIONAL                     :: with_ghosts
    !!! if true, then allocate with Mpart instead of the default size of Npart
    INTEGER, OPTIONAL                     :: datatype
    !!! deallocate the old data array and allocate a new one,
    !!! possibly of a different data type.
    INTEGER, OPTIONAL                     :: lda
    !!! deallocate the old data array and allocate a new one,
    !!! possibly of a different dimension

    INTEGER                               :: lda2,vec_size,npart,i,dtype
    CHARACTER(LEN=ppm_char)               :: caller = 'realloc_prop'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_part_prop_s),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_part_prop_s),               POINTER  :: prop => NULL()
    LOGICAL, DIMENSION(ppm_param_length_pptflags):: flags

    CALL substart(caller,t0,info)

    IF (.NOT. ASSOCIATED(Pc%props%vec(id)%t)) THEN
        ALLOCATE(Pc%props%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating property pointer failed',305,info)
            GOTO 9999
        ENDIF
    ENDIF

    prop => Pc%props%vec(id)%t
    flags = prop%flags
    name2 = prop%name

    npart = Pc%Npart
    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            IF (Pc%flags(ppm_part_ghosts)) THEN
                npart = Pc%Mpart
                flags(ppm_ppt_ghosts) = .TRUE.
            ELSE
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,&
            'trying to init property for ghosts when ghosts are not computed',&
                    324,info)
                GOTO 9999
            ENDIF
        ENDIF
    ENDIF
    flags(ppm_ppt_partial) = .TRUE.

    IF (PRESENT(lda)) THEN
        lda2 = lda
    ELSE
        lda2 = prop%lda
    ENDIF
    IF (PRESENT(datatype)) THEN
        dtype = datatype
    ELSE
        dtype = prop%data_type
    ENDIF
    IF (lda2.NE.prop%lda .OR. dtype.NE.prop%data_type) THEN
        CALL prop%destroy(info)
    ENDIF

    ! Create the property
    CALL prop%create(dtype,npart,lda2,name2,flags,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'reallocating property array failed',350,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_prop_realloc_s

SUBROUTINE prop_create_s(prop,datatype,npart,lda,name,flags,info,zero)
    !!! Constructor for particle property data structure
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_part_prop_s)      :: prop
    INTEGER,                INTENT(IN) :: datatype
    INTEGER,                INTENT(IN) :: npart
    INTEGER,                INTENT(IN) :: lda
    CHARACTER(LEN=*)                   :: name
    !!! name to this property
    LOGICAL, DIMENSION(ppm_param_length_pptflags),INTENT(IN) :: flags
    INTEGER,               INTENT(OUT) :: info
    LOGICAL, OPTIONAL,     INTENT( IN) :: zero
    !!! if true, then initialize the data to zero

    REAL(KIND(1.D0))                   :: t0
    INTEGER                            :: iopt
    CHARACTER(LEN=ppm_char)            :: caller = 'prop_create'
    LOGICAL                            :: is2d
    LOGICAL                            :: zero_data



    CALL substart(caller,t0,info)

    prop%lda       = lda
    prop%data_type = datatype
    prop%name      = name
    prop%flags     = flags

    IF (PRESENT(zero)) THEN
        zero_data = zero
    ELSE
        zero_data = .FALSE.
    ENDIF


    iopt   = ppm_param_alloc_grow

    IF (lda.GE.2) THEN
        ldc(1) = lda
        ldc(2) = npart
        is2d = .TRUE.
    ELSE
        ldc(1) = npart
        is2d = .FALSE.
    ENDIF


    IF (is2d) THEN
        SELECT CASE (datatype)
        CASE (ppm_type_int)
            CALL ppm_alloc(prop%data_2d_i,ldc,iopt,info)
            IF (zero_data) prop%data_2d_i(1:lda,1:npart) = 0
        CASE (ppm_type_longint)
            CALL ppm_alloc(prop%data_2d_li,ldc,iopt,info)
            IF (zero_data) prop%data_2d_li(1:lda,1:npart) = 0
        CASE (ppm_type_real)
            CALL ppm_alloc(prop%data_2d_r,ldc,iopt,info)
            IF (zero_data) prop%data_2d_r(1:lda,1:npart) = 0._MK
        CASE (ppm_type_comp)
            CALL ppm_alloc(prop%data_2d_c,ldc,iopt,info)
            IF (zero_data) prop%data_2d_c(1:lda,1:npart) = 0._MK
        CASE (ppm_type_logical )
            CALL ppm_alloc(prop%data_2d_l,ldc,iopt,info)
            IF (zero_data) prop%data_2d_l(1:lda,1:npart) = .FALSE.
        CASE DEFAULT
            info = ppm_error_fatal
            CALL ppm_error(ppm_err_argument,caller,   &
                &        'invalid type for particle property',427,info)
        END SELECT
    ELSE
        SELECT CASE (datatype)
        CASE (ppm_type_int)
            CALL ppm_alloc(prop%data_1d_i,ldc,iopt,info)
            IF (zero_data) prop%data_1d_i(1:npart) = 0
        CASE (ppm_type_longint)
            CALL ppm_alloc(prop%data_1d_li,ldc,iopt,info)
            IF (zero_data) prop%data_1d_li(1:npart) = 0
        CASE (ppm_type_real)
            CALL ppm_alloc(prop%data_1d_r,ldc,iopt,info)
            IF (zero_data) prop%data_1d_r(1:npart) = 0._MK
        CASE (ppm_type_comp)
            CALL ppm_alloc(prop%data_1d_c,ldc,iopt,info)
            IF (zero_data) prop%data_1d_c(1:npart) = 0._MK
        CASE (ppm_type_logical )
            CALL ppm_alloc(prop%data_1d_l,ldc,iopt,info)
            IF (zero_data) prop%data_1d_l(1:npart) = .FALSE.
        CASE DEFAULT
            info = ppm_error_fatal
            CALL ppm_error(ppm_err_argument,caller,   &
                &        'invalid type for particle property',449,info)
        END SELECT
    ENDIF

    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'allocating property failed',456,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE prop_create_s

SUBROUTINE prop_destroy_s(prop,info)
    CLASS(ppm_t_part_prop_s)      :: prop
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'prop_destroy'


    CALL substart(caller,t0,info)

    IF(ASSOCIATED(prop%data_1d_i)) DEALLOCATE(prop%data_1d_i,STAT=info)
    IF(ASSOCIATED(prop%data_2d_i)) DEALLOCATE(prop%data_2d_i,STAT=info)
    IF(ASSOCIATED(prop%data_1d_li)) DEALLOCATE(prop%data_1d_li,STAT=info)
    IF(ASSOCIATED(prop%data_2d_li)) DEALLOCATE(prop%data_2d_li,STAT=info)
    IF(ASSOCIATED(prop%data_1d_r)) DEALLOCATE(prop%data_1d_r,STAT=info)
    IF(ASSOCIATED(prop%data_2d_r)) DEALLOCATE(prop%data_2d_r,STAT=info)
    IF(ASSOCIATED(prop%data_1d_c)) DEALLOCATE(prop%data_1d_c,STAT=info)
    IF(ASSOCIATED(prop%data_2d_c)) DEALLOCATE(prop%data_2d_c,STAT=info)
    IF(ASSOCIATED(prop%data_1d_l)) DEALLOCATE(prop%data_1d_l,STAT=info)
    IF(ASSOCIATED(prop%data_2d_l)) DEALLOCATE(prop%data_2d_l,STAT=info)

    prop%data_type = ppm_type_none
    prop%lda = 0
    prop%flags = .FALSE.

    CALL substop(caller,t0,info)

END SUBROUTINE prop_destroy_s

SUBROUTINE part_neigh_create_s(Pc,id,info,&
        P_id,name,skin,symmetry,cutoff)
    !!! Create a data structure to store a neighbour list
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,               INTENT(  OUT)  :: id
    INTEGER,               INTENT(OUT)    :: info
    INTEGER, OPTIONAL                     :: P_id    
    !!! Id of the set of particles that this neighbor list refers to
    !!! The default, 0, stands for "self"
    CHARACTER(LEN=*) , OPTIONAL           :: name
    !!! name of this neighbour list
    REAL(MK), OPTIONAL                    :: skin
    REAL(MK), OPTIONAL                    :: cutoff
    LOGICAL, OPTIONAL                     :: symmetry    

    INTEGER                               :: vec_size,i
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_neigh_create'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_t_neighlist_s),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_neighlist_s),POINTER  :: Nlist
    REAL(MK), DIMENSION(:), POINTER       :: rcp => NULL()

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%neighs )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of property pointers
            id = id + 1
            write(*,*) cont%nb, cont%min_id,cont%max_id,cont%vec_size
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                write(*,*) '  id = ',id
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of property pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',541,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of property pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',552,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE
        
    IF (.NOT. ASSOCIATED(Pc%neighs%vec(id)%t)) THEN
        ALLOCATE(Pc%neighs%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating neighlist pointer failed',577,info)
            GOTO 9999
        ENDIF
    ENDIF

    Nlist => Pc%neighs%vec(id)%t

    ! Create the property

    IF (PRESENT(name)) THEN
        Nlist%name = name
    ELSE
        Nlist%name = particles_dflt_nlname(id)
    ENDIF

    IF (PRESENT(P_id)) THEN
        Nlist%P_id = P_id
    ELSE
        Nlist%P_id = 0
    ENDIF

    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_s)
        ASSOCIATE (ghosts => Pc%flags(ppm_part_ghosts))
            IF (Pc%rcp_id.LE.0) THEN
                CALL Pc%create_prop(Pc%rcp_id,ppm_type_real,info,&
                    name='rcp',with_ghosts=ghosts) 
            ENDIF
            CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=ghosts)
            IF (PRESENT(cutoff)) THEN
                rcp = cutoff
            ELSE
                rcp = Pc%ghostlayer
            ENDIF
            CALL Pc%set(rcp,Pc%rcp_id,ghosts_ok=ghosts)
        END ASSOCIATE
        Nlist%cutoff = -1._MK 
        !this field should not be used with adaptive particles
    CLASS DEFAULT
        IF (PRESENT(cutoff)) THEN
            Nlist%cutoff = cutoff
        ELSE
            Nlist%cutoff = Pc%ghostlayer
        ENDIF
    END SELECT

    IF (PRESENT(skin)) THEN
        Nlist%skin = skin
    ELSE
        Nlist%skin = 0._mk
    ENDIF

    IF (PRESENT(symmetry)) THEN
        IF (symmetry) THEN
            Nlist%isymm = 1
        ELSE
            Nlist%isymm = 0
        ENDIF
    ELSE
        Nlist%isymm = 0
    ENDIF

    Nlist%uptodate = .FALSE.
    Nlist%nneighmin = 0
    Nlist%nneighmax = 0

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_neigh_create_s

SUBROUTINE part_neigh_destroy_s(Pc,id,info)
    !!! Destroy a property from an existing particle set
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_neigh_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%neighs)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'property id larger than size of properties array',&
                664,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            692,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_neigh_destroy_s

SUBROUTINE neigh_destroy_s(neigh,info)
    CLASS(ppm_t_neighlist_s)      :: neigh
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'neigh_destroy'

    CALL substart(caller,t0,info)

    IF(ASSOCIATED(neigh%nvlist)) DEALLOCATE(neigh%nvlist,STAT=info)
    IF(ASSOCIATED(neigh%vlist))  DEALLOCATE(neigh%vlist,STAT=info)

    CALL substop(caller,t0,info)

END SUBROUTINE neigh_destroy_s

SUBROUTINE part_op_create_s(Pc,id,nterms,coeffs,degree,order,info,&
        name,with_ghosts,vector,interp,P_id,neigh_id)
    !!! Adds a differential operator to a particle set
    !!!------------------------------------------------------------------------!
    !!! Define a DC operator as a linear combination (with scalar coefficients)
    !!! of nterms partial derivatives of arbitrary degrees. 
    !!! These are given by a matrix
    !!! of integers where each row represents one term of the linear combination
    !!! and each of the ppm_dim columns is the order of differentiation in that
    !!! dimension.
    !!! The definition of the operator is stored in the ppm_t_operator derived 
    !!! type under the index eta_id. 
    !!! The operator itself is computed elsewhere and will be stored in 
    !!! the same data structure.
    !!!
    !!! Usage example:
    !!!
    !!!   The differential operator:
    !!!   3.0 df/dx -7.0 d^4f/dxdydz^2 + 8.0 d^3f/dx^2dz
    !!!   would be defined by calling particles_dcop_define with
    !!!   coeffs = (/3.0, -7.0, 8.0/)
    !!!   degree = (/1,0,0,  1,1,2,  2,0,1 /)
    !!!   order =  (/2,      1,      3     /)
    !!!   nterms = 3
    !!!------------------------------------------------------------------------!
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                       :: Pc
    INTEGER,                            INTENT(  OUT)   :: id
    !!! id for this operator 
    INTEGER,                            INTENT(IN   )   :: nterms
    !!! Number of terms in the linear combination
    REAL(MK),DIMENSION(:),              INTENT(IN   )   :: coeffs
    !!! Multiplicative coefficients of each term in the linear combination of
    !!! differential operators
    INTEGER,DIMENSION(:),               INTENT(IN   )   :: degree
    !!! Degree of differentiation of each term
    INTEGER,DIMENSION(:),               INTENT(IN   )   :: order
    !!! Order of approxmiation for each term
    LOGICAL,OPTIONAL,                   INTENT(IN   )   :: with_ghosts
    !!! True if the operator should be computed for ghost particles too. 
    !!! Note that the resulting values will be wrong for the ghost particles
    !!! that have some neighbours outside the ghost layers. Default is false.
    LOGICAL,OPTIONAL,                   INTENT(IN   )   :: vector
    !!! True if the operator is a vector field. Default is false.
    LOGICAL,OPTIONAL,                   INTENT(IN   )   :: interp
    !!! True if the operator interpolates data from one set of particles to
    !!! another. Default is false.
    INTEGER,OPTIONAL,                   INTENT(IN   )   :: P_id
    !!! Id of the set of particles that this operator takes data from.
    !!! The default, 0, stands for "self" (the operator is computed
    !!! on the same set of particles than the one which contains the data).
    INTEGER,OPTIONAL,                   INTENT(IN   )   :: neigh_id
    !!! Id of the neighbour list that should be used
    !!! The default, 1, refers to "self": the list of neighbours within
    !!! the same set of particles. 
    CHARACTER(LEN=*) , OPTIONAL           :: name
    !!! name for this operator
    INTEGER,               INTENT(OUT)    :: info

    INTEGER                               :: i,vec_size,npart,lpid,lnlid
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_op_create'
    CHARACTER(LEN=ppm_char)               :: lname
    LOGICAL                               :: lwith_ghosts,lvector,linterp
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_ops_s),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_operator_s),          POINTER  :: op => NULL()

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%ops )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of property pointers
            id = id + 1
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of property pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',809,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of property pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',820,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE

    !Allocate operator struct
    IF (.NOT. ASSOCIATED(Pc%ops%vec(id)%t)) THEN
        ALLOCATE(Pc%ops%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating operator pointer failed',846,info)
            GOTO 9999
        ENDIF
    ENDIF

    op => Pc%ops%vec(id)%t

    IF (PRESENT(name)) THEN
        lname = name
    ELSE
        lname = particles_dflt_opname(id)
    ENDIF
    IF (PRESENT(with_ghosts)) THEN
        lwith_ghosts = with_ghosts
    ELSE
        lwith_ghosts = .FALSE.
    ENDIF
    IF (PRESENT(interp)) THEN
        linterp = interp
    ELSE
        linterp = .FALSE.
    ENDIF
    IF (PRESENT(vector)) THEN
        lvector = vector
    ELSE
        lvector = .FALSE.
    ENDIF
    IF (PRESENT(P_id)) THEN
        lpid = P_id
    ELSE
        lpid = 0
    ENDIF
    IF (PRESENT(neigh_id)) THEN
        lnlid = neigh_id
    ELSE
        lnlid = ppm_param_default_nlID
    ENDIF

    IF (.NOT. Pc%neighs%exists(lnlid)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Invalid neighbour list. Use comp_neigh() first.',&
            888,info)
        GOTO 9999
    ENDIF
    IF (Pc%neighs%vec(lnlid)%t%P_id .NE. lpid) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'incompatible P_id and neigh_id',894,info)
        GOTO 9999
    ENDIF

    ! Create/Initialize operator
    CALL op%create(nterms,coeffs,degree,order,&
        lname,lwith_ghosts,lvector,linterp,lpid,lnlid,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating operator object failed',904,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_op_create_s


SUBROUTINE part_op_destroy_s(Pc,id,info)
    !!! Destroy a property from an existing particle set
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_op_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%ops)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'property id larger than size of properties array',&
                930,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            958,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_op_destroy_s

SUBROUTINE op_create_s(op,nterms,coeffs,degree,order,&
        name,with_ghosts,vector,interp,pid,nlid,info)
    !!! Create a differential operator
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_operator_s)          :: op
    INTEGER,                INTENT(IN   ) :: nterms
    !!! Number of terms in the linear combination
    REAL(MK),DIMENSION(:),  INTENT(IN   ) :: coeffs
    !!! Multiplicative coefficients of each term in the linear combination of
    !!! differential operators
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: degree
    !!! Degree of differentiation of each term
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: order
    !!! Order of approxmiation for each term
    LOGICAL,                INTENT(IN   ) :: with_ghosts
    !!! True if the operator should be computed for ghost particles too. 
    !!! Note that the resulting values will be wrong for the ghost particles
    !!! that have some neighbours outside the ghost layers. Default is false.
    LOGICAL,                INTENT(IN   ) :: vector
    !!! True if the operator is a vector field. Default is false.
    LOGICAL,                INTENT(IN   ) :: interp
    !!! True if the operator interpolates data from one set of particles to
    !!! another. Default is false.
    INTEGER,                INTENT(IN   ) :: pid
    !!! Id of the set of particles that this operator takes data from.
    !!! The default, 0, stands for "self" (the operator is computed
    !!! on the same set of particles than the one which contains the data).
    INTEGER,                INTENT(IN   ) :: nlid
    !!! Id of the neighbour list that should be used
    !!! The default, 1, refers to "self": the list of neighbours within
    !!! the same set of particles. 
    CHARACTER(LEN=*)                      :: name
    !!! name for this operator
    INTEGER,                INTENT(OUT)   :: info
    !!! Returns status, 0 upon success.

    CHARACTER(LEN=ppm_char)               :: caller = 'op_create'
    REAL(KIND(1.D0))                      :: t0
    
    CALL substart(caller,t0,info)

    op%flags = .FALSE.
    op%flags(ppm_ops_inc_ghosts) = with_ghosts
    op%flags(ppm_ops_interp) = interp
    op%flags(ppm_ops_vector) = vector
    op%flags(ppm_ops_isdefined) = .TRUE.
    op%P_id = pid
    op%neigh_id = nlid

    IF (ASSOCIATED(op%desc)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,   &
            &       'operator struct not clean. Use destroy first ',&
            &       1025,info)
        GOTO 9999
    ENDIF

    ALLOCATE(op%desc,STAT=info)
    IF (info.NE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &       'allocation of ker or desc failed',1033,info)
        GOTO 9999
    ENDIF

    CALL op%desc%create(nterms,coeffs,degree,order,name,info)

    CALL substop(caller,t0,info)
    
    9999 CONTINUE

END SUBROUTINE op_create_s

SUBROUTINE op_destroy_s(op,info)
    !!! Destroy the description for a differential operator
    CLASS(ppm_t_operator_s)              :: op
    INTEGER                                   :: i
    INTEGER,                   INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'op_destroy'
    
    CALL substart(caller,t0,info)

    CALL ppm_alloc(op%ker,ldc,ppm_param_dealloc,info)
    IF (info.NE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_dealloc,caller,   &
            &       'ker deallocate failed ',1060,info)
        GOTO 9999
    ENDIF
    CALL op%desc%destroy(info)
    IF (info.NE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,   &
            &       'desc destroy failed ',1067,info)
        GOTO 9999
    ENDIF

    op%flags = .FALSE.
    op%P_id = -1
    op%neigh_id = 1

    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE op_destroy_s

SUBROUTINE part_op_compute_s(Pc,op_id,info,c,min_sv)

    USE ppm_module_write
    IMPLICIT NONE
    INCLUDE 'mpif.h'

    INTEGER, PARAMETER :: MK = ppm_kind_single
    !---------------------------------------------------------
    ! arguments
    !---------------------------------------------------------
    CLASS(ppm_t_particles_s)                        :: Pc
    !!! particles
    INTEGER,                             INTENT(IN   )   :: op_id
    !!! id of the operator 
    INTEGER,                             INTENT(  OUT)   :: info
    !!! non-zero on output if some error occurred
    !---------------------------------------------------------
    ! Optional arguments
    !---------------------------------------------------------
    REAL(MK),OPTIONAL                       :: c
    !!! ratio h/epsilon (default is 1.0)
    REAL(MK),OPTIONAL   ,  INTENT(  OUT)    :: min_sv
    !!! smallest singular value
    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    CHARACTER(LEN = ppm_char)               :: caller = 'part_dcop_compute'
    CHARACTER(LEN = ppm_char)               :: cbuf
    REAL(KIND(1.D0))                        :: t0,t1,t2
    TYPE(ppm_t_operator_s), POINTER    :: op => NULL()

    !-------------------------------------------------------------------------
    ! Initialize
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    t1 = MPI_WTIME(info)

    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT. ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,'Particles not defined',&
            1128,info)
        GOTO 9999
    ENDIF
    IF (.NOT. Pc%ops%exists(op_id)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            & 'No operator data structure found, use create_op() first',&
            1135,info)
        GOTO 9999
    ENDIF
    op => Pc%ops%vec(op_id)%t
    IF (.NOT. op%flags(ppm_ops_isdefined)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            & 'Operator not found, use create_op() first',&
            1143,info)
        GOTO 9999
    ENDIF
    IF (op%flags(ppm_ops_iscomputed)) THEN
        WRITE(cbuf,*) 'WARNING: The operator with id ',op_id,&
            & ' and name *',TRIM(ADJUSTL(op%desc%name)),&
            &'* seems to have already been computed. Unnecessary call to',&
            &' particles_dcop_compute()'
        CALL ppm_write(ppm_rank,caller,cbuf,info)
    ENDIF

    !-------------------------------------------------------------------------
    ! Compute the DC operator
    !-------------------------------------------------------------------------

    Pc%stats%nb_dc_comp = Pc%stats%nb_dc_comp + 1

    IF (ppm_dim .EQ. 2) THEN
        CALL Pc%ppm_dcop_compute2d_s(op_id,info,c,min_sv)
    ELSE
        CALL Pc%ppm_dcop_compute3d_s(op_id,info,c,min_sv)
    ENDIF
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            & 'ppm_dcop_compute failed',&
            1169,info)
        GOTO 9999
    ENDIF

    !-------------------------------------------------------------------------
    ! Update states
    !-------------------------------------------------------------------------
    op%flags(ppm_ops_iscomputed) = .TRUE.
    t2 = MPI_WTIME(info)
    Pc%stats%t_dc_comp = Pc%stats%t_dc_comp + (t2-t1)

    !-------------------------------------------------------------------------
    ! Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_op_compute_s

SUBROUTINE part_op_apply_s(Pc,from_id,to_id,op_id,info)
    !!!------------------------------------------------------------------------!
    !!! Apply DC kernel stored in op_id to the scalar property stored
    !!! prop_from_id and store the results in prop_to_id
    !!!------------------------------------------------------------------------!
    USE ppm_module_data, ONLY: ppm_rank

    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                       :: Pc
    !!! Data structure containing the particles
    INTEGER,                            INTENT(IN   )   :: from_id
    !!! id where the data is stored
    INTEGER,                            INTENT(INOUT)   :: to_id
    !!! id where the result should be stored (0 if it needs to be allocated)
    INTEGER,                            INTENT(IN   )   :: op_id
    !!! id where the DC kernel has been stored
    INTEGER,                            INTENT(  OUT)   :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)                  :: filename
    CHARACTER(LEN = ppm_char)                  :: caller = 'part_dcop_apply'
    INTEGER                                    :: ip,iq,ineigh,lda,np_target
    REAL(KIND(1.D0))                           :: t0,t1,t2
    REAL(MK),DIMENSION(:,:),POINTER            :: eta => NULL()
    REAL(MK),DIMENSION(:),  POINTER            :: wps1 => NULL(),wps2=>NULL()
    REAL(MK),DIMENSION(:,:),POINTER            :: wpv1 => NULL(),wpv2=>NULL()
    REAL(MK),DIMENSION(:),  POINTER            :: dwps => NULL()
    REAL(MK),DIMENSION(:,:),POINTER            :: dwpv => NULL()
    INTEGER, DIMENSION(:),  POINTER            :: nvlist => NULL()
    INTEGER, DIMENSION(:,:),POINTER            :: vlist => NULL()
    REAL(MK)                                   :: sig
    LOGICAL                                    :: vector_output
    LOGICAL                                    :: vector_input
    LOGICAL                                    :: with_ghosts,isinterp

    TYPE(ppm_t_sop_s),POINTER             :: Pc2 => NULL()
    TYPE(ppm_t_neighlist_s),POINTER       :: Nlist => NULL()
    TYPE(ppm_t_operator_s), POINTER       :: op => NULL()
    TYPE(ppm_t_part_prop_s), POINTER      :: prop_from => NULL()
    !-------------------------------------------------------------------------
    ! Initialize
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    t1 = MPI_WTIME(info)

    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT. ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,'Particles not defined',&
            1253,info)
        GOTO 9999
    ENDIF
    IF (.NOT. Pc%ops%exists(op_id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'No operator data structure found, use create_op() first',&
            1260,info)
        GOTO 9999
    ENDIF
    op => Pc%ops%vec(op_id)%t
    IF (.NOT. op%flags(ppm_ops_isdefined)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Operator not found, use create_op() first',&
            1268,info)
        GOTO 9999
    ENDIF
    IF (.NOT.op%flags(ppm_ops_iscomputed)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Operator not computed, use comp_op() first',&
            1275,info)
        GOTO 9999
    ENDIF

    isinterp = op%flags(ppm_ops_interp)
    vector_output =  op%flags(ppm_ops_vector)
    !if true, then each term of the differential opearator is stored as one
    !component in eta. This is used when computing e.g. the gradient opearator.
    !if false, the same input parameters would yield an operator approximating
    ! the divergence operator.
    with_ghosts = op%flags(ppm_ops_inc_ghosts)
    !if true, then the operator should be computed for ghost particles too. 
    !Note that the resulting values will be wrong for the ghost particles
    !that have some neighbours outside the ghost layers. Some of these particles
    !may also not have enough neighbours for the Vandermonde matrix to be
    !invertible. These particles will be skipped without raising a warning.

    IF (with_ghosts) THEN
        np_target = Pc%Mpart
    ELSE
        np_target = Pc%Npart
    ENDIF

    lda = op%desc%nterms

    IF (.NOT. Pc%neighs%exists(op%neigh_id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Neighbour lists have not been created',&
            1304,info)
        GOTO 9999
    ENDIF

    Nlist => Pc%neighs%vec(op%neigh_id)%t
    IF (.NOT. Nlist%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Neighbour lists are not up to date',1312,info)
        GOTO 9999
    ENDIF
    nvlist => Nlist%nvlist
    vlist => Nlist%vlist


    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_s)
        IF (isinterp) THEN
            Pc2 => Pc%set_aPc%vec(op%P_id)%t
            IF (.NOT. Pc2%props%exists(from_id)) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,   &
                    & 'The operator input is not allocated.',&
                    1327,info)
                GOTO 9999
            ELSE
                prop_from => Pc2%props%vec(from_id)%t
            ENDIF
        ELSE
            IF (.NOT. Pc%props%exists(from_id)) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,   &
                    & 'The operator input is not allocated.',&
                    1337,info)
                GOTO 9999
            ELSE
                prop_from => Pc%props%vec(from_id)%t
            ENDIF
        ENDIF
    CLASS DEFAULT
        IF (.NOT. Pc%props%exists(from_id)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                & 'The operator input is not allocated.',&
                1348,info)
            GOTO 9999
        ELSE
            prop_from => Pc%props%vec(from_id)%t
        ENDIF
    END SELECT

    IF (.NOT.prop_from%flags(ppm_ppt_ghosts)) THEN
        WRITE(cbuf,*) 'Ghost values of ',TRIM(ADJUSTL(&
            prop_from%name)),' are needed.'
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Please call particles_mapping_ghosts first',&
            1362,info)
        GOTO 9999
    ENDIF

    IF (vector_output .AND. prop_from%lda .NE. lda) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Incompatible dimensions between operator and input data',&
            1370,info)
        GOTO 9999
    ENDIF
    vector_input = (prop_from%lda .GE.2)

    !allocate output field if needed
    !otherwise simply check that the output array had been allocated
    !to the right size
    IF (to_id.EQ.0) THEN
        IF (vector_output) THEN
            CALL Pc%create_prop(to_id,ppm_type_real,info,lda=lda,&  
                name="dflt_dcop_apply",with_ghosts=with_ghosts)
        ELSE
            CALL Pc%create_prop(to_id,ppm_type_real,info,&
                name="dflt_dcop_apply",with_ghosts=with_ghosts)
        ENDIF
    ELSE
        ASSOCIATE (prop_to => Pc%props%vec(to_id)%t)
        !Destroy and reallocate the target property data structure
        ! if its type/dimension do not match that of the operator
        IF (      vector_output.AND.prop_to%lda.LT.2 .OR. &
             .NOT.vector_output.AND.prop_to%lda.NE.1 .OR. &
             prop_to%data_type.NE.ppm_type_real) THEN 
                CALL Pc%realloc_prop(to_id,info,with_ghosts=with_ghosts,&
                    datatype=ppm_type_real,lda=lda)
        ENDIF
        !Resize the target property array if its size does not match
        !that of the operators output.
        IF (.NOT.Pc%props%vec(to_id)%t%flags(ppm_ppt_partial).OR. &
            &  with_ghosts .AND. &
            &  .NOT.Pc%props%vec(to_id)%t%flags(ppm_ppt_ghosts)) THEN
            CALL Pc%realloc_prop(to_id,info,with_ghosts=with_ghosts)
        ENDIF
        END ASSOCIATE
    ENDIF
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'ppm_prop_(re)allocate failed',1408,info)
        GOTO 9999
    ENDIF

    !zero the output array
    IF (vector_output) THEN
        CALL Pc%get(dwpv,to_id,with_ghosts=with_ghosts)
        DO ip = 1,np_target
            dwpv(1:lda,ip) = 0._MK
        ENDDO
    ELSE
        CALL Pc%get(dwps,to_id,with_ghosts=with_ghosts)
        DO ip = 1,np_target
            dwps(ip) = 0._MK
        ENDDO
    ENDIF
    eta => Pc%get_dcop(op_id,with_ghosts=with_ghosts)


    IF (isinterp) THEN
        IF (vector_output) THEN
            IF(vector_input) THEN
                CALL Pc2%get(wpv2,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            wpv2(1:lda,iq) * eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc2%set(wpv2,from_id,read_only=.TRUE.)
            ELSE
                CALL Pc2%get(wps2,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            wps2(iq) * eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc2%set(wps2,from_id,read_only=.TRUE.)
            ENDIF
        ELSE
            CALL Pc2%get(wps2,from_id,with_ghosts=.TRUE.)
            DO ip = 1,np_target
                DO ineigh = 1,nvlist(ip)
                    iq = vlist(ineigh,ip)
                    dwps(ip) = dwps(ip) + wps2(iq) * eta(ineigh,ip)
                ENDDO
            ENDDO
            CALL Pc2%set(wps2,from_id,read_only=.TRUE.)
        ENDIF
    ELSE
        sig = -1._mk 
        IF (vector_output) THEN
            IF(vector_input) THEN
                CALL Pc%get(wpv1,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            (wpv1(1:lda,iq) + sig*(wpv1(1:lda,ip)))* &
                            eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc%set(wpv1,from_id,read_only=.TRUE.)
            ELSE
                CALL Pc%get(wps1,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            (wps1(iq) + sig*(wps1(ip)))* &
                            eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc%set(wps1,from_id,read_only=.TRUE.)
            ENDIF
        ELSE
            CALL Pc%get(wps1,from_id,with_ghosts=.TRUE.)
            DO ip = 1,np_target
                DO ineigh = 1,nvlist(ip)
                    iq = vlist(ineigh,ip)
                    dwps(ip) = dwps(ip) + &
                        (wps1(iq)+sig*(wps1(ip))) * eta(ineigh,ip)
                ENDDO
            ENDDO
            CALL Pc%set(wps1,from_id,read_only=.TRUE.)
        ENDIF
    ENDIF

    eta => Pc%set_dcop(op_id)
    IF (vector_output) THEN
        IF (with_ghosts) THEN
            !we assume that the ghosts are up-to-date even though
            !they clearly are not. we assume you know what you are
            !doing when using this option.
            CALL Pc%set(dwpv,to_id,ghosts_ok=.TRUE.)
        ELSE
            CALL Pc%set(dwpv,to_id)
        ENDIF
    ELSE
        IF (with_ghosts) THEN
            CALL Pc%set(dwps,to_id,ghosts_ok=.TRUE.)
        ELSE
            CALL Pc%set(dwps,to_id)
        ENDIF
    ENDIF
    nvlist => NULL()
    vlist => NULL()

    Pc%stats%nb_dc_apply = Pc%stats%nb_dc_apply + 1
    t2 = MPI_WTIME(info)
    Pc%stats%t_dc_apply = Pc%stats%t_dc_apply+(t2-t1)

    CALL substop(caller,t0,info)

    9999  CONTINUE ! jump here upon error


END SUBROUTINE part_op_apply_s




SUBROUTINE desc_create_s(desc,nterms,coeffs,degree,order,name,info)
    !!! Create a description for a differential operator
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_opdesc_s)            :: desc
    INTEGER,                INTENT(IN   ) :: nterms
    !!! Number of terms in the linear combination
    REAL(MK),DIMENSION(:),  INTENT(IN   ) :: coeffs
    !!! Multiplicative coefficients of each term in the linear combination of
    !!! differential operators
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: degree
    !!! Degree of differentiation of each term
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: order
    !!! Order of approxmiation for each term
    CHARACTER(LEN=*)                      :: name
    !!! name for this operator
    INTEGER,                INTENT(OUT)   :: info
    !!! Returns status, 0 upon success.

    CHARACTER(LEN=ppm_char)               :: caller = 'desc_create'
    REAL(KIND(1.D0))                      :: t0
    
    CALL substart(caller,t0,info)

    !Check arguments
    IF (MINVAL(degree).LT.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &       'invalid degree: must be positive',1562,info)
        GOTO 9999
    ENDIF
    IF (MINVAL(order).LT.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &     'invalid approx order: must be positive',1568,info)
        GOTO 9999
    ENDIF
    IF (SIZE(degree).NE.ppm_dim*nterms) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &     'wrong number of terms in degree argument',1574,info)
        GOTO 9999
    ENDIF
    IF (SIZE(order).NE.nterms) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &      'wrong number of terms in order argument',1580,info)
        GOTO 9999
    ENDIF
    IF (SIZE(coeffs).NE.nterms) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &      'wrong number of terms in coeffs argument',1586,info)
        GOTO 9999
    ENDIF


    !allocate operators descriptors
    ldc(1) = ppm_dim * nterms
    CALL ppm_alloc(desc%degree,ldc,ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &            'failed to allocate ops%desc',1597,info)
        GOTO 9999
    ENDIF
    ldc(1) = nterms
    CALL ppm_alloc(desc%order,ldc,ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &            'failed to allocate ops%desc',1605,info)
        GOTO 9999
    ENDIF
    ldc(1) = nterms
    CALL ppm_alloc(desc%coeffs,ldc,ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &            'failed to allocate ops%desc',1613,info)
        GOTO 9999
    ENDIF
    desc%order = order 
    desc%coeffs = coeffs 
    desc%degree = degree 
    desc%nterms = nterms 
    desc%name = name


    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE desc_create_s

SUBROUTINE desc_destroy_s(desc,info)
    CLASS(ppm_t_opdesc_s)              :: desc
    INTEGER,                 INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    
    IF (ASSOCIATED(desc%degree)) DEALLOCATE(desc%degree,STAT=info)
    IF (ASSOCIATED(desc%order))  DEALLOCATE(desc%order,STAT=info)
    IF (ASSOCIATED(desc%coeffs)) DEALLOCATE(desc%coeffs,STAT=info)

END SUBROUTINE desc_destroy_s

SUBROUTINE part_create_s(Pc,Npart,info,name)

    !!! create a ppm_t_particles data type

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                                INTENT(IN   )  :: Npart
    !!! Number of particles 
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    CHARACTER(LEN=*) , OPTIONAL                            :: name
    !!! give a name to this Particle set
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    LOGICAL                                         :: lalloc,ldealloc
    INTEGER                                         :: i
    REAL(KIND(1.D0))                                :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_create_particles'
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  Destroy the DS if it already exists
    !-----------------------------------------------------------------
    IF (ASSOCIATED(Pc%xp)) THEN
        CALL Pc%destroy(info)
    ENDIF
    !-----------------------------------------------------------------
    !  Allocate memory for the positions
    !-----------------------------------------------------------------
    ldc(1) = ppm_dim
    ldc(2) = Npart
    CALL ppm_alloc(Pc%xp,ldc(1:2),ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &        'Could not allocate Particles elements',1695,info)
        GOTO 9999
    ENDIF
    Pc%Npart = Npart
    Pc%Mpart = Npart
    Pc%flags(ppm_part_ghosts) = .FALSE.
    Pc%flags(ppm_part_areinside) = .FALSE.
    Pc%flags(ppm_part_partial) = .FALSE.
    Pc%flags(ppm_part_reqput) = .FALSE.
    Pc%flags(ppm_part_cartesian) = .FALSE.
    Pc%flags(ppm_part_neighlists) = .FALSE.
    Pc%flags(ppm_part_global_index) = .FALSE.
    Pc%active_topoid = -1
    ! No active topology yet

    ! Give a default name to this Particle set
    IF (PRESENT(name)) THEN
        Pc%name = ADJUSTL(TRIM(name))
    ELSE
        Pc%name = particles_dflt_partname()
    ENDIF

    ! Particles have not been initialised yet
    Pc%h_avg = -1._MK
    Pc%h_min = -1._MK

    Pc%time = 0._MK
    Pc%itime = 0

    Pc%gi_id = 0

    SELECT TYPE(Pc)
    CLASS IS (ppm_t_sop_s)
        !-----------------------------------------------------------------
        !  Initialize fields of the extended SOP type
        !-----------------------------------------------------------------
        ! Particles are by default not adaptive
        Pc%adaptive = .FALSE.
        Pc%adapt_wpid = 0
        Pc%rcp_id = 0
        Pc%D_id = 0
        Pc%Dtilde_id = 0
        Pc%nn_sq_id = 0
        ! Particles do not represent a level-set function
        Pc%level_set = .FALSE.
        Pc%level_id = 0
        !        Pc%level_old_id = 0
        Pc%level_grad_id = 0
        !        Pc%level_grad_old_id = 0
        ! Particles are by default isotropic
        Pc%anisotropic = .FALSE.
    CLASS DEFAULT
    END SELECT
    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_create_s


SUBROUTINE part_destroy_s(Pc,info)

    !!! Deallocate a ppm_t_particles data type

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the Pc
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.

    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    LOGICAL                                         :: lalloc,ldealloc
    INTEGER                                         :: i
    REAL(KIND(1.D0))                                :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_destroy_particles'
    TYPE(ppm_t_neighlist_s), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_s),  POINTER :: op => NULL()
    TYPE(ppm_t_part_prop_s), POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-------------------------------------------------------------------------
    !  Check arguments
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  If reallocating, deallocate old data first
    !-------------------------------------------------------------------------
    !----------------------------------------------------------------------
    !  deallocate
    !----------------------------------------------------------------------
    ! first deallocate all content of Pc
    IF (ASSOCIATED(Pc%xp)) THEN 
        DEALLOCATE(Pc%xp,STAT=info)
        NULLIFY(Pc%xp)
    ENDIF
    IF (ASSOCIATED(Pc%pcost)) THEN
        DEALLOCATE(Pc%pcost,STAT=info)
        NULLIFY(Pc%pcost)
    ENDIF

    !Deallocate neighbour lists
    CALL Pc%neighs%destroy(info)

    !Deallocate properties
    CALL Pc%props%destroy(info)

    !Deallocate operators
    CALL Pc%ops%destroy(info)

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_destroy_s

SUBROUTINE particles_initialize2d_s(Pc,Npart_global,info,&
        distrib,topoid,minphys,maxphys,cutoff,name)
    !!!-----------------------------------------------------------------------
    !!! Set initial particle positions
    !!!-----------------------------------------------------------------------
    USE ppm_module_substart
    USE ppm_module_substop
    USE ppm_module_data, ONLY: ppm_rank,ppm_nproc,ppm_topo,ppm_comm
    USE ppm_module_write

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particle cloud
    INTEGER,                             INTENT(INOUT)     :: Npart_global
    !!! total number of particles that will be initialized
    INTEGER,                             INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: distrib
    !!! type of initial distribution. One of
    !!! ppm_param_part_init_cartesian (default)
    !!! ppm_param_part_init_random
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: topoid
    !!! topology id (used only to get the extent of the physical domain)
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: minphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: maxphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),                   OPTIONAL,INTENT(IN   )     :: cutoff
    !!! cutoff of the particles
    CHARACTER(LEN=*),           OPTIONAL,INTENT(IN   )     :: name
    !!! name for this set of particles
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    INTEGER                               :: ip,i,j,k,Npart,iopt
    INTEGER                               :: nijk(ppm_dim),nijk_global(ppm_dim)
    CHARACTER(LEN = ppm_char)             :: filename,cbuf
    CHARACTER(LEN = ppm_char)             :: caller = 'particles_initialize'
    REAL(MK)                              :: y,z,h
    REAL(KIND(1.D0))                      :: t0
    INTEGER                               :: remaining_rows

    REAL(MK)                              :: shift
    INTEGER                               :: distribution,neigh_id
    TYPE(ppm_t_topo),POINTER              :: topo => NULL()
    REAL(MK), DIMENSION(ppm_dim)          :: min_phys,max_phys,len_phys

    REAL(MK), DIMENSION(:,:), POINTER     :: xp
    REAL(MK), DIMENSION(:  ), POINTER     :: randnb


    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    IF(PRESENT(distrib)) THEN
        distribution=distrib
    ELSE
        distribution=ppm_param_part_init_cartesian
    ENDIF

    !Get boundaries of computational domain
    IF (PRESENT(topoid) .AND. (PRESENT(minphys).OR.PRESENT(maxphys))) THEN
            info = ppm_error_error
            CALL ppm_error(999,caller,&
               'probable conflict of optional arguments. Use topoid OR minphys'&
               ,80,info)
            GOTO 9999
    ENDIF
    IF (PRESENT(topoid)) THEN
        topo => ppm_topo(topoid)%t
        IF (MK.EQ.ppm_kind_single) THEN
            min_phys = topo%min_physs
            max_phys = topo%max_physs
        ELSE IF (MK.EQ.ppm_kind_double) THEN
            min_phys = topo%min_physd
            max_phys = topo%max_physd
        ENDIF
    ELSE IF (PRESENT(minphys).AND.PRESENT(maxphys)) THEN
        min_phys = minphys
        max_phys = maxphys
    ELSE
        info = ppm_error_error
        CALL ppm_error(999,caller,&
            'optional arguments needed to define the domain boundaries'&
            ,99,info)
        GOTO 9999
    ENDIF
    len_phys=max_phys-min_phys
    IF (MINVAL(len_phys(1:ppm_dim)).LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Domain length is <= 0 along one dimension. Check input parameters'&
            ,107,info)
        GOTO 9999
    ENDIF


    h = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim))
    nijk_global = FLOOR(len_phys/h)
    Npart_global = PRODUCT(nijk_global)
    remaining_rows = MOD(nijk_global(ppm_dim),ppm_nproc)

    !number of particles along x and z
    nijk(1:ppm_dim) = nijk_global(1:ppm_dim)
    !number of particles along y 
    nijk(2) = nijk_global(ppm_dim)/ppm_nproc

    !number of particles on this processor
    Npart = PRODUCT(nijk)

    !last proc takes care of the additional rows (remainder)
    IF (ppm_rank.EQ.ppm_nproc-1) THEN
        Npart = Npart + remaining_rows * nijk(1)
    ENDIF

    !Deallocate Particles if already allocated
    IF (ASSOCIATED(Pc%xp)) THEN
        CALL Pc%destroy(info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_dealloc,caller,&
                'destroying Particle cloud failed',140,info)
            GOTO 9999
        ENDIF
    ENDIF

    CALL Pc%create(Npart,info,name=name)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'creating Particle cloud failed',149,info)
        GOTO 9999
    ENDIF

    !use a shortcut, for convenience
    xp => Pc%xp

    !-----------------------------------------------------------------------
    ! set particles
    !-----------------------------------------------------------------------
    ip = 0
    shift = 0._MK !shifts positions of the particles. Set to 0.5 to place
    !particles in the middle of each cell, set to 0 to place them in the lower
    !left corner

    if_cartesian: IF (distribution .EQ. ppm_param_part_init_cartesian) THEN
        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2)) + shift*h
            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                xp(2,ip) = y                  

                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)

            ENDDO
        ENDDO

        IF(ppm_rank.EQ.(ppm_nproc-1)) THEN
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                    xp(2,ip) = y                  

                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)

                ENDDO
            ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .TRUE.
    ELSE !random distribution
        iopt = ppm_param_alloc_fit
        ldc(1) = ppm_dim*Npart
        CALL ppm_alloc(randnb,ldc(1:1),iopt,info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,   &
                &            'allocation failed',246,info)
            GOTO 9999
        ENDIF
        IF (.NOT.ASSOCIATED(ppm_particles_seed)) THEN
            CALL RANDOM_SEED(SIZE=ppm_particles_seedsize)
            ldc(1) = ppm_particles_seedsize
            CALL ppm_alloc(ppm_particles_seed,ldc(1:1),iopt,info)
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_alloc,caller,   &
                    &            'allocation failed',256,info)
                GOTO 9999
            ENDIF
            DO i=1,ppm_particles_seedsize
                ppm_particles_seed(i)=i*i*i*i
            ENDDO
            CALL RANDOM_SEED(PUT=ppm_particles_seed)
        ENDIF
        CALL RANDOM_NUMBER(randnb)

        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2))  + shift* h

            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                ! uniformly random in cells
                xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                    randnb(ppm_dim*ip - 1)*h
                xp(2,ip) = y                   + &
                    randnb(ppm_dim*ip    )*h
                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
            ENDDO
        ENDDO
        IF(ppm_rank.EQ.0) THEN
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    ! uniformly random in cells
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                        randnb(ppm_dim*ip - 1)*h
                    xp(2,ip) = y                   + &
                        randnb(ppm_dim*ip    )*h
                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                ENDDO
            ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .FALSE.

        DEALLOCATE(randnb)

    ENDIF if_cartesian

    xp=>NULL()

    ! (global) average interparticle spacing
    Pc%h_avg = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim)) 
    ! min interparticle spacing (not needed now)
    Pc%h_min = -1._MK

    Pc%flags(ppm_part_areinside) = .TRUE.

    ! set cutoff to a default value
    IF (PRESENT(cutoff)) THEN
        Pc%ghostlayer = cutoff
    ELSE
        Pc%ghostlayer = 2.1_MK * Pc%h_avg
    ENDIF

    IF (PRESENT(topoid)) THEN
        Pc%active_topoid = topoid
    ENDIF

    CALL Pc%create_neighlist(neigh_id,info,name='self',&
        skin=0._MK,symmetry=.FALSE.,cutoff=cutoff)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating neighbour list failed',395,info)
        GOTO 9999
    ENDIF
    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE particles_initialize2d_s

SUBROUTINE particles_initialize3d_s(Pc,Npart_global,info,&
        distrib,topoid,minphys,maxphys,cutoff,name)
    !!!-----------------------------------------------------------------------
    !!! Set initial particle positions
    !!!-----------------------------------------------------------------------
    USE ppm_module_substart
    USE ppm_module_substop
    USE ppm_module_data, ONLY: ppm_rank,ppm_nproc,ppm_topo,ppm_comm
    USE ppm_module_write

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particle cloud
    INTEGER,                             INTENT(INOUT)     :: Npart_global
    !!! total number of particles that will be initialized
    INTEGER,                             INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: distrib
    !!! type of initial distribution. One of
    !!! ppm_param_part_init_cartesian (default)
    !!! ppm_param_part_init_random
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: topoid
    !!! topology id (used only to get the extent of the physical domain)
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: minphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: maxphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),                   OPTIONAL,INTENT(IN   )     :: cutoff
    !!! cutoff of the particles
    CHARACTER(LEN=*),           OPTIONAL,INTENT(IN   )     :: name
    !!! name for this set of particles
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    INTEGER                               :: ip,i,j,k,Npart,iopt
    INTEGER                               :: nijk(ppm_dim),nijk_global(ppm_dim)
    CHARACTER(LEN = ppm_char)             :: filename,cbuf
    CHARACTER(LEN = ppm_char)             :: caller = 'particles_initialize'
    REAL(MK)                              :: y,z,h
    REAL(KIND(1.D0))                      :: t0
    INTEGER                               :: remaining_rows

    REAL(MK)                              :: shift
    INTEGER                               :: distribution,neigh_id
    TYPE(ppm_t_topo),POINTER              :: topo => NULL()
    REAL(MK), DIMENSION(ppm_dim)          :: min_phys,max_phys,len_phys

    REAL(MK), DIMENSION(:,:), POINTER     :: xp
    REAL(MK), DIMENSION(:  ), POINTER     :: randnb


    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    IF(PRESENT(distrib)) THEN
        distribution=distrib
    ELSE
        distribution=ppm_param_part_init_cartesian
    ENDIF

    !Get boundaries of computational domain
    IF (PRESENT(topoid) .AND. (PRESENT(minphys).OR.PRESENT(maxphys))) THEN
            info = ppm_error_error
            CALL ppm_error(999,caller,&
               'probable conflict of optional arguments. Use topoid OR minphys'&
               ,80,info)
            GOTO 9999
    ENDIF
    IF (PRESENT(topoid)) THEN
        topo => ppm_topo(topoid)%t
        IF (MK.EQ.ppm_kind_single) THEN
            min_phys = topo%min_physs
            max_phys = topo%max_physs
        ELSE IF (MK.EQ.ppm_kind_double) THEN
            min_phys = topo%min_physd
            max_phys = topo%max_physd
        ENDIF
    ELSE IF (PRESENT(minphys).AND.PRESENT(maxphys)) THEN
        min_phys = minphys
        max_phys = maxphys
    ELSE
        info = ppm_error_error
        CALL ppm_error(999,caller,&
            'optional arguments needed to define the domain boundaries'&
            ,99,info)
        GOTO 9999
    ENDIF
    len_phys=max_phys-min_phys
    IF (MINVAL(len_phys(1:ppm_dim)).LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Domain length is <= 0 along one dimension. Check input parameters'&
            ,107,info)
        GOTO 9999
    ENDIF


    h = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim))
    nijk_global = FLOOR(len_phys/h)
    Npart_global = PRODUCT(nijk_global)
    remaining_rows = MOD(nijk_global(ppm_dim),ppm_nproc)

    !number of particles along x and z
    nijk(1:ppm_dim) = nijk_global(1:ppm_dim)
    !number of particles along y 
    nijk(2) = nijk_global(ppm_dim)/ppm_nproc

    !number of particles on this processor
    Npart = PRODUCT(nijk)

    !last proc takes care of the additional rows (remainder)
    IF (ppm_rank.EQ.ppm_nproc-1) THEN
        Npart = Npart + remaining_rows * nijk(1)*nijk(3)
    ENDIF

    !Deallocate Particles if already allocated
    IF (ASSOCIATED(Pc%xp)) THEN
        CALL Pc%destroy(info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_dealloc,caller,&
                'destroying Particle cloud failed',140,info)
            GOTO 9999
        ENDIF
    ENDIF

    CALL Pc%create(Npart,info,name=name)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'creating Particle cloud failed',149,info)
        GOTO 9999
    ENDIF

    !use a shortcut, for convenience
    xp => Pc%xp

    !-----------------------------------------------------------------------
    ! set particles
    !-----------------------------------------------------------------------
    ip = 0
    shift = 0._MK !shifts positions of the particles. Set to 0.5 to place
    !particles in the middle of each cell, set to 0 to place them in the lower
    !left corner

    if_cartesian: IF (distribution .EQ. ppm_param_part_init_cartesian) THEN
        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2)) + shift*h
            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                xp(2,ip) = y                  
                xp(3,ip) = z 

                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)

            ENDDO
        ENDDO
        ENDDO

        IF(ppm_rank.EQ.(ppm_nproc-1)) THEN
        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                    xp(2,ip) = y                  
                    xp(3,ip) = z 

                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                    IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                    IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)

                ENDDO
            ENDDO
        ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .TRUE.
    ELSE !random distribution
        iopt = ppm_param_alloc_fit
        ldc(1) = ppm_dim*Npart
        CALL ppm_alloc(randnb,ldc(1:1),iopt,info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,   &
                &            'allocation failed',246,info)
            GOTO 9999
        ENDIF
        IF (.NOT.ASSOCIATED(ppm_particles_seed)) THEN
            CALL RANDOM_SEED(SIZE=ppm_particles_seedsize)
            ldc(1) = ppm_particles_seedsize
            CALL ppm_alloc(ppm_particles_seed,ldc(1:1),iopt,info)
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_alloc,caller,   &
                    &            'allocation failed',256,info)
                GOTO 9999
            ENDIF
            DO i=1,ppm_particles_seedsize
                ppm_particles_seed(i)=i*i*i*i
            ENDDO
            CALL RANDOM_SEED(PUT=ppm_particles_seed)
        ENDIF
        CALL RANDOM_NUMBER(randnb)

        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2))  + shift* h

            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                ! uniformly random in cells
                xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                    randnb(ppm_dim*ip - 1)*h
                xp(2,ip) = y                   + &
                    randnb(ppm_dim*ip    )*h
                xp(3,ip) = z                   + &
                    randnb(ppm_dim*ip - 2)*h
                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)
            ENDDO
        ENDDO
        ENDDO
        IF(ppm_rank.EQ.0) THEN
        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    ! uniformly random in cells
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                        randnb(ppm_dim*ip - 1)*h
                    xp(2,ip) = y                   + &
                        randnb(ppm_dim*ip    )*h
                    xp(3,ip) = z                   + &
                        randnb(ppm_dim*ip - 2)*h
                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                    IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                    IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)
                ENDDO
            ENDDO
        ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .FALSE.

        DEALLOCATE(randnb)

    ENDIF if_cartesian

    xp=>NULL()

    ! (global) average interparticle spacing
    Pc%h_avg = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim)) 
    ! min interparticle spacing (not needed now)
    Pc%h_min = -1._MK

    Pc%flags(ppm_part_areinside) = .TRUE.

    ! set cutoff to a default value
    IF (PRESENT(cutoff)) THEN
        Pc%ghostlayer = cutoff
    ELSE
        Pc%ghostlayer = 2.1_MK * Pc%h_avg
    ENDIF

    IF (PRESENT(topoid)) THEN
        Pc%active_topoid = topoid
    ENDIF

    CALL Pc%create_neighlist(neigh_id,info,name='self',&
        skin=0._MK,symmetry=.FALSE.,cutoff=cutoff)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating neighbour list failed',395,info)
        GOTO 9999
    ENDIF
    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE particles_initialize3d_s


!!temporary hack to deal with both 2d and 3d
SUBROUTINE part_initialize_s(Pc,Npart_global,info,&
        distrib,topoid,minphys,maxphys,cutoff,name)
    !-----------------------------------------------------------------------
    ! Set initial particle positions
    !-----------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                            INTENT(INOUT)      :: Npart_global
    !!! total number of particles that will be initialized
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER,OPTIONAL,                   INTENT(IN   )      :: distrib
    !!! type of initial distribution. One of
    !!! ppm_param_part_init_cartesian (default)
    !!! ppm_param_part_init_random
    INTEGER,OPTIONAL,                   INTENT(IN   )      :: topoid
    !!! topology id (used only to get the extent of the physical domain)
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: minphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: maxphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),                   OPTIONAL,INTENT(IN   )     :: cutoff
    !!! cutoff of the particles
    CHARACTER(LEN=*),           OPTIONAL,INTENT(IN   )     :: name
    !!! name for this set of particles

    IF (ppm_dim.EQ.2) THEN
        CALL  particles_initialize2d_s(Pc,Npart_global,info,&
            distrib,topoid,minphys,maxphys,cutoff,name=name)
    ELSE
        CALL  particles_initialize3d_s(Pc,Npart_global,info,&
            distrib,topoid,minphys,maxphys,cutoff,name=name)
    ENDIF
END SUBROUTINE part_initialize_s

SUBROUTINE part_print_info_s(Pc,info,level,fileunit)
    !-----------------------------------------------------------------------
    ! Print out summary information about this particle cloud
    ! (list of properties, operators, etc...)
    !-----------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: level
    !!! indentation level at which to printout the info. Default = 0
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: fileunit
    !!! Already open file unit for printout. Default = stdout
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                              :: lev,fileu
    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'part_print_info'
    CHARACTER(LEN = ppm_char)            :: myformat
    TYPE(ppm_t_part_prop_s),POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)


    IF (PRESENT(fileunit)) THEN
        fileu = fileunit
    ELSE
        fileu = 6
    ENDIF
    IF (PRESENT(level)) THEN
        lev = MAX(level,1)
    ELSE
        lev = 1
    ENDIF

    WRITE(myformat,'(A,I0,A)') '(',4*lev,'X,A,A,2X,2(A,I0),A)'

    WRITE(fileu,myformat) 'Particle cloud: ',TRIM(color_print(Pc%name,31)),&
       '(N = ',Pc%Npart,' M = ',Pc%Mpart,')'

    lev = lev + 1

    WRITE(myformat,'(A,I0,A,I0,A)') '(',4*lev,'X,A,',&
        ppm_param_length_partflags,'L)'
    WRITE(fileu,myformat) 'flags: ',Pc%flags

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        CALL prop%print_info(info,lev,fileunit,Pc%props%iter_id)
        prop => Pc%props%next()
    ENDDO

    CALL substop(caller,t0,info)

END SUBROUTINE part_print_info_s

SUBROUTINE prop_print_info_s(prop,info,level,fileunit,propid)
    !-----------------------------------------------------------------------
    ! Print out summary information about this property
    !-----------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_part_prop_s)                          :: prop
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: level
    !!! indentation level at which to printout the info. Default = 0
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: fileunit
    !!! Already open file unit for printout. Default = stdout
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: propid
    !!! id of this property in the parent struct
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                              :: lev,fileu,id
    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'prop_print_info'
    CHARACTER(LEN = ppm_char)            :: myformat
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)


    IF (PRESENT(fileunit)) THEN
        fileu = fileunit
    ELSE
        fileu = 6
    ENDIF
    IF (PRESENT(level)) THEN
        lev = MAX(level,1)
    ELSE
        lev = 1
    ENDIF
    IF (PRESENT(propid)) THEN
        id = propid
    ELSE
        id = 1
    ENDIF

    WRITE(myformat,'(A,I0,A)') '(',4*lev,'X,A,I0,A,A,A,I0)'

    WRITE(fileu,myformat) 'Property ',id,': ',TRIM(color_print(prop%name,33)),&
        ' Type: ',prop%data_type

    lev = lev + 1

    WRITE(myformat,'(A,I0,A)') '(',4*lev,'X,A,I0)'
    WRITE(fileu,myformat) 'lda: ',prop%lda

    WRITE(myformat,'(A,I0,A,I0,A)') '(',4*lev,'X,A,',&
        ppm_param_length_pptflags,'L)'
    WRITE(fileu,myformat) 'flags: ',prop%flags


    CALL substop(caller,t0,info)

END SUBROUTINE prop_print_info_s

SUBROUTINE part_del_parts_s(Pc,list_del_parts,nb_del,info)

    !!! remove some particles from a particle cloud
    !!! WARNING: this implementation is NOT efficient
    !!! if the number of particles to delete is large.

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,DIMENSION(:),POINTER,           INTENT(IN   )  :: list_del_parts
    !!! list of particles to be deleted
    INTEGER,                                INTENT(IN   )  :: nb_del
    !!! number of particles to be deleted
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    INTEGER                              :: i,ip,Npart,del_part,lda
    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_del_particles'
    TYPE(ppm_t_part_prop_s),POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  check arguments
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Pc structure had not been defined. Call allocate first',&
            &  2059,info)
        GOTO 9999
    ENDIF

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        IF (.NOT.prop%flags(ppm_ppt_partial)) THEN
            IF (prop%flags(ppm_ppt_map_parts)) THEN
                info = ppm_error_error
                CALL ppm_error(999,caller,   &
                    & 'property not mapped, data will be lost',&
                    &  2070,info)
                GOTO 9999
            ENDIF
        ENDIF
        prop => Pc%props%next()
    ENDDO

    !-----------------------------------------------------------------
    !  Delete particles
    !-----------------------------------------------------------------
    Npart = Pc%Npart

    del_part = 1

    DO i=1,nb_del
        ip = list_del_parts(i)

        ! copying particles from the end of xp to the index that has
        ! to be removed
        Pc%xp(1:ppm_dim,ip) = Pc%xp(1:ppm_dim,Npart-i+1)

        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_partial)) THEN

                    lda = prop%lda

                    IF (lda.GE.2) THEN
                        SELECT CASE (prop%data_type)
                        CASE (ppm_type_int)
                            prop%data_2d_i(1:lda,ip) = &
                                prop%data_2d_i(1:lda,Npart-i+1)
                        CASE (ppm_type_longint)
                            prop%data_2d_li(1:lda,ip) = &
                                prop%data_2d_li(1:lda,Npart-i+1)
                        CASE (ppm_type_real)
                            prop%data_2d_r(1:lda,ip) = &
                                prop%data_2d_r(1:lda,Npart-i+1)
                        CASE (ppm_type_comp)
                            prop%data_2d_c(1:lda,ip) = &
                                prop%data_2d_c(1:lda,Npart-i+1)
                        CASE (ppm_type_logical )
                            prop%data_2d_l(1:lda,ip) = &
                                prop%data_2d_l(1:lda,Npart-i+1)
                        END SELECT

                    ELSE
                        SELECT CASE (prop%data_type)
                        CASE (ppm_type_int)
                            prop%data_1d_i(ip) = &
                                prop%data_1d_i(Npart-i+1)
                        CASE (ppm_type_longint)
                            prop%data_1d_li(ip) = &
                                prop%data_1d_li(Npart-i+1)
                        CASE (ppm_type_real)
                            prop%data_1d_r(ip) = &
                                prop%data_1d_r(Npart-i+1)
                        CASE (ppm_type_comp)
                            prop%data_1d_c(ip) = &
                                prop%data_1d_c(Npart-i+1)
                        CASE (ppm_type_logical )
                            prop%data_1d_l(ip) = &
                                prop%data_1d_l(Npart-i+1)
                        END SELECT
                    ENDIF
                prop => Pc%props%next()
            ENDIF
        ENDDO
    ENDDO
    !New number of particles, after deleting some
    Pc%Npart = Npart - del_part

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_del_parts_s

SUBROUTINE part_prop_push_s(Pc,prop_id,info)

    !!! wrapper for ppm_map_part_push

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------
    USE ppm_module_map

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                                INTENT(IN   )  :: prop_id
    !!! id of the property to be pushed
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'map_part_push'
    INTEGER                              :: lda
    TYPE(ppm_t_part_prop_s),POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  Check arguments
    !-----------------------------------------------------------------

    !-----------------------------------------------------------------
    !  Call ppm_map_part_push
    !-----------------------------------------------------------------
    prop => Pc%props%vec(prop_id)%t
    lda = prop%lda

    IF (lda.GE.2) THEN
        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_push(&
            prop%data_2d_i,lda,Pc%Npart,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2209,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_push(&
            prop%data_2d_r,lda,Pc%Npart,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_push(&
            prop%data_2d_c,lda,Pc%Npart,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_push(&
            prop%data_2d_l,lda,Pc%Npart,info)
        END SELECT

    ELSE

        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_push(&
            prop%data_1d_i,Pc%Npart,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2232,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_push(&
            prop%data_1d_r,Pc%Npart,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_push(&
            prop%data_1d_c,Pc%Npart,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_push(&
            prop%data_1d_l,Pc%Npart,info)
        END SELECT
    ENDIF

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_prop_push_s

SUBROUTINE part_prop_pop_s(Pc,prop_id,Npart_new,info)

    !!! wrapper for ppm_map_part_pop

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------
    USE ppm_module_map

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                                INTENT(IN   )  :: prop_id
    !!! id of the property to be pushed
    INTEGER,                                INTENT(IN   )  :: Npart_new
    !!! number of particles to pop from the buffer
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'map_part_push'
    INTEGER                              :: lda
    TYPE(ppm_t_part_prop_s),POINTER :: prop
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  Check arguments
    !-----------------------------------------------------------------

    !-----------------------------------------------------------------
    !  Call ppm_map_part_pop
    !-----------------------------------------------------------------
    prop => Pc%props%vec(prop_id)%t
    lda = prop%lda

    IF (lda.GE.2) THEN
        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_pop(&
            prop%data_2d_i,lda,Pc%Npart,Npart_new,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2315,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_pop(&
            prop%data_2d_r,lda,Pc%Npart,Npart_new,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_pop(&
            prop%data_2d_c,lda,Pc%Npart,Npart_new,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_pop(&
            prop%data_2d_l,lda,Pc%Npart,Npart_new,info)
        END SELECT

    ELSE

        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_pop(&
            prop%data_1d_i,Pc%Npart,Npart_new,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2338,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_pop(&
            prop%data_1d_r,Pc%Npart,Npart_new,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_pop(&
            prop%data_1d_c,Pc%Npart,Npart_new,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_pop(&
            prop%data_1d_l,Pc%Npart,Npart_new,info)
        END SELECT
    ENDIF

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_prop_pop_s


FUNCTION get_dcop_s(Pc,eta_id,with_ghosts)
    CLASS(ppm_t_particles_s)      :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_single
    INTEGER                            :: eta_id
    REAL(MK),DIMENSION(:,:),POINTER    :: get_dcop_s
    LOGICAL,OPTIONAL                   :: with_ghosts

    IF (eta_id .LE. 0 .OR. eta_id .GT. Pc%ops%max_id) THEN
        write(*,*) 'ERROR: failed to get operator for id ',eta_id
        get_dcop_s => NULL()
        RETURN
    ENDIF

    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            get_dcop_s => &
                Pc%ops%vec(eta_id)%t%ker(:,1:Pc%Mpart)
            RETURN
        ENDIF
    ENDIF
    get_dcop_s => &
        Pc%ops%vec(eta_id)%t%ker(:,1:Pc%Npart)

END FUNCTION get_dcop_s

FUNCTION set_dcop_s(Pc,eta_id)
    CLASS(ppm_t_particles_s)   :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_single
    INTEGER                         :: eta_id
    REAL(MK),DIMENSION(:,:),POINTER :: set_dcop_s

    set_dcop_s => NULL()

END FUNCTION set_dcop_s

SUBROUTINE part_mapping_s(Pc,info,debug,global,topoid)

    !!!  Partial/Global mapping for particles
    !!!  Assumptions:
    !!! * All the particles have to be inside the domain
    !!!   (otherwise -> "unassigned particle error")

    USE ppm_module_map
    USE ppm_module_data, ONLY: ppm_comm
    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_s)                          :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_single
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional Arguments
    !-------------------------------------------------------------------------
    LOGICAL, OPTIONAL                                   :: debug
    !!! IF true, printout more
    LOGICAL, OPTIONAL                                   :: global
    !!! does a global mapping. Default is false (i.e. partial mapping)
    INTEGER, OPTIONAL                                   :: topoid
    !!! topology id
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                   :: Npart_new
    !!! new number of particles on this processor
    INTEGER                   :: ltopoid
    !!! index variable
    CHARACTER(LEN = ppm_char) :: caller = 'particles_mapping'
    REAL(KIND(1.D0))          :: t0,t1,t2
    LOGICAL                   :: dbg,partial
    TYPE(ppm_t_part_prop_s), POINTER :: prop => NULL()
    TYPE(ppm_t_neighlist_s), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_s),  POINTER :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    t1 = MPI_WTIME(info)
    dbg = .FALSE.
    IF (PRESENT(debug)) dbg = debug
    !-----------------------------------------------------------------
    !  Checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Pc structure had not been defined. Call allocate first',&
            &  2456,info)
        GOTO 9999
    ENDIF
    IF (.NOT.Pc%flags(ppm_part_areinside)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'some Pc may be outside the domain. Apply BC first',&
            &  2463,info)
        GOTO 9999
    ENDIF

    IF (PRESENT(global)) THEN
        IF(.NOT.PRESENT(topoid)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'need the topoid parameter for global mapping',&
                &  2472,info)
            GOTO 9999
        ENDIF
        IF (global) partial = .FALSE.
    ELSE
        partial = .TRUE.
    ENDIF

    IF (partial) THEN
        ltopoid = Pc%active_topoid
    ELSE
        ltopoid = topoid
    ENDIF

    !-----------------------------------------------------------------------
    !  Map the particles onto the topology
    !-----------------------------------------------------------------------
    IF (partial .AND. Pc%flags(ppm_part_partial)) THEN
        !Particles have already been mapped onto this topology
        !nothing to do
    ELSE
        t1 = MPI_WTIME(info)
        IF (partial) THEN
            CALL ppm_map_part_partial(ltopoid,Pc%xp,Pc%Npart,info) 
            Pc%stats%nb_part_map = Pc%stats%nb_part_map + 1
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(999,caller,&
                    'ppm_map_part_partial failed',2502,info)
                GOTO 9999
            ENDIF
        ELSE
            CALL ppm_map_part_global(ltopoid,Pc%xp,Pc%Npart,info) 
            Pc%stats%nb_global_map = Pc%stats%nb_global_map + 1
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(999,caller,&
                    'ppm_map_part_global failed',2511,info)
                GOTO 9999
            ENDIF
        ENDIF

        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_map_parts)) THEN
                IF(dbg) &
                    write(*,*) 'pushing property ',Pc%props%iter_id
                CALL Pc%map_part_push_legacy(Pc%props%iter_id,info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(999,caller,&
                        'ppm_map_part_prop_push failed',2525,info)
                    GOTO 9999
                ENDIF
            ENDIF
            prop => Pc%props%next()
        ENDDO

        CALL ppm_map_part_send(Pc%Npart,Npart_new,info)
        IF (info .NE. 0) THEN
            CALL ppm_error(0,caller,&
                'ppm_map_part_send failed',2535,info)
            GOTO 9999
        ENDIF

        prop => Pc%props%last()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_map_parts)) THEN
                IF(dbg) &
                    write(*,*) 'poping property ',Pc%props%iter_id
                CALL Pc%map_part_pop_legacy(Pc%props%iter_id,Npart_new,info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(999,caller,&
                        'ppm_map_part_prop_pop failed',2548,info)
                    GOTO 9999
                ENDIF
                prop%flags(ppm_ppt_partial) = .TRUE.
            ENDIF
            prop => Pc%props%prev()
        ENDDO

        IF(dbg) &
            write(*,*) 'popping xp'
        CALL ppm_map_part_pop(Pc%xp,ppm_dim,Pc%Npart,Npart_new,info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(999,caller,&
                'ppm_map_part_pop failed',2562,info)
            GOTO 9999
        ENDIF

        ! Update states
        ! Number of particles on this processor
        Pc%Npart = Npart_new
        Pc%Mpart = Pc%Npart

        ! This is the active topology for these particles
        IF (.NOT.partial) Pc%active_topoid = topoid

        ! Particles are now mapped on the active topology
        Pc%flags(ppm_part_partial) = .TRUE.
        ! Pc have been re-indexed and ghosts have not been computed
        Pc%flags(ppm_part_ghosts) = .FALSE.

        !   values for poperty arrays have been mapped and ghosts
        !   are no longer up-to-date
        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            prop%flags(ppm_ppt_ghosts) = .FALSE.
            prop => Pc%props%next()
        ENDDO

        ! particles have been re-indexed and neighbour lists not updated
        nl => Pc%neighs%begin()
        DO WHILE (ASSOCIATED(nl))
            nl%uptodate = .FALSE.
            nl => Pc%neighs%next()
        ENDDO
        Pc%flags(ppm_part_neighlists) = .FALSE.

        ! particles have been re-indexed and operators need be recomputed
        op => Pc%ops%begin()
        DO WHILE (ASSOCIATED(op))
            op%flags(ppm_ops_iscomputed) = .FALSE.
            op => Pc%ops%next()
        ENDDO

    ENDIF

    t2 = MPI_WTIME(info)
    IF (partial) THEN
        Pc%stats%t_part_map = Pc%stats%t_part_map + (t2-t1)
    ELSE
        Pc%stats%t_global_map = Pc%stats%t_global_map + (t2-t1)
    ENDIF

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_mapping_s

SUBROUTINE part_mapping_ghosts_s(Pc,info,ghostsize,debug)

    !!!  Ghost mapping for particles
    !!!  Assumptions:
    !!! * Particles positions need to have been mapped onto the topology
    !!!
    USE ppm_module_data, ONLY: ppm_topo
    USE ppm_module_map
    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_s)                       :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_single
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)   :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional Arguments
    !-------------------------------------------------------------------------
    REAL(MK), OPTIONAL                                  :: ghostsize
    !!! size of the ghost layers. Default is to use the particles cutoff
    LOGICAL, OPTIONAL                                   :: debug
    !!! IF true, printout more
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                                   :: topoid
    !!! index variable
    REAL(MK)                                  :: cutoff
    !!! cutoff radius
    TYPE(ppm_t_topo),POINTER                  :: topo => NULL()
    CHARACTER(LEN = ppm_char) :: caller = 'particles_mapping_ghosts'
    REAL(KIND(1.D0))                          :: t0,t1,t2
    LOGICAL                                   :: dbg
    LOGICAL                                   :: skip_ghost_get
    LOGICAL                                   :: skip_send
    TYPE(ppm_t_part_prop_s), POINTER :: prop => NULL()
    TYPE(ppm_t_neighlist_s), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_s),  POINTER :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    dbg = .FALSE.
    IF (PRESENT(debug)) dbg=debug
    skip_ghost_get = .FALSE.
    skip_send = .TRUE.
    !we must not call ppm_map_part_send unless ppm_map_part_push (or ghost_get)
    ! has been called (in which case, skip_send is set to FALSE)

    !-----------------------------------------------------------------
    !  Checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  2683,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%flags(ppm_part_partial)) THEN
        !Particles have not been mapped onto this topology
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Do a partial/global mapping before doing a ghost mapping',&
            &  2692,info)
        GOTO 9999
    ENDIF
    IF (.NOT.Pc%flags(ppm_part_areinside)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'some particles may be outside the domain. Apply BC first',&
            &  2699,info)
        GOTO 9999
    ENDIF


    topoid = Pc%active_topoid
    topo=>ppm_topo(topoid)%t

    cutoff = Pc%ghostlayer
    IF (PRESENT(ghostsize)) THEN
        IF (ghostsize .LT. cutoff) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'using ghostsize < cutoff+skin. Increase ghostsize.',&
                &  2713,info)
            GOTO 9999
        ELSE
            cutoff = ghostsize
        ENDIF
    ENDIF

    IF (cutoff .GT. topo%ghostsizes) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'ghostsize of topology may be smaller than that of particles',&
            &  2725,info)
        GOTO 9999
    ENDIF
    IF (cutoff .GT. 0._MK) THEN
        IF (Pc%flags(ppm_part_ghosts)) THEN
            IF (dbg) THEN
                write(*,*) 'ghosts have already been updated'
            ENDIF

            IF (ppm_map_type_isactive(ppm_param_map_ghost_get)) THEN
                IF (dbg) THEN
                    write(*,*) 'we skip the ghost_get and go straight to'
                    write(*,*) 'push/send/pop'
                ENDIF
                skip_ghost_get = .TRUE.
            ENDIF
        ENDIF

        IF (.NOT.skip_ghost_get) THEN
            Pc%stats%nb_ghost_get = Pc%stats%nb_ghost_get + 1
            t1 = MPI_WTIME(info)
            IF(dbg) &
                write(*,*) 'ghost-get '
            CALL ppm_map_part_ghost_get(topoid,Pc%xp,ppm_dim,&
                Pc%Npart,Pc%isymm,cutoff,info)
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_sub_failed,caller,&
                    'ppm_map_part_ghost_get failed',2768,info)
                GOTO 9999
            ENDIF
            t2 = MPI_WTIME(info)
            Pc%stats%t_ghost_get = Pc%stats%t_ghost_get + (t2-t1)
            skip_send = .FALSE.
        ELSE
            IF(dbg) &
                write(*,*) 'skipping ghost-get '
        ENDIF

        !Update the ghost for the properties if
        ! 1) they have been mapped to this topology,
        ! 2) the ghosts have not yet been updated, and
        ! 3) the user wants them to be updated
        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))

            IF (prop%flags(ppm_ppt_map_ghosts)) THEN
                IF (.NOT.prop%flags(ppm_ppt_ghosts)) THEN
                    IF (prop%flags(ppm_ppt_partial)) THEN

                        IF(dbg) &
                            write(*,*) 'pushing property ',Pc%props%iter_id,&
                            TRIM(prop%name)
                        Pc%stats%nb_ghost_push = &
                            Pc%stats%nb_ghost_push + 1
                        t1 = MPI_WTIME(info)
                        CALL Pc%map_part_push_legacy(Pc%props%iter_id,info)
                        IF (info .NE. 0) THEN
                            info = ppm_error_error
                            CALL ppm_error(ppm_err_sub_failed,caller,&
                                'ppm_map_part_push failed',2804,info)
                            GOTO 9999
                        ENDIF
                        t2 = MPI_WTIME(info)
                        Pc%stats%t_ghost_push = &
                            Pc%stats%t_ghost_push + (t2-t1)
                        skip_send = .FALSE.
                    ELSE
                        write(*,*) 'pushing property ',Pc%props%iter_id,TRIM(prop%name)
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_argument,caller,&
                            'getting ghosts for a property thats not mapped',&
                            2818,info)
                        GOTO 9999
                    ENDIF
                ENDIF
            ENDIF
            prop => Pc%props%next()
        ENDDO

        IF (.NOT. skip_send) THEN
            CALL ppm_map_part_send(Pc%Npart,Pc%Mpart,info)
            IF (info .NE. 0) THEN
                write(*,*) 'ppm_map_part_send failed with info = ',info
                info = ppm_error_error
                CALL ppm_error(ppm_err_sub_failed,caller,&
                    'ppm_map_part_send failed',2832,info)
                GOTO 9999
            ENDIF

            prop => Pc%props%last()
            DO WHILE (ASSOCIATED(prop))

                IF (prop%flags(ppm_ppt_map_ghosts)) THEN
                    IF (.NOT.prop%flags(ppm_ppt_ghosts)) THEN
                        IF (prop%flags(ppm_ppt_partial)) THEN

                            IF(dbg) &
                                write(*,*) 'popping property ',Pc%props%iter_id,&
                                TRIM(prop%name)
                            CALL Pc%map_part_pop_legacy(Pc%props%iter_id,Pc%Mpart,info)
                            IF (info .NE. 0) THEN
                                write(*,*) 'popping property ',Pc%props%iter_id,&
                                    TRIM(prop%name)
                                info = ppm_error_error
                                CALL ppm_error(ppm_err_sub_failed,caller,&
                                    'ppm_map_part_pop failed',2852,info)
                                GOTO 9999
                            ENDIF
                            prop%flags(ppm_ppt_ghosts) = .TRUE.
                        ENDIF
                    ENDIF
                ENDIF
                prop => Pc%props%prev()
            ENDDO

            IF (.NOT.skip_ghost_get) THEN
                IF(dbg) &
                    write(*,*) 'popping-xp '
                CALL ppm_map_part_pop(Pc%xp,ppm_dim,Pc%Npart,&
                    Pc%Mpart,info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_sub_failed,caller,&
                        'ppm_map_part_pop failed',2870,info)
                    GOTO 9999
                ENDIF
            ENDIF
        ENDIF !.NOT.skip_send

    ELSE ! if cutoff.LE.0

        IF(dbg) THEN
            write(*,*) 'cutoff = 0, nothing to do'
            write(*,*) 'setting all %has_ghost properties to true'
        ENDIF

        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_map_ghosts)) THEN
                prop%flags(ppm_ppt_ghosts) = .TRUE.
            ENDIF
            prop => Pc%props%next()
        ENDDO
    ENDIF


    ! Update states
    !   ghosts have been computed
    Pc%flags(ppm_part_ghosts) = .TRUE.
    ! the states for the properties have already been updated above

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_mapping_ghosts_s

SUBROUTINE part_apply_bc_s(Pc,info)

    !!!  Apply boundary conditions for particles positions
    !!!  Assumptions:
    !!! * Particles positions need to have been mapped onto the topology

    USE ppm_module_data, ONLY: ppm_topo,ppm_rank

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_s)                         :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_single
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    REAL(MK), DIMENSION(:,:),POINTER                      :: xp => NULL()
    !!! pointer to positions
    TYPE(ppm_t_topo),POINTER                              :: topo => NULL()
    !!! pointer to topology
    REAL(MK), DIMENSION(ppm_dim)                          :: min_phys,max_phys
    !!! computational domain corners
    REAL(MK), DIMENSION(ppm_dim)                          :: len_phys
    !!! length of the computational domain
    INTEGER                                               :: di,ip
    INTEGER                                               :: topoid
    INTEGER                                               :: Npart,del_part
    INTEGER,DIMENSION(:),POINTER                          :: list_del_parts
    REAL(ppm_kind_double)                                 :: t0
    CHARACTER(LEN = ppm_char)                   :: caller = 'particles_apply_bc'
    REAL(MK)                                              :: almostone
    TYPE(ppm_t_part_prop_s),POINTER                  :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    !-----------------------------------------------------------------
    !  checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  2953,info)
        GOTO 9999
    ENDIF

    topoid = Pc%active_topoid
    topo=>ppm_topo(topoid)%t
    xp=>Pc%xp
    Npart = Pc%Npart
    almostone = 1._MK - EPSILON(1._MK)

    !-----------------------------------------------------------------
    !  Move particles if needed
    !-----------------------------------------------------------------
    min_phys = topo%min_physs
    max_phys = topo%max_physs
    len_phys=max_phys-min_phys

    del_part = 0
    DO di=1,ppm_dim
        IF (topo%bcdef(di) .EQ. ppm_param_bcdef_periodic) THEN
            DO ip=1,Npart
                IF (xp(di,ip) .EQ. max_phys(di)) &
                    xp(di,ip) = xp(di,ip) - len_phys(di)*almostone
                IF (xp(di,ip) .GT. max_phys(di)) &
                    xp(di,ip) = xp(di,ip) - len_phys(di)
                IF (xp(di,ip) .LT. min_phys(di)) &
                    xp(di,ip) = xp(di,ip) + len_phys(di)
            ENDDO
        ELSE IF (topo%bcdef(di) .EQ. ppm_param_bcdef_freespace) THEN
            !delete particles that have crossed the boundary
            DO ip=Npart,1,-1
                IF (xp(di,ip).GE.max_phys(di).OR.xp(di,ip).LT.min_phys(di)) THEN
                    del_part = del_part+1
                ENDIF
            ENDDO
        ELSE
            info = ppm_error_error
            CALL ppm_error(999,caller,   &
                & 'this type of BC is not implemented/tested in this version',&
                &  2997,info)
            GOTO 9999
        ENDIF
    ENDDO

    IF (del_part .GT. 0 ) THEN
        ldc(1) = del_part
        CALL ppm_alloc(list_del_parts,ldc,ppm_param_alloc_fit,info)
        del_part = 0
        DO di=1,ppm_dim
            IF (topo%bcdef(di) .EQ. ppm_param_bcdef_freespace) THEN
                DO ip=Npart,1,-1
                    IF (xp(di,ip).GE.max_phys(di).OR.xp(di,ip).LT.min_phys(di)) THEN
                        del_part = del_part+1
                        list_del_parts(del_part)=ip
                    ENDIF
                ENDDO
            ENDIF
        ENDDO
        CALL Pc%del_parts(list_del_parts,del_part,info)
        IF (info.NE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_sub_failed,caller,   &
                & 'could not delete particles',&
                &  3021,info)
            GOTO 9999
        ENDIF
        DEALLOCATE(list_del_parts)
    ENDIF

    ! Update states
    Pc%Npart = Npart
    ! Particles are no longer on the right processors
    Pc%flags(ppm_part_partial) = .FALSE.
    ! But they are now all inside the computational domain
    Pc%flags(ppm_part_areinside) = .TRUE.
    ! Dangereous to use the ghosts
    Pc%flags(ppm_part_ghosts) = .FALSE.
    ! ghosts values for properties are also dangerous to use
    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        prop%flags(ppm_ppt_ghosts) = .FALSE.
        prop => Pc%props%next()
    ENDDO


    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    xp => NULL()
    topo => NULL()
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_apply_bc_s

SUBROUTINE part_move_s(Pc,disp,info)

    !!!  Move all particles according to some displacement field
    !!!  The size of disp must match the size of xp

    USE ppm_module_data, ONLY: ppm_topo,ppm_rank

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)                         :: Pc
    !!! Data structure containing the particles
    REAL(MK), DIMENSION(:,:), POINTER,  INTENT(IN   )     :: disp
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    REAL(ppm_kind_double)                                 :: t0
    INTEGER                                               :: ip
    CHARACTER(LEN = ppm_char)                 :: caller ='particles_move'
    REAL(MK),DIMENSION(:,:),POINTER                       :: xp=>NULL()
    TYPE(ppm_t_part_prop_s),POINTER                  :: prop => NULL()
    TYPE(ppm_t_operator_s), POINTER                  :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    !-----------------------------------------------------------------
    !  checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  3091,info)
        GOTO 9999
    ENDIF


    CALL Pc%get_xp(xp)
    FORALL (ip=1:Pc%Npart) &
            xp(1:ppm_dim,ip) = xp(1:ppm_dim,ip) + disp(1:ppm_dim,ip)
    CALL Pc%set_xp(xp)

    !-----------------------------------------------------------------
    !  update states
    !-----------------------------------------------------------------
    Pc%flags(ppm_part_ghosts) = .FALSE.

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        prop%flags(ppm_ppt_ghosts) = .FALSE.
        prop => Pc%props%next()
    ENDDO

    op => Pc%ops%begin()
    DO WHILE (ASSOCIATED(op))
        op%flags(ppm_ops_iscomputed) = .FALSE.
        op => Pc%ops%next()
    ENDDO

    Pc%flags(ppm_part_partial) = .FALSE.
    Pc%flags(ppm_part_cartesian) = .FALSE.

    !-----------------------------------------------------------------
    !  Finalize
    !-----------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_move_s

SUBROUTINE part_neighlist_s(Pc,info,&
        nlid,lstore,incl_ghosts,knn)
    !-----------------------------------------------------------------
    !  Neighbor lists for particles
    !-----------------------------------------------------------------
    !  Assumptions:
    ! * Particles positions need to have been mapped onto the topology
    ! * Ghost positions have been computed
    !
    USE ppm_module_neighlist
    USE ppm_module_inl_vlist
    
    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_s)                          :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_single
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER, OPTIONAL,                  INTENT(INOUT)      :: nlid
    !!! which neighbour list are we computing. Default is 1
    LOGICAL, OPTIONAL,                  INTENT(IN   )      :: lstore
    !!! store verlet lists
    LOGICAL, OPTIONAL,                  INTENT(IN   )      :: incl_ghosts
    !!! if true, then verlet lists are computed for all particles, incl. ghosts.
    !!! Default is false.
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: knn
    !!! if present, neighbour lists are constructed such that each particle
    !!! has at least knn neighbours.
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                                   :: op_id,np_target,i
    INTEGER                                   :: ip,ineigh
    !!! index variable
    LOGICAL                                   :: symmetry
    !!! backward compatibility
    LOGICAL                                   :: ensure_knn
    !!! uses a neighbour-finding algorithm that finds enough neighbours
    REAL(MK),DIMENSION(2*ppm_dim):: ghostlayer
    !!!
    CHARACTER(LEN = ppm_char)                 :: caller = 'part_comp_neighlist'
    REAL(KIND(1.D0))                          :: t0,t1,t2
    TYPE(ppm_t_topo), POINTER                 :: topo
    INTEGER                                   :: neigh_id,topoid
    INTEGER                                   :: nneighmin,nneighmax
    TYPE(ppm_t_neighlist_s), POINTER      :: Nlist
    REAL(MK)                                  :: skin

    REAL(MK),DIMENSION(:),POINTER             :: rcp  => NULL()
    TYPE(ppm_t_operator_s), POINTER      :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    !-----------------------------------------------------------------
    !  Checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  3211,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%flags(ppm_part_partial)) THEN
        !Particles have not been mapped onto this topology
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Do a partial/global mapping before',&
            &  3220,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%flags(ppm_part_ghosts)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Ghosts have not been updated. They are needed for neighlists',&
            &  3228,info)
        GOTO 9999
    ENDIF

    IF (Pc%neighs%vec_size.LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighlist DS not allocated. Call create_neighlist() first',&
            &  3236,info)
        GOTO 9999
    ENDIF

    !checks that the data structure for the neighbour list has been
    !defined already
    IF (PRESENT(nlid)) THEN
        neigh_id = nlid
        IF (.NOT. Pc%neighs%exists(neigh_id)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'invalid id for neighbour list.',&
                &  3248,info)
            GOTO 9999
        ENDIF
    ELSE
        neigh_id = 1
        IF (Pc%neighs%vec(neigh_id)%t%P_id.NE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
        &  'We assumed default neighlist, but the P_id is not default',&
                &  3257,info)
            GOTO 9999
        ENDIF
    ENDIF

    !define an alias for the neighbour list DS
    Nlist => Pc%neighs%vec(neigh_id)%t
    IF (.NOT.ASSOCIATED(Nlist)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour list not allocated. ',&
            &  3268,info)
        GOTO 9999
    ENDIF

    !check that we have a cutoff radius
    SELECT TYPE (Pc)
    CLASS IS (ppm_t_sop_s)
        IF (Pc%rcp_id.LE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'cutoff radii for adaptive particles have not been defined',&
                &  3279,info)
            GOTO 9999
        ENDIF
        CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=.TRUE.)
        IF (.NOT.ASSOCIATED(rcp)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'DS for cutoff radii is not associated',&
                &  3287,info)
            GOTO 9999
        ENDIF
    CLASS DEFAULT
        IF (Nlist%cutoff.LE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
            &  'cutoff is negative or zero - do we really want neighbour lists?',&
                &  3295,info)
            GOTO 9999
        ENDIF
    END SELECT

    IF (Nlist%isymm.EQ.1) THEN
        symmetry =.TRUE.
    ELSE
        symmetry = .FALSE.
    ENDIF
    IF (PRESENT(knn)) THEN
        ensure_knn = .TRUE.
    ELSE
        ensure_knn = .FALSE.
    ENDIF
    skin = Nlist%skin
    topoid = Pc%active_topoid

    do_something: IF (Nlist%uptodate .OR. Pc%Npart.EQ.0) THEN
        !neighbor lists are already up-to-date, or no particles on this proc
        !nothing to do
        IF (Nlist%uptodate) THEN
            info = ppm_error_notice
            CALL ppm_error(999,caller,   &
                &  'neighlists are already up-to-date, NOTHING to do',&
                &  3320,info)
            info = 0
        ELSE
            Nlist%nneighmin = 0
            Nlist%nneighmax = 0
        ENDIF
    ELSE
        !hack to build (potentially incomplete) neighbour lists even 
        !for ghost particles
        np_target = Pc%Npart
        IF (PRESENT(incl_ghosts)) THEN
            IF (incl_ghosts) THEN
                np_target = Pc%Mpart
                topo => ppm_topo(topoid)%t
                IF (MK.EQ.ppm_kind_single) THEN
                    topo%min_subs(:,:) = topo%min_subs(:,:) - topo%ghostsizes
                    topo%max_subs(:,:) = topo%max_subs(:,:) + topo%ghostsizes
                ELSE IF (MK.EQ.ppm_kind_double) THEN
                    topo%min_subd(:,:) = topo%min_subd(:,:) - topo%ghostsized
                    topo%max_subd(:,:) = topo%max_subd(:,:) + topo%ghostsized
                ENDIF
            ENDIF
        ENDIF

        IF (ensure_knn) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_alloc,caller,   &
                    &   'option required the kdtree module.',3394,info)
                GOTO 9999
!__WITH_KDTREE
        ELSE  

            SELECT TYPE (Pc)
            CLASS IS (ppm_t_sop_s)

                !FIXME: when adaptive ghost layers are available
                ghostlayer(1:2*ppm_dim)=Pc%ghostlayer

!__WITH_CNL
                    Pc%stats%nb_inl = Pc%stats%nb_inl+1

                    t1 = MPI_WTIME(info)
                    CALL ppm_inl_vlist(topoid,Pc%xp,np_target,&
                        Pc%Mpart,rcp,skin,symmetry,ghostlayer,info,&
                        Nlist%vlist,Nlist%nvlist)
                    IF (info .NE. 0) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_sub_failed,caller,&
                            'ppm_inl_vlist failed',3453,info)
                        GOTO 9999
                    ENDIF
                    t2 = MPI_WTIME(info)
                    Pc%stats%t_inl = Pc%stats%t_inl + (t2 - t1)

            CLASS DEFAULT

                Pc%stats%nb_nl = Pc%stats%nb_nl+1

                t1 = MPI_WTIME(info)
                CALL ppm_neighlist_vlist(topoid,Pc%xp,Pc%Mpart,&
                    Nlist%cutoff,skin,symmetry,Nlist%vlist,&
                    Nlist%nvlist,info,lstore=lstore)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_sub_failed,caller,&
                        'ppm_neighlist_vlist failed',3477,info)
                    GOTO 9999
                ENDIF
                t2 = MPI_WTIME(info)
                Pc%stats%t_nl = Pc%stats%t_nl + (t2 - t1)
            END SELECT
        ENDIF

        !restore subdomain sizes (revert hack)
        IF (PRESENT(incl_ghosts)) THEN
            IF (incl_ghosts) THEN
                IF (MK.EQ.ppm_kind_single) THEN
                    topo%min_subs(:,:) = topo%min_subs(:,:) + topo%ghostsizes
                    topo%max_subs(:,:) = topo%max_subs(:,:) - topo%ghostsizes
                ELSE IF (MK.EQ.ppm_kind_double) THEN
                    topo%min_subd(:,:) = topo%min_subd(:,:) + topo%ghostsized
                    topo%max_subd(:,:) = topo%max_subd(:,:) - topo%ghostsized
                ENDIF
                topo => NULL()
            ENDIF
        ENDIF

        !-----------------------------------------------------------------------
        !Update state
        !-----------------------------------------------------------------------
        Nlist%uptodate = .TRUE.

        Nlist%nneighmin = MINVAL(Nlist%nvlist(1:Pc%Npart))
        Nlist%nneighmax = MAXVAL(Nlist%nvlist(1:np_target))

        ! DC operators that do not use a xset neighbour list, if they exist, 
        ! are no longer valid (they depend on the neighbour lists)
        op => Pc%ops%begin()
        DO WHILE (ASSOCIATED(op))
            IF (.NOT.op%flags(ppm_ops_interp)) THEN
                op%flags(ppm_ops_iscomputed) = .FALSE.
            ENDIF
            op => Pc%ops%next()
        ENDDO

        
        Nlist => NULL()

        !FIXME
        ! We want to distinguish between "self" neighbour lists
        ! and cross-set ones.
        IF (neigh_id .EQ. 1) THEN
            Pc%flags(ppm_part_neighlists) = .TRUE.
        ENDIF

    ENDIF do_something
    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_neighlist_s


FUNCTION part_DS_exists_s(cont,id,caller) RESULT(exists)
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_container_s)                       :: cont
    !!! Data structure containing the particles
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    LOGICAL                                             :: exists
    !!! Return status, on success 0.
    CHARACTER(LEN = *),OPTIONAL                         :: caller
    !!! Calling routine
    
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)               :: lcaller
    INTEGER                                 :: info


    IF (PRESENT(caller)) THEN
        lcaller = TRIM(ADJUSTL(caller))
    ELSE
        lcaller = 'ppm_DS_exists'
    ENDIF
    exists = .FALSE.
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (id.LE.0 .OR. id.GT.cont%max_id) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,lcaller,   &
            & 'Invalid id for this data structure, use create() first',&
            3578,info)
        RETURN
    ENDIF

    !NB: ugly code b/c no templating
    SELECT TYPE(cont)
    TYPE IS (ppm_c_props_s)
        IF (ASSOCIATED(cont%vec)) THEN
            IF (ASSOCIATED(cont%vec(id)%t)) THEN
                exists = .TRUE.
                RETURN
            ENDIF
        ENDIF
    TYPE IS (ppm_c_operators_s)
        IF (ASSOCIATED(cont%vec)) THEN
            IF (ASSOCIATED(cont%vec(id)%t)) THEN
                exists = .TRUE.
                RETURN
            ENDIF
        ENDIF
    TYPE IS (ppm_c_neighlists_s)
        IF (ASSOCIATED(cont%vec)) THEN
            IF (ASSOCIATED(cont%vec(id)%t)) THEN
                exists = .TRUE.
                RETURN
            ENDIF
        ENDIF
    END SELECT


    info = ppm_error_error
    CALL ppm_error(ppm_err_argument,lcaller,   &
        & 'No data structure found, use create() first',&
        3611,info)
    RETURN



END FUNCTION part_DS_exists_s

SUBROUTINE part_set_cutoff_s(Pc,cutoff,info,nlid)
    !!! Set a cutoff radius for a particle cloud and update the
    !!! the ghostlayer sizes.
    !!! The cutoff radius concerns the default neighbor list, unless
    !!! specified otherwise.
    !-------------------------------------------------------------------------
    ! Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)            :: Pc
    REAL(MK),                 INTENT(IN   )  :: cutoff
    !!! cutoff radius
    INTEGER,                  INTENT(   OUT) :: info
    !!! return status. On success, 0
    INTEGER,OPTIONAL,         INTENT(IN    ) :: nlid
    !!! ID of the neighbor list for which this cutoff radius
    !!! applies. Default is ppm_param_default_nlID
    
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    TYPE(ppm_t_neighlist_s),     POINTER :: nl => NULL()
    INTEGER                                   :: neigh_id 
    CHARACTER(LEN = ppm_char)                 :: caller = 'part_set_cutoff'
    REAL(KIND(1.D0))                          :: t0

    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-------------------------------------------------------------------------
    !  Set new cutoff
    !-------------------------------------------------------------------------
    IF (PRESENT(nlid)) THEN
        neigh_id = nlid
    ELSE
        neigh_id = ppm_param_default_nlID
    ENDIF
    
    Pc%neighs%vec(neigh_id)%t%cutoff = cutoff

    ! Compute ghostlayer sizes
    IF (cutoff.GT.Pc%ghostlayer) THEN
        !If the new cutoff is larger than the current ghostsize
        ! then the new ghostsize is the new cutoff
        Pc%ghostlayer = cutoff
        ! update states
        Pc%flags(ppm_part_ghosts) = .FALSE.
    ELSE IF (cutoff .LT. Pc%ghostlayer) THEN
        !Else, we find the new maximum cutoff radius amongst
        !all existing neighbor lists on this particle cloud
        Pc%ghostlayer = 0._mk
        nl => Pc%neighs%begin()
        DO WHILE (ASSOCIATED(nl))
            IF (nl%cutoff .GT. Pc%ghostlayer) THEN
                Pc%ghostlayer = nl%cutoff
            ENDIF
            nl => Pc%neighs%next()
        ENDDO
        !no need to update states: ghosts are still ok.
    ENDIF

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_set_cutoff_s

SUBROUTINE part_comp_global_index_s(Pc,info)
    !!! Compute a global index for particles
    !!! (Uses MPI communications)
    !-------------------------------------------------------------------------
    ! Arguments
    !-------------------------------------------------------------------------
    INCLUDE "mpif.h"

    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_particles_s)            :: Pc
    INTEGER,                  INTENT(   OUT) :: info
    !!! return status. On success, 0

    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)                 :: caller = 'part_global_index'
    REAL(KIND(1.D0))                          :: t0

    INTEGER                        :: offset
    INTEGER                        :: i
    INTEGER, DIMENSION(:), POINTER :: wp
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    IF (.NOT. Pc%flags(ppm_part_global_index)) THEN
        CALL Pc%create_prop(Pc%gi_id,ppm_type_int,info,name="GlobalIndex")
        Pc%flags(ppm_part_global_index) = .TRUE.
    END IF
    CALL MPI_Scan(Pc%Npart,offset,1,MPI_INTEGER,MPI_SUM,ppm_comm,info)
    offset = offset - Pc%Npart
    CALL Pc%get(wp,Pc%gi_id)
    FORALL (i=1:Pc%Npart) wp(i) = offset + i !- 1 !uncomment if index from 0
    CALL Pc%set(wp,Pc%gi_id)

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_comp_global_index_s










SUBROUTINE part_map_create_s(Pc,id,source_topoid,target_topoid,info)
    !!! Adds a property to an existing particle set
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(  OUT) :: id
    INTEGER,                INTENT(IN   ) :: source_topoid
    INTEGER,                INTENT(IN   ) :: target_topoid
    INTEGER,               INTENT(OUT)    :: info

    INTEGER                               :: vec_size,npart,i
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_map_create'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_part_mapping_s),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_part_mapping_s),               POINTER  :: map => NULL()
    LOGICAL, DIMENSION(ppm_param_length_pptflags):: flags

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%maps )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of mapping pointers
            id = id + 1
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of mapping pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating mapping array failed',3787,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of mapping pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating mapping array failed',3798,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE

    IF (.NOT. ASSOCIATED(Pc%maps%vec(id)%t)) THEN
        ALLOCATE(Pc%maps%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating mapping pointer failed',3823,info)
            GOTO 9999
        ENDIF
    ENDIF

    map => Pc%maps%vec(id)%t

    ! Create the mapping
    CALL map%create(source_topoid,target_topoid,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating mapping failed',3835,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_map_create_s

SUBROUTINE part_map_destroy_s(Pc,id,info)
    !!! Destroy a mapping from an existing particle set
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_map_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%maps)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'mapping id larger than size of mappings array',&
                3860,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            3888,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE


    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_map_destroy_s


SUBROUTINE map_create_s(map,source_topoid,target_topoid,info)
    !!! Constructor for particle mapping data structure
    INTEGER, PARAMETER :: MK = ppm_kind_single
    CLASS(ppm_t_part_mapping_s)   :: map
    INTEGER,                INTENT(IN) :: source_topoid
    INTEGER,                INTENT(IN) :: target_topoid
    INTEGER,               INTENT(OUT) :: info

    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'map_create'



    CALL substart(caller,t0,info)

    map%source_topoid = source_topoid
    map%target_topoid = target_topoid

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE map_create_s

SUBROUTINE map_destroy_s(map,info)
    CLASS(ppm_t_part_mapping_s)   :: map
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'map_destroy'


    CALL substart(caller,t0,info)

    map%source_topoid = -1
    map%target_topoid = -1

    IF(ASSOCIATED(map%send)) DEALLOCATE(map%send,STAT=info)
    IF(ASSOCIATED(map%recv)) DEALLOCATE(map%recv,STAT=info)
    IF(ASSOCIATED(map%nsend)) DEALLOCATE(map%nsend,STAT=info)
    IF(ASSOCIATED(map%nrecv)) DEALLOCATE(map%nrecv,STAT=info)
    IF(ASSOCIATED(map%psend)) DEALLOCATE(map%psend,STAT=info)
    IF(ASSOCIATED(map%precv)) DEALLOCATE(map%precv,STAT=info)
    IF(ASSOCIATED(map%pp)) DEALLOCATE(map%pp,STAT=info)
    IF(ASSOCIATED(map%qq)) DEALLOCATE(map%qq,STAT=info)

    map%oldNpart = 0
    map%newNpart = 0

    CALL substop(caller,t0,info)

END SUBROUTINE map_destroy_s

















!-------------------------------------------------------------
! Primitive function as defined in Chen et al., 
!             Int. J. Numer. Meth. Engng 2003; 56:935-960.
! (here, the quartic spline)
!-------------------------------------------------------------
FUNCTION primitive_s(x)

    IMPLICIT NONE
    INTEGER, PARAMETER :: MK = ppm_kind_single
    !arguments
    REAL(MK), INTENT(IN) :: x
    REAL(MK)             :: primitive_s
    IF(x.GT.1._MK) THEN 
        primitive_s = 0._MK 
    ELSE
        primitive_s = 1._MK + x**2 * (-6._MK + x * (8._MK -3._MK * x))
    ENDIF

END FUNCTION

SUBROUTINE solveLSE_s(A,x_or_b,info)

    !=======================================================================!
    ! solves the LSE A*x=b
    ! if necessary, singularities are removed &
    ! (WARNING: no check is performed on the 
    ! validity of the solution after that)
    ! x_or_b is expected to contain b on input
    ! x_or_b contains x on output
    ! A is not altered

    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_single
    ! arguments
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(IN   ) :: A 
    REAL(MK), DIMENSION (:)  , POINTER,INTENT(INOUT) :: x_or_b
    INTEGER,                           INTENT(  OUT) :: info

    ! local variables
    INTEGER , DIMENSION (:)  , POINTER   :: indx=>NULL(),valid=>NULL()
    INTEGER , DIMENSION (:)  , POINTER   :: indxnew=>NULL(),roworder=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: bnew=>NULL(),exact_b=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: real_b=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: Anew=>NULL(),Acopy=>NULL()
    REAL(MK)                             :: tolerance_lse = 1e-1

    INTEGER                              :: n,nnew
    INTEGER                              :: i,j,inew,jnew,itemp
    LOGICAL                              :: check = .TRUE.
    CHARACTER(LEN = 256),PARAMETER       :: caller = 'solveLSE'
    CHARACTER(LEN = 256)                 :: cbuf
    REAL(MK)                             :: closetozero

    !=======================================================================!
    ! init
    info = 0
    n = SIZE(A,1)
    !closetozero = SQRT(EPSILON(closetozero))
    closetozero = 100._MK*(EPSILON(closetozero))

    ALLOCATE(indx(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(valid(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(Acopy(n,n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF
    Acopy = A

    IF (check) THEN
        ALLOCATE(exact_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b = x_or_b

        ALLOCATE(real_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! compute the LU factorization of A
    CALL sgetrf(n,n,Acopy,n,indx,info)
    ! if info = i > 0, then U_ii = 0 and the matrix is singular
    ! this case will be dealt with below when checking for singularities
    IF (info .LT. 0) THEN
        WRITE(cbuf,'(A,I2)') ' getrf failed with info = ', info
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    !=======================================================================!
    ! check for singularities

    ! mark redundant eqs/coefficients
    valid = 1
    DO j=1,n
        IF (ABS(Acopy(j,j)) .LT. closetozero) THEN
            valid(j) = 0
        ENDIF
    ENDDO

    nnew = SUM(valid) ! size of reduced system

    ! if necessary, remove redundant equations/coefficients
    IF (nnew .NE. n) THEN

        ALLOCATE(roworder(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        DO i= 1,n
            roworder(i) = i
        ENDDO
        DO i= 1,n
            itemp = roworder(i)
            roworder(i) = roworder(indx(i))
            roworder(indx(i)) = itemp
        ENDDO

        !====================================================================!
        ! create new LSE

        ! allocation
        ALLOCATE(bnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(indxnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(Anew(nnew,nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        ! delete singular rows/columns in A
        ! delete corresponding entries in b
        inew = 0
        DO i = 1,n

            IF (valid(i) .EQ. 1) THEN

                inew = inew + 1
                bnew(inew) = x_or_b(roworder(i))

                jnew = 0
                DO  j = 1,n
                    IF (valid(j) .EQ. 1) THEN

                        jnew = jnew + 1
                        Anew(inew,jnew) = A(roworder(i),roworder(j))

                    ENDIF
                ENDDO

            ENDIF

        ENDDO

        !====================================================================!
        ! solve new LSE
        CALL sgetrf(nnew,nnew,Anew,nnew,indxnew,info)
        IF (info .NE. 0) THEN
            !get the value of info
            WRITE(cbuf,'(A,I2)') ' getrf new failed with info = ', info

            IF (info.GT.0) THEN
                OPEN(81,FILE='DumpA.dat',FORM='FORMATTED',STATUS='REPLACE',IOSTAT=info)
                DO i=1,n
                    WRITE(81,'(10E20.12)') A(i,:)
                ENDDO
                CLOSE(81)
            ENDIF

            !print the error message
            CALL ppm_write(ppm_rank,caller,cbuf,info)

            info = -1
            GOTO 9999
        ENDIF

        CALL sgetrs('N',nnew,1,Anew,nnew,indxnew,bnew,nnew,info)
        IF (info .NE. 0) THEN
            WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        !====================================================================!
        ! sort solution (coefficients) into old places, remaining places are
        ! set to zero 
        jnew = 0
        DO j = 1,n
            x_or_b(j) = 0._MK
        ENDDO
        DO j = 1,n

            IF (valid(j) .EQ. 1) THEN
                jnew = jnew + 1
                x_or_b(roworder(j)) = bnew(jnew)
            ENDIF

        ENDDO

        DEALLOCATE(roworder)
        DEALLOCATE(indxnew)
        DEALLOCATE(bnew)
        DEALLOCATE(Anew)

    ELSE ! no singularities

        !====================================================================!
        ! solve originial LSE
        CALL sgetrs('N',n,1,Acopy,n,indx,x_or_b,n,info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': getrs failed'
            info = -1
            GOTO 9999
        ENDIF

    ENDIF

    !=======================================================================!
    ! check if equations were solved right (if you trust in LAPACK and this 
    ! code PUT THIS IN IF BRANCH FOR THE REDUCED SYSTEM)
    IF (check) THEN
        CALL sgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
            SIZE(A,1),x_or_b,1,0._MK,real_b,1)
        IF (SUM(ABS(real_b - exact_b)) .GT. tolerance_LSE) THEN
            WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
            CALL ppm_write(ppm_rank,caller,&
                'Error in moment conditions too large.',info)
            WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                SUM(ABS(real_b - exact_b))
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            DO i=1,n
                DO j=1,n
                    WRITE(9001,'(1(E30.22))') A(i,j)
                ENDDO
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'moment matrix written in file fort.9001',info)
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! dealloc
    DEALLOCATE(valid)
    DEALLOCATE(indx)
    DEALLOCATE(Acopy)
    IF (check) THEN
        DEALLOCATE(exact_b)
        DEALLOCATE(real_b)
    ENDIF

    9999 CONTINUE ! jump here upon error

END SUBROUTINE solveLSE_s

SUBROUTINE solveLSE_2_s(A,x_or_b,x_or_b_2,info)

    !=======================================================================!
    ! solves the LSE A*x1=b1 and A*x2=b2
    ! if necessary, singularities are removed 
    ! (WARNING: no check is performed on the 
    ! validity of the solution after that)
    ! x_or_b is expected to contain b on input
    ! x_or_b contains x on output
    ! A is not altered

    IMPLICIT NONE
    INTEGER, PARAMETER :: MK = ppm_kind_single
    ! arguments
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(IN   )  :: A 
    REAL(MK), DIMENSION (:)  , POINTER,INTENT(INOUT)  :: x_or_b, x_or_b_2
    INTEGER, INTENT(OUT)                  :: info
    ! local variables
    INTEGER , DIMENSION (:)  , POINTER   :: indx=>NULL(),valid=>NULL()
    INTEGER , DIMENSION (:)  , POINTER   :: indxnew=>NULL(),roworder=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: bnew=>NULL(),bnew_2=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: exact_b=>NULL(),exact_b_2=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: real_b=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: Anew=>NULL(),Acopy=>NULL()
    REAL(MK)                             :: tolerance_lse = 1e-1
    INTEGER                              :: n,nnew
    INTEGER                              :: i,j,inew,jnew,itemp
    LOGICAL                              :: check = .TRUE.
    CHARACTER(LEN = 256),PARAMETER       :: caller = 'solveLSE_2'
    CHARACTER(LEN = 256)                 :: cbuf
    REAL(MK)                             :: closetozero

    !=======================================================================!
    ! init
    info = 0
    n = SIZE(A,1)
    !closetozero = SQRT(EPSILON(closetozero))
    closetozero = 100._MK*(EPSILON(closetozero))

    ALLOCATE(indx(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(valid(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(Acopy(n,n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF
    Acopy = A

    IF (check) THEN
        ALLOCATE(exact_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b = x_or_b

        ALLOCATE(exact_b_2(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b_2 = x_or_b_2

        ALLOCATE(real_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! compute the LU factorization of A
    CALL sgetrf(n,n,Acopy,n,indx,info)
    ! if info = i > 0, then U_ii = 0 and the matrix is singular
    ! this case will be dealt with below when checking for singularities
    IF (info .LT. 0) THEN
        WRITE(cbuf,'(A,I2)') ' getrf failed with info = ', info
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    !=======================================================================!
    ! check for singularities

    ! mark redundant eqs/coefficients
    valid = 1
    DO j=1,n
        IF (ABS(Acopy(j,j)) .LT. closetozero) THEN
            valid(j) = 0
        ENDIF
    ENDDO

    nnew = SUM(valid) ! size of reduced system

    ! if necessary, remove redundant equations/coefficients
    IF (nnew .NE. n) THEN

        ALLOCATE(roworder(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        DO i= 1,n
            roworder(i) = i
        ENDDO
        DO i= 1,n
            itemp = roworder(i)
            roworder(i) = roworder(indx(i))
            roworder(indx(i)) = itemp
        ENDDO

        !====================================================================!
        ! create new LSE

        ! allocation
        ALLOCATE(bnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(bnew_2(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(indxnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(Anew(nnew,nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        ! delete singular rows/columns in A
        ! delete corresponding entries in b
        inew = 0
        DO i = 1,n

            IF (valid(i) .EQ. 1) THEN

                inew = inew + 1
                bnew(inew)   = x_or_b(roworder(i))
                bnew_2(inew) = x_or_b_2(roworder(i))

                jnew = 0
                DO  j = 1,n
                    IF (valid(j) .EQ. 1) THEN

                        jnew = jnew + 1
                        Anew(inew,jnew) = A(roworder(i),roworder(j))

                    ENDIF
                ENDDO

            ENDIF

        ENDDO

        !====================================================================!
        ! solve new LSE
        CALL sgetrf(nnew,nnew,Anew,nnew,indxnew,info)
        IF (info .NE. 0) THEN
            !get the value of info
            WRITE(cbuf,'(A,I2)') ' getrf new failed with info = ', info

            IF (info.GT.0) THEN
                OPEN(81,FILE='DumpA.dat',FORM='FORMATTED',STATUS='REPLACE',IOSTAT=info)
                DO i=1,n
                    WRITE(81,'(10E20.12)') A(i,:)
                ENDDO
                CLOSE(81)
            ENDIF

            !print the error message
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        CALL sgetrs('N',nnew,1,Anew,nnew,indxnew,bnew,nnew,info)
        IF (info .NE. 0) THEN
            WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF
        CALL sgetrs('N',nnew,1,Anew,nnew,indxnew,bnew_2,nnew,info)
        IF (info .NE. 0) THEN
            WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        !====================================================================!
        ! sort solution (coefficients) into old places, remaining places are
        ! set to zero 
        jnew = 0
        DO j = 1,n
            x_or_b(j) = 0._MK
            x_or_b_2(j) = 0._MK
        ENDDO
        DO j = 1,n

            IF (valid(j) .EQ. 1) THEN
                jnew = jnew + 1
                x_or_b(roworder(j)) = bnew(jnew)
                x_or_b_2(roworder(j)) = bnew_2(jnew)
            ENDIF

        ENDDO

        DEALLOCATE(roworder)
        DEALLOCATE(indxnew)
        DEALLOCATE(bnew)
        DEALLOCATE(bnew_2)
        DEALLOCATE(Anew)

    ELSE ! no singularities

        !====================================================================!
        ! solve originial LSE
        CALL sgetrs('N',n,1,Acopy,n,indx,x_or_b,n,info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': getrs failed'
            info = -1
            GOTO 9999
        ENDIF
        CALL sgetrs('N',n,1,Acopy,n,indx,x_or_b_2,n,info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': getrs failed'
            info = -1
            GOTO 9999
        ENDIF

    ENDIF

    !=======================================================================!
    ! check if equations were solved right (if you trust in LAPACK and this 
    ! code PUT THIS IN IF BRANCH FOR THE REDUCED SYSTEM)
    IF (check) THEN
        CALL sgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
            SIZE(A,1),x_or_b,1,0._MK,real_b,1)
        IF (SUM(ABS(real_b - exact_b)) .GT. tolerance_LSE) THEN
            WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
            CALL ppm_write(ppm_rank,caller,&
                'Error in moment conditions 1 too large.',info)
            WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                SUM(ABS(real_b - exact_b))
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            DO i=1,n
                DO j=1,n
                    WRITE(9001,'(1(E30.22))') A(i,j)
                ENDDO
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'moment matrix written in file fort.9001',info)
            info = -1
            GOTO 9999
        ENDIF
        CALL sgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
            SIZE(A,1),x_or_b_2,1,0._MK,real_b,1)
        IF (SUM(ABS(real_b - exact_b_2)) .GT. tolerance_LSE) THEN
            WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
            CALL ppm_write(ppm_rank,caller,&
                'Error in moment conditions 2 too large.',info)
            WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                SUM(ABS(real_b - exact_b_2))
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! dealloc
    DEALLOCATE(valid)
    DEALLOCATE(indx)
    DEALLOCATE(Acopy)
    IF (check) THEN
        DEALLOCATE(exact_b)
        DEALLOCATE(exact_b_2)
        DEALLOCATE(real_b)
    ENDIF

    9999 CONTINUE ! jump here upon error

END SUBROUTINE solveLSE_2_s

SUBROUTINE solveLSE_n_s(A,x_or_b,n_eq,info)

    !=======================================================================!
    ! solves the LSE A*x_i=b_i  for i=1..n_eq
    ! if necessary, singularities are removed 
    ! (WARNING: no check is performed on the 
    ! validity of the solution after that)
    ! x_or_b is expected to contain b on input
    ! x_or_b contains x on output
    ! A is not altered

    IMPLICIT NONE
    INTEGER, PARAMETER :: MK = ppm_kind_single
    ! arguments
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(IN   )  :: A 
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(INOUT)  :: x_or_b
    INTEGER, INTENT(IN)                               :: n_eq
    INTEGER, INTENT(OUT)                              :: info

    ! local variables
    INTEGER , DIMENSION (:)  , POINTER   :: indx=>NULL(),valid=>NULL()
    INTEGER , DIMENSION (:)  , POINTER   :: indxnew=>NULL(),roworder=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: real_b=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: bnew_n=>NULL(),exact_b_n=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: Anew=>NULL(),Acopy=>NULL()
    REAL(MK)                             :: tolerance_lse = 1e-1
    INTEGER                              :: n,nnew
    INTEGER                              :: i,j,k,inew,jnew,itemp
    LOGICAL                              :: check = .TRUE.
    CHARACTER(LEN = 256),PARAMETER       :: caller = 'solveLSE_n'
    CHARACTER(LEN = 256)                 :: cbuf
    REAL(MK)                             :: closetozero

    !=======================================================================!
    ! init
    info = 0
    n = SIZE(A,1)
    !closetozero = SQRT(EPSILON(closetozero))
    closetozero = 100._MK*(EPSILON(closetozero))

    ALLOCATE(indx(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(valid(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(Acopy(n,n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF
    Acopy = A

    IF (check) THEN
        ALLOCATE(exact_b_n(n,n_eq),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b_n = x_or_b

        ALLOCATE(real_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! compute the LU factorization of A
    CALL sgetrf(n,n,Acopy,n,indx,info)
    ! if info = i > 0, then U_ii = 0 and the matrix is singular
    ! this case will be dealt with below when checking for singularities
    IF (info .LT. 0) THEN
        WRITE(cbuf,'(A,I2)') ' getrf failed with info = ', info
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    !=======================================================================!
    ! check for singularities

    ! mark redundant eqs/coefficients
    valid = 1
    DO j=1,n
        IF (ABS(Acopy(j,j)) .LT. closetozero) THEN
            valid(j) = 0
        ENDIF
    ENDDO

    nnew = SUM(valid) ! size of reduced system

    ! if necessary, remove redundant equations/coefficients
    IF (nnew .NE. n) THEN

        ALLOCATE(roworder(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        DO i= 1,n
            roworder(i) = i
        ENDDO
        DO i= 1,n
            itemp = roworder(i)
            roworder(i) = roworder(indx(i))
            roworder(indx(i)) = itemp
        ENDDO

        !====================================================================!
        ! create new LSE

        ! allocation
        ALLOCATE(bnew_n(nnew,n_eq),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(indxnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(Anew(nnew,nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        ! delete singular rows/columns in A
        ! delete corresponding entries in b
        inew = 0
        DO i = 1,n

            IF (valid(i) .EQ. 1) THEN

                inew = inew + 1
                bnew_n(inew,1:n_eq)   = x_or_b(roworder(i),1:n_eq)

                jnew = 0
                DO  j = 1,n
                    IF (valid(j) .EQ. 1) THEN

                        jnew = jnew + 1
                        Anew(inew,jnew) = A(roworder(i),roworder(j))

                    ENDIF
                ENDDO

            ENDIF

        ENDDO

        !====================================================================!
        ! solve new LSE
        CALL sgetrf(nnew,nnew,Anew,nnew,indxnew,info)
        IF (info .NE. 0) THEN
            !get the value of info
            WRITE(cbuf,'(A,I2)') ' getrf new failed with info = ', info

            IF (info.GT.0) THEN
                OPEN(81,FILE='DumpA.dat',FORM='FORMATTED',STATUS='REPLACE',IOSTAT=info)
                DO i=1,n
                    WRITE(81,'(10E20.12)') A(i,:)
                ENDDO
                CLOSE(81)
            ENDIF

            !print the error message
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        DO k=1,n_eq
            CALL sgetrs('N',nnew,1,Anew,nnew,indxnew,bnew_n(:,k),nnew,info)
            IF (info .NE. 0) THEN
                WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
                CALL ppm_write(ppm_rank,caller,cbuf,info)
                info = -1
                GOTO 9999
            ENDIF
        ENDDO

        !====================================================================!
        ! sort solution (coefficients) into old places, remaining places are
        ! set to zero 
        jnew = 0
        DO j = 1,n
            x_or_b(j,1:n_eq) = 0._MK
        ENDDO
        DO j = 1,n

            IF (valid(j) .EQ. 1) THEN
                jnew = jnew + 1
                DO k=1,n_eq
                    x_or_b(roworder(j),k) = bnew_n(jnew,k)
                ENDDO
            ENDIF

        ENDDO

        DEALLOCATE(roworder)
        DEALLOCATE(indxnew)
        DEALLOCATE(bnew_n)
        DEALLOCATE(Anew)

    ELSE ! no singularities

        !====================================================================!
        ! solve originial LSE
        DO k=1,n_eq
            CALL sgetrs('N',n,1,Acopy,n,indx,x_or_b(:,k),n,info)
            IF (info .NE. 0) THEN
                WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
                CALL ppm_write(ppm_rank,caller,cbuf,info)
                info = -1
                GOTO 9999
            ENDIF
        ENDDO

    ENDIF

    !=======================================================================!
    ! check if equations were solved right (if you trust in LAPACK and this 
    ! code PUT THIS IN IF BRANCH FOR THE REDUCED SYSTEM)
    IF (check) THEN
        DO k=1,n_eq
            CALL sgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
                SIZE(A,1),x_or_b(:,k),1,0._MK,real_b,1)
            
            IF (SUM(ABS(real_b - exact_b_n(:,k))) .GT. tolerance_LSE) THEN
                WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
                CALL ppm_write(ppm_rank,caller,&
                    'Error in moment conditions 1 too large.',info)
                WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                    SUM(ABS(real_b - exact_b_n(:,k)))
                CALL ppm_write(ppm_rank,caller,cbuf,info)
                DO i=1,n
                    DO j=1,n
                        WRITE(9001,'(1(E30.22))') A(i,j)
                    ENDDO
                ENDDO
                CALL ppm_write(ppm_rank,caller,&
                    'moment matrix written in file fort.9001',info)
                info = -1
                GOTO 9999
            ENDIF
        ENDDO
    ENDIF

    !=======================================================================!
    ! dealloc
    DEALLOCATE(valid)
    DEALLOCATE(indx)
    DEALLOCATE(Acopy)
    IF (check) THEN
        DEALLOCATE(exact_b_n)
        DEALLOCATE(real_b)
    ENDIF

    9999 CONTINUE ! jump here upon error

END SUBROUTINE solveLSE_n_s

SUBROUTINE ppm_matrix_svd_s(Z,n,m,info,min_sv)
    USE ppm_module_write
    USE ppm_module_data, ONLY: ppm_rank

    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_single
    ! arguments
    REAL(MK),DIMENSION(:,:),          INTENT(IN   ) :: Z
    INTEGER,                          INTENT(IN   ) :: n
    INTEGER,                          INTENT(IN   ) :: m
    INTEGER,                          INTENT(  OUT) :: info

    ! optional argument
    REAL(MK),OPTIONAL,                INTENT(  OUT) :: min_sv
    ! local variables
    INTEGER                              :: j
    CHARACTER(LEN = ppm_char)            :: cbuf
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_matrix_svd'
    REAL(KIND(1.D0))                     :: t0

    REAL(MK), DIMENSION (:),   POINTER   :: offdiag=>NULL(), diag=>NULL()
    INTEGER                              :: lwork,mm,nnn
    REAL(MK), DIMENSION (:),   POINTER   :: work=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: tauq=>NULL(),taup=>NULL()
    REAL(MK), PARAMETER                  :: ppm_tolerance_svd = 1E-10


    mm = m
    nnn = n
    ALLOCATE(offdiag(nnn-1),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    ALLOCATE(diag(nnn),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    
    ALLOCATE(taup(mm,nnn),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    ALLOCATE(tauq(mm,nnn),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    lwork= -1
    ALLOCATE(work(1),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF

    !get the size for lwork
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'dgebrd failed on workspace query',info)
        info=-1
        GOTO 9999
    ENDIF

    lwork= work(1)
    DEALLOCATE(work)
    ALLOCATE(work(lwork),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF

    !decomposition
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'dgebrd failed',info)
        info=-1
        GOTO 9999
    ENDIF

    !get singular values
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'bdsqr failed',info)
        info=-1
        GOTO 9999
    ENDIF

    DEALLOCATE(taup)
    DEALLOCATE(tauq)
    DEALLOCATE(work)

    !!----------------------------------------------------------------------
    !! Raise an error if the singular value is below a threshold
    !!----------------------------------------------------------------------

    IF (MINVAL(diag) .LT. ppm_tolerance_svd) THEN
        WRITE(cbuf,'(A,E20.6)')'singular value. Min = ', MINVAL(diag)
        CALL ppm_write(ppm_rank,caller,cbuf, info)
        info = -1
        GOTO 9999
    ENDIF
    IF (PRESENT(min_sv)) min_sv=MINVAL(diag)
    
    9999 CONTINUE ! jump here upon error


END SUBROUTINE ppm_matrix_svd_s


!#if    1 == 1
!SUBROUTINE ppm_dcop_check_vandermonde_s(xp,ncoeff,npoints,info,min_sv)
!#elif  1 == 2
!SUBROUTINE ppm_dcop_check_vandermonde_d(xp,ncoeff,npoints,info,min_sv)
!#endif
    !USE ppm_module_write
    !USE ppm_module_data, ONLY: ppm_rank
!#ifdef __MKL
    !USE mkl95_lapack
    !USE mkl95_blas
!#endif

    !IMPLICIT NONE

!#if    1 == 1 
    !INTEGER, PARAMETER :: MK = ppm_kind_single
!#elif  1 == 2
    !INTEGER, PARAMETER :: MK = ppm_kind_double
!#endif
    !! arguments
    !REAL(MK),DIMENSION(:,:),          INTENT(IN   ) :: Z
    !INTEGER,                          INTENT(IN   ) :: ncoeff
    !INTEGER,                          INTENT(IN   ) :: npoints
    !INTEGER,                          INTENT(  OUT) :: info

    !! optional argument
    !REAL(MK),OPTIONAL,                INTENT(  OUT) :: min_sv
    !! local variables
    !INTEGER                               :: j
    !CHARACTER(LEN = ppm_char)             :: cbuf
    !CHARACTER(LEN = ppm_char)             :: caller = 'ppm_dcop_check_vandermonde'
    !REAL(KIND(1.D0))                      :: t0

    !REAL(MK), DIMENSION (:), POINTER      :: offdiag, diag
    !INTEGER                               :: lwork, mm,nnn
    !REAL(MK), DIMENSION (:), POINTER      :: work
    !REAL(MK), DIMENSION (:,:), POINTER    :: tauq,taup


    !mm = npoints
    !nnn = ncoeff
    !ALLOCATE(offdiag(nnn-1),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    !ALLOCATE(diag(nnn),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    
    !ALLOCATE(taup(mm,nnn),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    !ALLOCATE(tauq(mm,nnn),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    !lwork= -1
    !ALLOCATE(work(1),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !!get the size for lwork
!#ifdef __MKL
    !CALL dgebrd(mm,nnn,Z,mm,diag,offdiag,tauq,taup,work,lwork,info)
!#endif
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'dgebrd failed on workspace query',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !lwork= work(1)
    !DEALLOCATE(work)
    !ALLOCATE(work(lwork),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !!decomposition
!#ifdef __MKL
    !CALL dgebrd(mm,nnn,Z,mm,diag,offdiag,tauq,taup,work,lwork,info)
!#endif
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'dgebrd failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !!get singular values
    !CALL bdsqr(diag,offdiag)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'bdsqr failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !DEALLOCATE(taup)
    !DEALLOCATE(tauq)
    !DEALLOCATE(work)

    !!!----------------------------------------------------------------------
    !!! Raise an error if the singular value is below a threshold
    !!!----------------------------------------------------------------------

    !IF (MINVAL(diag) .LT. 0.001_mk) THEN
        !WRITE(cbuf,'(A,E20.6)')'singular value. Min = ', MINVAL(diag)
        !CALL ppm_write(ppm_rank,caller,cbuf, info)
        !info = -1
        !GOTO 9999
    !ENDIF
    !IF (PRESENT(min_sv)) min_sv=MINVAL(diag)
    
    !9999 CONTINUE ! jump here upon error


!#if    1 == 1
!END SUBROUTINE ppm_dcop_check_vandermonde_s
!#elif  1 == 2
!END SUBROUTINE ppm_dcop_check_vandermonde_d
!#endif
SUBROUTINE ppm_dcop_compute2d_s(Pc,op_id,info,c,min_sv)
    !!! Computes generalized DC operators
    !!! if the optional argument interp is true, the routine uses
    !!! one set of particles (Pc2) as input data and
    !!! compute the differential opearator on the new set
    !!! If it has to do be interpolating (if the quantity to be computed
    !!! is the field itself, ie. if the degree of one term of the 
    !!! differential operator is zero), then the nearest-neighbour 
    !!! distances within Pc2 must have been already computed.
    USE ppm_module_error
    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_single
    !---------------------------------------------------------
    ! arguments
    !---------------------------------------------------------
    CLASS(ppm_t_particles_s)                        :: Pc
    !!! particles
    INTEGER,                             INTENT(IN   )   :: op_id
    !!! id of the operator kernel
    INTEGER,                             INTENT(  OUT)   :: info
    !!! non-zero on output if some error occurred
    !---------------------------------------------------------
    ! Optional arguments
    !---------------------------------------------------------
    REAL(MK),                  OPTIONAL, INTENT(IN   )   :: c
    !!! ratio h/epsilon
    REAL(MK),                  OPTIONAL, INTENT(  OUT)   :: min_sv
    !!! if present, compute the singular value decomposition of the 
    !!! vandermonde matrix for each operator and return the smallest one

    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    INTEGER                               :: i,j,k,ip,iq,beta(ppm_dim),ineigh
    INTEGER                               :: ncoeff,n_odd,np_target
    CHARACTER(LEN = 256)                  :: caller='ppm_dcop_compute'
    CHARACTER(LEN = 256)                  :: cbuf
    CHARACTER(LEN = 32)                   :: myformat
    REAL(KIND(1.D0))                      :: t0
    REAL(MK)                              :: expo,byh
    REAL(MK),DIMENSION(:),ALLOCATABLE     :: byh0powerbeta
    REAL(MK)                              :: sv,dist2
    REAL(MK)                              :: nn_scaled
    REAL(MK), DIMENSION(:,:),POINTER      :: b=>NULL(),b_0=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z_copy=>NULL()
    REAL(MK),DIMENSION(:)  ,ALLOCATABLE   :: d2_one2all
    REAL(MK),DIMENSION(:,:),ALLOCATABLE   :: dx
    INTEGER, DIMENSION(:,:),ALLOCATABLE   :: alpha,gamma
    INTEGER                               :: order_a
    INTEGER,DIMENSION(ppm_dim)            :: degree
    INTEGER,DIMENSION(:),ALLOCATABLE      :: sum_degree
    REAL(MK),DIMENSION(:),POINTER         :: coeffs=>NULL()
    INTEGER,DIMENSION(3)                  :: ldc
    INTEGER                               :: degree_poly
    LOGICAL                               :: cartesian,isinterp,adaptive,vector
    LOGICAL                               :: with_ghosts

    REAL(MK), DIMENSION(:,:),  POINTER    :: xp1=>NULL()
    !!! particles (or points) where the operators are computed
    REAL(MK), DIMENSION(:,:),  POINTER    :: xp2=>NULL()
    !!! particles that contain the data to be used (xp1 can be equal to xp2) 
    !!! A case where xp1 .ne. xp2 is for interpolation.
    REAL(MK), DIMENSION(:),  POINTER      :: rcp=>NULL()
    REAL(MK), DIMENSION(:),  POINTER      :: nn_sq=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: eta=>NULL()
    INTEGER, DIMENSION(:),   POINTER      :: nvlist=>NULL()
    INTEGER, DIMENSION(:,:), POINTER      :: vlist=>NULL()
    INTEGER                               :: nterms
    !!! number of terms of the differential operator
    REAL(MK)                              :: c_value
    REAL(MK)                              :: min_sv_p

    TYPE(ppm_t_sop_s),POINTER  :: Pc2 => NULL()
    TYPE(ppm_t_operator_s),POINTER   :: op  => NULL()
    TYPE(ppm_t_neighlist_s),POINTER  :: Nlist => NULL()

    !!---------------------------------------------------------------------!
    !! Initialize
    !!---------------------------------------------------------------------!
    info = 0 ! change if error occurs
    CALL substart(caller,t0,info)

    IF (PRESENT(c)) THEN
        c_value=c
    ELSE
        c_value=1._MK
    ENDIF

    op => Pc%ops%vec(op_id)%t

    isinterp = op%flags(ppm_ops_interp)
    vector = op%flags(ppm_ops_vector)
    !if true, then each term of the differential opearator is stored as one
    !component in eta. This is used when computing e.g. the gradient opearator.
    !if false, the same input parameters would yield an operator approximating
    ! the divergence operator.
    with_ghosts = op%flags(ppm_ops_inc_ghosts)
    !if true, then the operator should be computed for ghost particles too. 
    !Note that the resulting values will be wrong for the ghost particles
    !that have some neighbours outside the ghost layers. Some of these particles
    !may also not have enough neighbours for the Vandermonde matrix to be
    !invertible. These particles will be skipped without raising a warning.


    Nlist => Pc%neighs%vec(op%neigh_id)%t
    IF (.NOT. Nlist%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Need to specify which set of particles &
            &   (Pc2) should be used for interpolation',&
            & 117,info)
        GOTO 9999
    ENDIF

    nterms = op%desc%nterms
    ALLOCATE(sum_degree(nterms),byh0powerbeta(nterms))

    cartesian=Pc%flags(ppm_part_cartesian)
    IF (cartesian .AND. nterms .GT. 1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Case where nterms>1 is not yet implemented for Cartesian particles',&
            129,info)
        GOTO 9999
    ENDIF

    !IF (Pc%adaptive) THEN
        !adaptive = .TRUE.
    !ELSE
        !adaptive = .FALSE.
    !ENDIF

    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_s)
        CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=with_ghosts)
        adaptive = .TRUE.
        IF (isinterp) THEN
            Pc2 => Pc%set_aPc%vec(op%P_id)%t
        ENDIF

        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%get(nn_sq,Pc2%nn_sq_id,with_ghosts=.TRUE.)
            !!! nearest-neighbour distances within Pc2 
            !!! (they must have been already computed)
        ENDIF
    CLASS DEFAULT
        byh = 1._MK/Pc%h_avg
        adaptive = .FALSE.
    END SELECT


    IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
        IF (Pc2%nn_sq_id .EQ. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                & 'need to call particles_nearest_neighbors first',162,info)
            GOTO 9999
        ENDIF
    ENDIF


    !Determine number of coefficients needed for this operator
    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        sum_degree(i) = SUM(degree)
        order_a=op%desc%order(i)

        degree_poly = sum_degree(i) + order_a - 1

        IF (degree_poly .LT. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                'Negative degree for polynomial basis',179,info)
            GOTO 9999
        ENDIF

        IF (cartesian) THEN
            n_odd = 0
            DO j = 1,ppm_dim
                n_odd = n_odd + MOD(degree(j),2)
            ENDDO
            ncoeff = binomial((sum_degree(i)-n_odd)/2 + &
                CEILING(order_a/2.0) -1 + ppm_dim,ppm_dim) 
        ELSE 
            ncoeff = binomial(degree_poly+ppm_dim,ppm_dim)
        ENDIF

        !write(*,*) 'degree: ',degree, sum_degree(i)
        !write(*,*) 'degree_poly: ',degree_poly, ncoeff
    ENDDO

    IF (ncoeff.LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Could not compute number of coefficients',201,info)
        GOTO 9999
    ENDIF

    ALLOCATE(gamma(ppm_dim,ncoeff),alpha(ppm_dim,ncoeff),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',208,info)
        GOTO 9999
    ENDIF ! Generate the polynomial basis for particle approximation
    !   alpha is the approximation basis
    !   gamma is the template for DC operators
    ip = 0
    alpha = 0 

    DO i=0,degree_poly

        loopj: DO j=0,i
            !if cartesian, it is not needed to compute coefficients 
            !for which gamma+order_d contains odd elements
            IF (cartesian) THEN 
                IF (MOD(j+degree(1),2)  .NE.0) CYCLE loopj
                IF (MOD(i-j+degree(2),2).NE.0) CYCLE loopj
            ENDIF
            ip=ip+1
            alpha(1,ip) = j
            alpha(2,ip) = i-j
        ENDDO loopj
    ENDDO

    IF (ip.NE.ncoeff) THEN
        WRITE(cbuf,*) 'Something wrong when computing coefficients. Theory: ',&
            ncoeff,', we have ',ip
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    ncoeff = ip
    gamma = alpha

    IF (Nlist%nneighmin .LT. ncoeff) THEN
        CALL ppm_write(ppm_rank,caller,'Not enough neighbours',info)
        WRITE(cbuf,*) 'For this DC-operator, we need ',&
            ncoeff,' neighbours. We have ',Nlist%nneighmin
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF


    ALLOCATE(d2_one2all(Nlist%nneighmax),dx(ppm_dim,Nlist%nneighmax),&
        Z(ncoeff,ncoeff),b(ncoeff,nterms),b_0(ncoeff,nterms),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',275,info)
        GOTO 9999
    ENDIF

    !only used to compute the SVD, mainly for debugging.
    IF(PRESENT(min_sv)) THEN
        min_sv = HUGE(1._MK)
        ALLOCATE(Z_copy(ncoeff,ncoeff))
    ENDIF

    IF (vector) THEN
        ldc(1) = Nlist%nneighmax*nterms; 
    ELSE
        ldc(1) = Nlist%nneighmax; 
    ENDIF
    IF (with_ghosts) THEN
        np_target = Pc%Mpart
    ELSE
        np_target = Pc%Npart
    ENDIF
    ldc(2) = np_target
    CALL ppm_alloc(op%ker,ldc,ppm_param_alloc_grow,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',299,info)
        GOTO 9999
    ENDIF
    eta => Pc%get_dcop(op_id,with_ghosts=with_ghosts)
    FORALL(i=1:ldc(1),j=1:np_target) eta(i,j)=0._MK

    !----------------------------------------------------------------------!
    ! Compute diff op weights
    !----------------------------------------------------------------------!
    b_0 = 0._MK

    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        DO j=1,ncoeff
            IF (MAXVAL(ABS(alpha(:,j)-degree)).EQ.0) THEN
                b_0(j,i)=(-1)**(sum_degree(i))*factorial_m(degree,ppm_dim)
            ENDIF
        ENDDO

        !When applicable, and for stability reasons, set the zeroth moment to 5
        IF (.NOT.isinterp) THEN
            IF (SUM(alpha(1:ppm_dim,1)).EQ. 0 .AND. MOD(sum_degree(i),2) .EQ.0)&
                b_0(1,i) = 5._MK
        ENDIF
    ENDDO
    
    IF (isinterp) THEN
        CALL Pc%get_xp(xp1,with_ghosts=with_ghosts)
        CALL Pc2%get_xp(xp2,with_ghosts=.TRUE.)
    ELSE
        CALL Pc%get_xp(xp1,with_ghosts=.TRUE.)
        xp2 => xp1
    ENDIF
    nvlist => Nlist%nvlist
    vlist => Nlist%vlist
    coeffs => op%desc%coeffs(1:nterms)

    particle_loop: DO ip = 1,np_target ! loop over all target particles

        IF (ip .GT. Pc%Npart .AND. nvlist(ip).LT.ncoeff) THEN
            !not enough neigbours for this ghost particle - skip it
            CYCLE particle_loop
        ENDIF

        Z = 0._MK
        b = b_0
        ! loop over their neighbors
        IF (adaptive) THEN
            !byh = 2._MK/rcp(ip)
            byh = 0.5_MK/rcp(ip)
        ENDIF


        neighbour_loop: DO ineigh = 1,nvlist(ip) 
            iq = vlist(ineigh,ip) ! index in the "old particles" set

            ! distance squared between the new particle and the old ones
            dx(1:ppm_dim,ineigh) = (xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))*byh
            d2_one2all(ineigh) = SUM(dx(1:ppm_dim,ineigh)**2)

            expo = exp(-c_value**2*d2_one2all(ineigh))

            ! Fill matrix Z
            ! moments in alpha order: (alphas = rows)
            ! coefficients in gamma order (gammas = cols):

            DO j=1,ncoeff
                DO i=1,ncoeff
                    beta = alpha(1:ppm_dim,i) + gamma(1:ppm_dim,j)

                    Z(i,j) = Z(i,j) + &
                        dx(1,ineigh)**beta(1) * &
                        dx(2,ineigh)**beta(2) * expo
                ENDDO
            ENDDO

        ENDDO neighbour_loop

        IF (isinterp) THEN
            DO i=1,nterms
                IF (sum_degree(i).NE.0) CYCLE
                ! Assemble the rhs for the linear system that has to be solved for 
                ! interpolating functions
                DO ineigh = 1,nvlist(ip)
                    !rescaled nearest-neighbour distance  
                    iq = vlist(ineigh,ip)
                    dist2 = SUM((xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))**2)
                    eta(ineigh,ip) = &
                        primitive_s(SQRT(dist2/nn_sq(iq)) / 0.9_MK)

                    !reuse the variable to assemble the rhs
                    DO j=1,ncoeff
                        b(j,i) = b(j,i) - &
                            eta(ineigh,ip)* &
                            dx(1,ineigh)**alpha(1,j) * dx(2,ineigh)**alpha(2,j)
                    ENDDO
                ENDDO
            ENDDO
        ENDIF


        CALL solveLSE_n_s(Z,b,nterms,info)
        ! now b contain the solutions to the LSEs A*x_i=b_i for i=1:nterms
        IF (info .NE. 0) THEN
            IF (ip .GT. Pc%Npart) THEN
                !ignore error in matrix inversion for ghost particles
                ! simply skip it
                CYCLE particle_loop
            ENDIF
            !writes the coordinate of the stencil that lead to the error
            IF (ppm_dim .EQ. 2 ) THEN
                myformat = TRIM(ADJUSTL('(2(E30.22))'))
            ELSE
                myformat = TRIM(ADJUSTL('(3(E30.22))'))
            ENDIF
            WRITE(9000,myformat) xp1(1:ppm_dim,ip)
            DO ineigh = 1,nvlist(ip)
                WRITE(9000,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'stencil written in file fort.9000',info)

            WRITE(9003,myformat) xp1(1:ppm_dim,ip)*byh
            DO ineigh = 1,nvlist(ip)
                WRITE(9003,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))*byh
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'h-scaled stencil written in file fort.9003',info)
            info = ppm_error_error
            CALL ppm_error(ppm_err_sub_failed,caller,&
                'Failed to solve the LSE', 472,info)
            GOTO 9999
        ENDIF

        DO i=1,nterms 
            byh0powerbeta(i) = byh**(sum_degree(i))
        ENDDO


        !------------------------------------------------------------------!
        ! Compute the operators
        !------------------------------------------------------------------!
        ! loop over old particles
        IF (isinterp) THEN
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo
                    ELSE
                        eta(ineigh,ip) = eta(ineigh,ip) + &
                            SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo

                            !note: do not factorise out expo, like for eta. 
                            ! eta_interp already contains some data (the primitive &
                            ! function) that should not be multiplied by expo.
                    ENDIF
                ENDDO
            ENDDO
        ELSE
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ELSE

                    eta(ineigh,ip) = eta(ineigh,ip) +&
                        SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ENDIF
                ENDDO
                IF (vector) THEN
                    eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) * expo
                ELSE
                    eta(ineigh,ip) = eta(ineigh,ip) * expo
                ENDIF
            ENDDO
        ENDIF

    ENDDO particle_loop

    coeffs=> NULL()
    CALL Pc%set_xp(xp1,read_only=.TRUE.)
    IF (isinterp) THEN
        CALL Pc2%set_xp(xp2,read_only=.TRUE.)
    ELSE
        xp2 => NULL()
    ENDIF
    eta => Pc%set_dcop(op_id)

    SELECT TYPE (Pc)
    TYPE IS (ppm_t_sop_s)
        CALL Pc%set(rcp,Pc%rcp_id,read_only=.TRUE.)
        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%set(nn_sq,Pc2%nn_sq_id,read_only=.TRUE.)
        ENDIF
    END SELECT

    !!---------------------------------------------------------------------!
    !! Finalize
    !!---------------------------------------------------------------------!
    DEALLOCATE(Z,b,b_0,d2_one2all,dx,gamma,alpha,sum_degree,byh0powerbeta)

    IF(PRESENT(min_sv)) THEN
        DEALLOCATE(Z_copy)
    ENDIF

    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE ppm_dcop_compute2d_s

SUBROUTINE ppm_dcop_compute3d_s(Pc,op_id,info,c,min_sv)
    !!! Computes generalized DC operators
    !!! if the optional argument interp is true, the routine uses
    !!! one set of particles (Pc2) as input data and
    !!! compute the differential opearator on the new set
    !!! If it has to do be interpolating (if the quantity to be computed
    !!! is the field itself, ie. if the degree of one term of the 
    !!! differential operator is zero), then the nearest-neighbour 
    !!! distances within Pc2 must have been already computed.
    USE ppm_module_error
    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_single
    !---------------------------------------------------------
    ! arguments
    !---------------------------------------------------------
    CLASS(ppm_t_particles_s)                        :: Pc
    !!! particles
    INTEGER,                             INTENT(IN   )   :: op_id
    !!! id of the operator kernel
    INTEGER,                             INTENT(  OUT)   :: info
    !!! non-zero on output if some error occurred
    !---------------------------------------------------------
    ! Optional arguments
    !---------------------------------------------------------
    REAL(MK),                  OPTIONAL, INTENT(IN   )   :: c
    !!! ratio h/epsilon
    REAL(MK),                  OPTIONAL, INTENT(  OUT)   :: min_sv
    !!! if present, compute the singular value decomposition of the 
    !!! vandermonde matrix for each operator and return the smallest one

    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    INTEGER                               :: i,j,k,ip,iq,beta(ppm_dim),ineigh
    INTEGER                               :: ncoeff,n_odd,np_target
    CHARACTER(LEN = 256)                  :: caller='ppm_dcop_compute'
    CHARACTER(LEN = 256)                  :: cbuf
    CHARACTER(LEN = 32)                   :: myformat
    REAL(KIND(1.D0))                      :: t0
    REAL(MK)                              :: expo,byh
    REAL(MK),DIMENSION(:),ALLOCATABLE     :: byh0powerbeta
    REAL(MK)                              :: sv,dist2
    REAL(MK)                              :: nn_scaled
    REAL(MK), DIMENSION(:,:),POINTER      :: b=>NULL(),b_0=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z_copy=>NULL()
    REAL(MK),DIMENSION(:)  ,ALLOCATABLE   :: d2_one2all
    REAL(MK),DIMENSION(:,:),ALLOCATABLE   :: dx
    INTEGER, DIMENSION(:,:),ALLOCATABLE   :: alpha,gamma
    INTEGER                               :: order_a
    INTEGER,DIMENSION(ppm_dim)            :: degree
    INTEGER,DIMENSION(:),ALLOCATABLE      :: sum_degree
    REAL(MK),DIMENSION(:),POINTER         :: coeffs=>NULL()
    INTEGER,DIMENSION(3)                  :: ldc
    INTEGER                               :: degree_poly
    LOGICAL                               :: cartesian,isinterp,adaptive,vector
    LOGICAL                               :: with_ghosts

    REAL(MK), DIMENSION(:,:),  POINTER    :: xp1=>NULL()
    !!! particles (or points) where the operators are computed
    REAL(MK), DIMENSION(:,:),  POINTER    :: xp2=>NULL()
    !!! particles that contain the data to be used (xp1 can be equal to xp2) 
    !!! A case where xp1 .ne. xp2 is for interpolation.
    REAL(MK), DIMENSION(:),  POINTER      :: rcp=>NULL()
    REAL(MK), DIMENSION(:),  POINTER      :: nn_sq=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: eta=>NULL()
    INTEGER, DIMENSION(:),   POINTER      :: nvlist=>NULL()
    INTEGER, DIMENSION(:,:), POINTER      :: vlist=>NULL()
    INTEGER                               :: nterms
    !!! number of terms of the differential operator
    REAL(MK)                              :: c_value
    REAL(MK)                              :: min_sv_p

    TYPE(ppm_t_sop_s),POINTER  :: Pc2 => NULL()
    TYPE(ppm_t_operator_s),POINTER   :: op  => NULL()
    TYPE(ppm_t_neighlist_s),POINTER  :: Nlist => NULL()

    !!---------------------------------------------------------------------!
    !! Initialize
    !!---------------------------------------------------------------------!
    info = 0 ! change if error occurs
    CALL substart(caller,t0,info)

    IF (PRESENT(c)) THEN
        c_value=c
    ELSE
        c_value=1._MK
    ENDIF

    op => Pc%ops%vec(op_id)%t

    isinterp = op%flags(ppm_ops_interp)
    vector = op%flags(ppm_ops_vector)
    !if true, then each term of the differential opearator is stored as one
    !component in eta. This is used when computing e.g. the gradient opearator.
    !if false, the same input parameters would yield an operator approximating
    ! the divergence operator.
    with_ghosts = op%flags(ppm_ops_inc_ghosts)
    !if true, then the operator should be computed for ghost particles too. 
    !Note that the resulting values will be wrong for the ghost particles
    !that have some neighbours outside the ghost layers. Some of these particles
    !may also not have enough neighbours for the Vandermonde matrix to be
    !invertible. These particles will be skipped without raising a warning.


    Nlist => Pc%neighs%vec(op%neigh_id)%t
    IF (.NOT. Nlist%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Need to specify which set of particles &
            &   (Pc2) should be used for interpolation',&
            & 117,info)
        GOTO 9999
    ENDIF

    nterms = op%desc%nterms
    ALLOCATE(sum_degree(nterms),byh0powerbeta(nterms))

    cartesian=Pc%flags(ppm_part_cartesian)
    IF (cartesian .AND. nterms .GT. 1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Case where nterms>1 is not yet implemented for Cartesian particles',&
            129,info)
        GOTO 9999
    ENDIF

    !IF (Pc%adaptive) THEN
        !adaptive = .TRUE.
    !ELSE
        !adaptive = .FALSE.
    !ENDIF

    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_s)
        CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=with_ghosts)
        adaptive = .TRUE.
        IF (isinterp) THEN
            Pc2 => Pc%set_aPc%vec(op%P_id)%t
        ENDIF

        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%get(nn_sq,Pc2%nn_sq_id,with_ghosts=.TRUE.)
            !!! nearest-neighbour distances within Pc2 
            !!! (they must have been already computed)
        ENDIF
    CLASS DEFAULT
        byh = 1._MK/Pc%h_avg
        adaptive = .FALSE.
    END SELECT


    IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
        IF (Pc2%nn_sq_id .EQ. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                & 'need to call particles_nearest_neighbors first',162,info)
            GOTO 9999
        ENDIF
    ENDIF


    !Determine number of coefficients needed for this operator
    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        sum_degree(i) = SUM(degree)
        order_a=op%desc%order(i)

        degree_poly = sum_degree(i) + order_a - 1

        IF (degree_poly .LT. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                'Negative degree for polynomial basis',179,info)
            GOTO 9999
        ENDIF

        IF (cartesian) THEN
            n_odd = 0
            DO j = 1,ppm_dim
                n_odd = n_odd + MOD(degree(j),2)
            ENDDO
            ncoeff = binomial((sum_degree(i)-n_odd)/2 + &
                CEILING(order_a/2.0) -1 + ppm_dim,ppm_dim) 
        ELSE 
            ncoeff = binomial(degree_poly+ppm_dim,ppm_dim)
        ENDIF

        !write(*,*) 'degree: ',degree, sum_degree(i)
        !write(*,*) 'degree_poly: ',degree_poly, ncoeff
    ENDDO

    IF (ncoeff.LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Could not compute number of coefficients',201,info)
        GOTO 9999
    ENDIF

    ALLOCATE(gamma(ppm_dim,ncoeff),alpha(ppm_dim,ncoeff),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',208,info)
        GOTO 9999
    ENDIF ! Generate the polynomial basis for particle approximation
    !   alpha is the approximation basis
    !   gamma is the template for DC operators
    ip = 0
    alpha = 0 

    DO i=0,degree_poly

        DO j=0,i
            loopk: DO k=0,i-j
                !if cartesian, it is not needed to compute coefficients 
                !for which gamma+order_d contains odd elements
                IF (cartesian) THEN
                    IF (MOD(j+degree(1),2)    .NE.0) CYCLE loopk
                    IF (MOD(k+degree(2),2)    .NE.0) CYCLE loopk
                    IF (MOD(i-j-k+degree(3),2).NE.0) CYCLE loopk
                ENDIF

                ip=ip+1
                alpha(1,ip) = j
                alpha(2,ip) = k
                alpha(3,ip) = i-j-k
            ENDDO loopk
        ENDDO
    ENDDO

    IF (ip.NE.ncoeff) THEN
        WRITE(cbuf,*) 'Something wrong when computing coefficients. Theory: ',&
            ncoeff,', we have ',ip
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    ncoeff = ip
    gamma = alpha

    IF (Nlist%nneighmin .LT. ncoeff) THEN
        CALL ppm_write(ppm_rank,caller,'Not enough neighbours',info)
        WRITE(cbuf,*) 'For this DC-operator, we need ',&
            ncoeff,' neighbours. We have ',Nlist%nneighmin
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF


    ALLOCATE(d2_one2all(Nlist%nneighmax),dx(ppm_dim,Nlist%nneighmax),&
        Z(ncoeff,ncoeff),b(ncoeff,nterms),b_0(ncoeff,nterms),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',275,info)
        GOTO 9999
    ENDIF

    !only used to compute the SVD, mainly for debugging.
    IF(PRESENT(min_sv)) THEN
        min_sv = HUGE(1._MK)
        ALLOCATE(Z_copy(ncoeff,ncoeff))
    ENDIF

    IF (vector) THEN
        ldc(1) = Nlist%nneighmax*nterms; 
    ELSE
        ldc(1) = Nlist%nneighmax; 
    ENDIF
    IF (with_ghosts) THEN
        np_target = Pc%Mpart
    ELSE
        np_target = Pc%Npart
    ENDIF
    ldc(2) = np_target
    CALL ppm_alloc(op%ker,ldc,ppm_param_alloc_grow,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',299,info)
        GOTO 9999
    ENDIF
    eta => Pc%get_dcop(op_id,with_ghosts=with_ghosts)
    FORALL(i=1:ldc(1),j=1:np_target) eta(i,j)=0._MK

    !----------------------------------------------------------------------!
    ! Compute diff op weights
    !----------------------------------------------------------------------!
    b_0 = 0._MK

    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        DO j=1,ncoeff
            IF (MAXVAL(ABS(alpha(:,j)-degree)).EQ.0) THEN
                b_0(j,i)=(-1)**(sum_degree(i))*factorial_m(degree,ppm_dim)
            ENDIF
        ENDDO

        !When applicable, and for stability reasons, set the zeroth moment to 5
        IF (.NOT.isinterp) THEN
            IF (SUM(alpha(1:ppm_dim,1)).EQ. 0 .AND. MOD(sum_degree(i),2) .EQ.0)&
                b_0(1,i) = 5._MK
        ENDIF
    ENDDO
    
    IF (isinterp) THEN
        CALL Pc%get_xp(xp1,with_ghosts=with_ghosts)
        CALL Pc2%get_xp(xp2,with_ghosts=.TRUE.)
    ELSE
        CALL Pc%get_xp(xp1,with_ghosts=.TRUE.)
        xp2 => xp1
    ENDIF
    nvlist => Nlist%nvlist
    vlist => Nlist%vlist
    coeffs => op%desc%coeffs(1:nterms)

    particle_loop: DO ip = 1,np_target ! loop over all target particles

        IF (ip .GT. Pc%Npart .AND. nvlist(ip).LT.ncoeff) THEN
            !not enough neigbours for this ghost particle - skip it
            CYCLE particle_loop
        ENDIF

        Z = 0._MK
        b = b_0
        ! loop over their neighbors
        IF (adaptive) THEN
            !byh = 2._MK/rcp(ip)
            byh = 0.5_MK/rcp(ip)
        ENDIF


        neighbour_loop: DO ineigh = 1,nvlist(ip) 
            iq = vlist(ineigh,ip) ! index in the "old particles" set

            ! distance squared between the new particle and the old ones
            dx(1:ppm_dim,ineigh) = (xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))*byh
            d2_one2all(ineigh) = SUM(dx(1:ppm_dim,ineigh)**2)

            expo = exp(-c_value**2*d2_one2all(ineigh))

            ! Fill matrix Z
            ! moments in alpha order: (alphas = rows)
            ! coefficients in gamma order (gammas = cols):

            DO j=1,ncoeff
                DO i=1,ncoeff
                    beta = alpha(1:ppm_dim,i) + gamma(1:ppm_dim,j)

                    Z(i,j) = Z(i,j) + &
                        dx(1,ineigh)**beta(1) * &
                        dx(3,ineigh)**beta(3) * &
                        dx(2,ineigh)**beta(2) * expo
                ENDDO
            ENDDO

        ENDDO neighbour_loop

        IF (isinterp) THEN
            DO i=1,nterms
                IF (sum_degree(i).NE.0) CYCLE
                ! Assemble the rhs for the linear system that has to be solved for 
                ! interpolating functions
                DO ineigh = 1,nvlist(ip)
                    !rescaled nearest-neighbour distance  
                    iq = vlist(ineigh,ip)
                    dist2 = SUM((xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))**2)
                    eta(ineigh,ip) = &
                        primitive_s(SQRT(dist2/nn_sq(iq)) / 0.9_MK)

                    !reuse the variable to assemble the rhs
                    DO j=1,ncoeff
                        b(j,i) = b(j,i) - &
                            eta(ineigh,ip)* &
                            dx(1,ineigh)**alpha(1,j) * dx(2,ineigh)**alpha(2,j) * &
                                dx(3,ineigh)**alpha(3,j)
                    ENDDO
                ENDDO
            ENDDO
        ENDIF


        CALL solveLSE_n_s(Z,b,nterms,info)
        ! now b contain the solutions to the LSEs A*x_i=b_i for i=1:nterms
        IF (info .NE. 0) THEN
            IF (ip .GT. Pc%Npart) THEN
                !ignore error in matrix inversion for ghost particles
                ! simply skip it
                CYCLE particle_loop
            ENDIF
            !writes the coordinate of the stencil that lead to the error
            IF (ppm_dim .EQ. 2 ) THEN
                myformat = TRIM(ADJUSTL('(2(E30.22))'))
            ELSE
                myformat = TRIM(ADJUSTL('(3(E30.22))'))
            ENDIF
            WRITE(9000,myformat) xp1(1:ppm_dim,ip)
            DO ineigh = 1,nvlist(ip)
                WRITE(9000,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'stencil written in file fort.9000',info)

            WRITE(9003,myformat) xp1(1:ppm_dim,ip)*byh
            DO ineigh = 1,nvlist(ip)
                WRITE(9003,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))*byh
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'h-scaled stencil written in file fort.9003',info)
            info = ppm_error_error
            CALL ppm_error(ppm_err_sub_failed,caller,&
                'Failed to solve the LSE', 472,info)
            GOTO 9999
        ENDIF

        DO i=1,nterms 
            byh0powerbeta(i) = byh**(sum_degree(i))
        ENDDO


        !------------------------------------------------------------------!
        ! Compute the operators
        !------------------------------------------------------------------!
        ! loop over old particles
        IF (isinterp) THEN
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(3,ineigh)**gamma(3,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo
                    ELSE
                        eta(ineigh,ip) = eta(ineigh,ip) + &
                            SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(3,ineigh)**gamma(3,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo

                            !note: do not factorise out expo, like for eta. 
                            ! eta_interp already contains some data (the primitive &
                            ! function) that should not be multiplied by expo.
                    ENDIF
                ENDDO
            ENDDO
        ELSE
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(3,ineigh)**gamma(3,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ELSE

                    eta(ineigh,ip) = eta(ineigh,ip) +&
                        SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(3,ineigh)**gamma(3,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ENDIF
                ENDDO
                IF (vector) THEN
                    eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) * expo
                ELSE
                    eta(ineigh,ip) = eta(ineigh,ip) * expo
                ENDIF
            ENDDO
        ENDIF

    ENDDO particle_loop

    coeffs=> NULL()
    CALL Pc%set_xp(xp1,read_only=.TRUE.)
    IF (isinterp) THEN
        CALL Pc2%set_xp(xp2,read_only=.TRUE.)
    ELSE
        xp2 => NULL()
    ENDIF
    eta => Pc%set_dcop(op_id)

    SELECT TYPE (Pc)
    TYPE IS (ppm_t_sop_s)
        CALL Pc%set(rcp,Pc%rcp_id,read_only=.TRUE.)
        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%set(nn_sq,Pc2%nn_sq_id,read_only=.TRUE.)
        ENDIF
    END SELECT

    !!---------------------------------------------------------------------!
    !! Finalize
    !!---------------------------------------------------------------------!
    DEALLOCATE(Z,b,b_0,d2_one2all,dx,gamma,alpha,sum_degree,byh0powerbeta)

    IF(PRESENT(min_sv)) THEN
        DEALLOCATE(Z_copy)
    ENDIF

    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE ppm_dcop_compute3d_s


!BEGIN
FUNCTION begin_op_s(this) RESULT (iterator)
    CLASS(ppm_c_operators_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_s),   POINTER      :: iterator

    this%iter_id = this%min_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%min_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION begin_op_s

FUNCTION begin_neigh_s(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_s),   POINTER      :: iterator

    this%iter_id = this%min_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%min_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION begin_neigh_s

FUNCTION begin_prop_s(this) RESULT (iterator)
    CLASS(ppm_c_props_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_s),POINTER   :: iterator

    this%iter_id = this%min_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%min_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION begin_prop_s

!LAST
FUNCTION last_op_s(this) RESULT (iterator)
    CLASS(ppm_c_operators_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_s),   POINTER      :: iterator

    this%iter_id = this%max_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%max_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION last_op_s

FUNCTION last_neigh_s(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_s),   POINTER      :: iterator

    this%iter_id = this%max_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%max_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION last_neigh_s

FUNCTION last_prop_s(this) RESULT (iterator)
    CLASS(ppm_c_props_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_s),POINTER   :: iterator

    this%iter_id = this%max_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%max_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION last_prop_s


!NEXT
FUNCTION next_op_s(this) RESULT (iterator)
    CLASS(ppm_c_operators_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_s),   POINTER      :: iterator

    DO WHILE(this%iter_id.LT.this%max_id)
        this%iter_id = this%iter_id + 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN
       
END FUNCTION next_op_s

FUNCTION next_neigh_s(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_s),  INTENT(INOUT):: this
    TYPE(ppm_t_neighlist_s),   POINTER      :: iterator

    DO WHILE(this%iter_id.LT.this%max_id)
        this%iter_id = this%iter_id + 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION next_neigh_s

FUNCTION next_prop_s(this) RESULT (iterator)
    CLASS(ppm_c_props_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_s),POINTER   :: iterator

    DO WHILE(this%iter_id.LT.this%max_id)
        this%iter_id = this%iter_id + 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION next_prop_s


!PREVIOUS
FUNCTION prev_op_s(this) RESULT (iterator)
    CLASS(ppm_c_operators_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_s),   POINTER      :: iterator

    DO WHILE(this%iter_id.GT.this%min_id)
        this%iter_id = this%iter_id - 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN
       
END FUNCTION prev_op_s

FUNCTION prev_neigh_s(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_s),  INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_s),   POINTER      :: iterator

    DO WHILE(this%iter_id.GT.this%min_id)
        this%iter_id = this%iter_id - 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION prev_neigh_s

FUNCTION prev_prop_s(this) RESULT (iterator)
    CLASS(ppm_c_props_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_s),POINTER   :: iterator

    DO WHILE(this%iter_id.GT.this%min_id)
        this%iter_id = this%iter_id - 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION prev_prop_s

! Destructors
SUBROUTINE op_container_destroy_s(this,info)
    CLASS(ppm_c_operators_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_s),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    info = 0
    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec)
    NULLIFY(this%vec)
    this%min_id = HUGE(1)
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

END SUBROUTINE op_container_destroy_s

SUBROUTINE neigh_container_destroy_s(this,info)
    CLASS(ppm_c_neighlists_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_s),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    info = 0
    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec)
    NULLIFY(this%vec)
    this%min_id = HUGE(1)
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

END SUBROUTINE neigh_container_destroy_s

SUBROUTINE prop_container_destroy_s(this,info)
    CLASS(ppm_c_props_s), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_s),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    info = 0
    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec)
    NULLIFY(this%vec)
    this%min_id = HUGE(1)
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

END SUBROUTINE prop_container_destroy_s
SUBROUTINE get_vlist_s(Pc,nvlist,vlist,nlid)
    !!! returns pointers to the arrays nvlist and vlist
    !!! that contain the Verlet lists for the neighbour list
    !!! of ID nlid.
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,DIMENSION(:),        POINTER  :: nvlist
    !!! number of neighbours for each particle
    INTEGER,DIMENSION(:,:),      POINTER  :: vlist
    !!! verlet list
    INTEGER                               :: nlid
    !!! id of the neighbour list 
    INTEGER                               :: info


    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    CHARACTER(LEN = ppm_char)             :: caller = 'get_vlist'

    
    nvlist => NULL()
    vlist => NULL()

    IF (.NOT.Pc%neighs%exists(nlid)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour list is invalid or not allocated',&
            &  28,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%neighs%vec(nlid)%t%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour lists have not been computed',&
            &  36,info)
        GOTO 9999
    ENDIF

    nvlist => Pc%neighs%vec(nlid)%t%nvlist
    vlist => Pc%neighs%vec(nlid)%t%vlist


    9999 CONTINUE

END SUBROUTINE get_vlist_s

SUBROUTINE get_nvlist_s(Pc,nvlist,nlid)
    !!! returns a pointer to the array of nb of neighbors
    !!! for the neighbour list of id nlID
    CLASS(ppm_t_particles_s)         :: Pc
    INTEGER,DIMENSION(:),        POINTER  :: nvlist
    !!! number of neighbours for each particle
    INTEGER                               :: nlid
    !!! id of the neighbour list 
    INTEGER                               :: info

    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    CHARACTER(LEN = ppm_char)             :: caller = 'get_nvlist'
    
    nvlist => NULL()

    IF (.NOT.Pc%neighs%exists(nlid)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour list is invalid or not allocated',&
            &  69,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%neighs%vec(nlid)%t%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour lists have not been computed',&
            &  77,info)
        GOTO 9999
    ENDIF

    nvlist => Pc%neighs%vec(nlid)%t%nvlist

    9999 CONTINUE

END SUBROUTINE get_nvlist_s





SUBROUTINE data_1d_i_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    INTEGER,DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_int&
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_i_check_d

SUBROUTINE data_1d_i_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER,DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_i_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_i(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_i(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_i(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_i(1)

END SUBROUTINE data_1d_i_get_d


SUBROUTINE data_1d_i_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER,DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_i_set_d



SUBROUTINE data_1d_li_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    INTEGER(ppm_kind_int64),DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_longint& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_li_check_d

SUBROUTINE data_1d_li_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER(ppm_kind_int64),DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_li_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_li(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_li(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_li(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_li(1)

END SUBROUTINE data_1d_li_get_d


SUBROUTINE data_1d_li_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER(ppm_kind_int64),DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_li_set_d



SUBROUTINE data_1d_r_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    REAL(ppm_kind_double),DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_real& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_r_check_d

SUBROUTINE data_1d_r_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    REAL(ppm_kind_double),DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_r_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_r(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_r(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_r(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_r(1)

END SUBROUTINE data_1d_r_get_d


SUBROUTINE data_1d_r_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    REAL(ppm_kind_double),DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_r_set_d



SUBROUTINE data_1d_c_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    COMPLEX(ppm_kind_double),DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_comp& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_c_check_d

SUBROUTINE data_1d_c_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    COMPLEX(ppm_kind_double),DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_c_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_c(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_c(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_c(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_c(1)

END SUBROUTINE data_1d_c_get_d


SUBROUTINE data_1d_c_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    COMPLEX(ppm_kind_double),DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_c_set_d



SUBROUTINE data_1d_l_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    LOGICAL,DIMENSION(:),POINTER,        INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.NE.1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_logical& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_1d_l_check_d

SUBROUTINE data_1d_l_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    LOGICAL,DIMENSION(:),POINTER     :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_1d_l_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_1d_l(1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_1d_l(1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_1d_l(1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_1d_l(1)

END SUBROUTINE data_1d_l_get_d


SUBROUTINE data_1d_l_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    LOGICAL,DIMENSION(:),POINTER      :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_1d_l_set_d




SUBROUTINE data_2d_i_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    INTEGER,DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_int&
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_i_check_d

SUBROUTINE data_2d_i_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER,DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_i_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_i(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_i(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_i(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_i(1,1)

END SUBROUTINE data_2d_i_get_d


SUBROUTINE data_2d_i_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER,DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_i_set_d



SUBROUTINE data_2d_li_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_longint& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_li_check_d

SUBROUTINE data_2d_li_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_li_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_li(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_li(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_li(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_li(1,1)

END SUBROUTINE data_2d_li_get_d


SUBROUTINE data_2d_li_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    INTEGER(ppm_kind_int64),DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_li_set_d



SUBROUTINE data_2d_r_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    REAL(ppm_kind_double),DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_real& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_r_check_d

SUBROUTINE data_2d_r_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    REAL(ppm_kind_double),DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_r_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_r(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_r(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_r(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_r(1,1)

END SUBROUTINE data_2d_r_get_d


SUBROUTINE data_2d_r_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    REAL(ppm_kind_double),DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_r_set_d



SUBROUTINE data_2d_c_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    COMPLEX(ppm_kind_double),DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_comp& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_c_check_d

SUBROUTINE data_2d_c_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    COMPLEX(ppm_kind_double),DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_c_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_c(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_c(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_c(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_c(1,1)

END SUBROUTINE data_2d_c_get_d


SUBROUTINE data_2d_c_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    COMPLEX(ppm_kind_double),DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_c_set_d



SUBROUTINE data_2d_l_check_d(props,wp,id,info) 
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_c_props_d)                           :: props
    !!! Data structure containing the particles
    LOGICAL,DIMENSION(:,:),POINTER,      INTENT(IN   )   :: wp
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    INTEGER,                            INTENT(   OUT)  :: info
    !!! Return status, on success 0.
    CHARACTER(LEN=ppm_char)                             :: caller ='prop_check'
    INTEGER, DIMENSION(:),POINTER :: nullv=>NULL()
    
    info = 0
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT.props%exists(id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'This property id does not exist.',&
            35,info)
        RETURN
    ENDIF

    IF (props%vec(id)%t%lda.LT.2) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has wrong dimension for this property id',&
            47,info)
        info = nullv(1)
        RETURN
    ENDIF


    IF (props%vec(id)%t%data_type.NE. &
        ppm_type_logical& 
       &  ) THEN

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Argument has the wrong type for this property id',&
            72,info)
        RETURN
    ENDIF

END SUBROUTINE data_2d_l_check_d

SUBROUTINE data_2d_l_get_d(Pc,wp,ppt_id,with_ghosts)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER                         :: ppt_id
    LOGICAL,DIMENSION(:,:),POINTER   :: wp
    INTEGER                         :: info
    LOGICAL,OPTIONAL                :: with_ghosts
    CHARACTER (LEN = ppm_char)      :: caller = '__FUNCNAME'

    IF (ppt_id .LE. 0) THEN
        write(cbuf,*) 'ERROR: failed to get DATANAME for property ',& 
            'ppt_id = ',ppt_id
        CALL ppm_write(ppm_rank,'DATANAME',cbuf,info)
        wp => NULL()
        RETURN
    ENDIF

    !CALL Pc%props%checktype(wp,ppt_id,info)
    CALL Pc%props%data_2d_l_check_d(wp,ppt_id,info)
    !IF (info.NE.0) THEN
        !info = ppm_error_error
        !WRITE(cbuf,'(A,I0,A)') & 
            !'Type conflict between the requested property id:',ppt_id,&
            !& ' and the target array (1st argument)'  
        !CALL ppm_error(ppm_err_alloc,caller,cbuf,109,info)
        !wp => NULL()
        !RETURN
    !ENDIF

    IF (ppt_id .LE. Pc%props%max_id) THEN
        ASSOCIATE (prop => Pc%props%vec(ppt_id)%t)
        IF (prop%flags(ppm_ppt_partial)) THEN
            IF (PRESENT(with_ghosts)) THEN
                IF (with_ghosts) THEN
                    IF (prop%flags(ppm_ppt_ghosts)) THEN
                        wp => &
                     prop%data_2d_l(:,1:Pc%Mpart)
                    ELSE
                        write(*,*) line_of_stars
                        write(*,*) 'ERROR: tried to get DATANAME (name = ',&
                            & TRIM(ADJUSTL(prop%name)),&
                            & ') with ghosts when ghosts are not up-to-date. ',&
                            & 'Returning NULL pointer'
                        write(*,*) 'Run with traceback option to debug'
                        write(*,*) line_of_stars
                        wp => NULL()
                        !segfault the program. Compile with appropriate compiler
                        !options to check for array bounds and provide traceback
                        write(*,*) prop%data_2d_l(1,1)
                    ENDIF
                    RETURN
                ENDIF
            ENDIF
            wp => &
                prop%data_2d_l(:,1:Pc%Npart)
            RETURN
        ENDIF
        END ASSOCIATE
    ENDIF

    write(cbuf,*) 'ERROR: tried to get DATANAME (name = ',&
        & TRIM(ADJUSTL(Pc%props%vec(ppt_id)%t%name)),&
        & ') when mapping is not up-to-date. ',&
        & 'Returning NULL pointer', &
        'Run with traceback option to debug'
    CALL ppm_write(ppm_rank,cbuf,caller,info)

    wp => NULL()
    !segfault the program. Compile with appropriate compiler
    !options to check for array bounds and provide traceback
    write(*,*) Pc%props%vec(ppt_id)%t%data_2d_l(1,1)

END SUBROUTINE data_2d_l_get_d


SUBROUTINE data_2d_l_set_d(Pc,wp,ppt_id,read_only,ghosts_ok)
    CLASS(ppm_t_particles_d)    :: Pc
    INTEGER                          :: ppt_id
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    LOGICAL,DIMENSION(:,:),POINTER    :: wp

    !If read_only was not explicitely set to true, then assume
    !that ghosts are no longer up to date, unless ghosts_ok was
    ! explicitely set to true
    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            wp => NULL()
            RETURN
        ENDIF
    ENDIF

    !Assume that the ghost values are now incorrect
    Pc%props%vec(ppt_id)%t%flags(ppm_ppt_ghosts) = .FALSE.
    wp => NULL()

END SUBROUTINE data_2d_l_set_d


SUBROUTINE get_xp_d(Pc,xp,with_ghosts)
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)         :: Pc
    LOGICAL,OPTIONAL                      :: with_ghosts
    REAL(MK),DIMENSION(:,:),     POINTER  :: xp
    INTEGER                               :: info

    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            IF (Pc%flags(ppm_part_ghosts)) THEN
                xp => Pc%xp(1:ppm_dim,1:Pc%Mpart)
            ELSE
                write(cbuf,*) 'WARNING: tried to get xp with ghosts ',&
                    'when ghosts are not up-to-date'
                CALL ppm_write(ppm_rank,'get_xp',cbuf,info)
                xp => NULL()
            ENDIF
            RETURN
        ENDIF
    ENDIF

    xp => Pc%xp(1:ppm_dim,1:Pc%Npart)

END SUBROUTINE get_xp_d

SUBROUTINE set_xp_d(Pc,xp,read_only,ghosts_ok)
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)    :: Pc
    LOGICAL,OPTIONAL                 :: read_only
    LOGICAL,OPTIONAL                 :: ghosts_ok
    REAL(MK),DIMENSION(:,:),POINTER  :: xp
    INTEGER                          :: i

    TYPE(ppm_t_part_prop_d), POINTER :: prop => NULL()
    TYPE(ppm_t_neighlist_d), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_d),  POINTER :: op => NULL()

    IF (PRESENT(ghosts_ok)) THEN
        IF (ghosts_ok) THEN
            xp => NULL()
            RETURN
        ENDIF
    ENDIF

    IF (PRESENT(read_only)) THEN
        IF (read_only) THEN
            xp => NULL()
            RETURN
        ENDIF
    ENDIF

    Pc%flags(ppm_part_areinside) = .FALSE.
    Pc%flags(ppm_part_partial) = .FALSE.
    Pc%flags(ppm_part_ghosts) = .FALSE.
    Pc%flags(ppm_part_cartesian) = .FALSE.

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        prop%flags(ppm_ppt_ghosts) = .FALSE.
        prop%flags(ppm_ppt_partial) = .FALSE.
        prop => Pc%props%next()
    ENDDO

    nl => Pc%neighs%begin()
    DO WHILE (ASSOCIATED(nl))
        nl%uptodate = .FALSE.
        nl => Pc%neighs%next()
    ENDDO

    op => Pc%ops%begin()
    DO WHILE (ASSOCIATED(op))
        op%flags(ppm_ops_iscomputed) = .FALSE.
        op => Pc%ops%next()
    ENDDO

    xp => NULL()

END SUBROUTINE set_xp_d

SUBROUTINE part_prop_create_d(Pc,id,datatype,info,&
        lda,name,zero,with_ghosts)
    !!! Adds a property to an existing particle set
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(  OUT) :: id
    INTEGER,                INTENT(IN   ) :: datatype
    INTEGER, OPTIONAL,      INTENT(IN   ) :: lda
    CHARACTER(LEN=*) , OPTIONAL           :: name
    !!! name to this property
    LOGICAL, OPTIONAL                     :: zero
    !!! if true, then initialise the data to zero
    LOGICAL, OPTIONAL                     :: with_ghosts
    !!! if true, then allocate with Mpart instead of the default size of Npart
    INTEGER,               INTENT(OUT)    :: info

    INTEGER                               :: lda2,vec_size,npart,i
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_prop_create'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_part_prop_d),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_part_prop_d),               POINTER  :: prop => NULL()
    LOGICAL, DIMENSION(ppm_param_length_pptflags):: flags

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%props )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of property pointers
            id = id + 1
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of property pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',123,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of property pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',134,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE

    IF (.NOT. ASSOCIATED(Pc%props%vec(id)%t)) THEN
        ALLOCATE(Pc%props%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating property pointer failed',159,info)
            GOTO 9999
        ENDIF
    ENDIF

    prop => Pc%props%vec(id)%t

    !
    lda2 = 1
    IF (PRESENT(lda)) THEN
        IF (lda.GE.2) THEN
            lda2 = lda
        ENDIF
    ENDIF

    IF (PRESENT(name)) THEN
        name2 = name
    ELSE
        name2 = particles_dflt_pptname(id,1)
    ENDIF

    npart = Pc%Npart
    flags = .FALSE.
    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            IF (Pc%flags(ppm_part_ghosts)) THEN
                npart = Pc%Mpart
                flags(ppm_ppt_ghosts) = .TRUE.
            ELSE
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,&
            'trying to init property for ghosts when ghosts are not computed',&
                    191,info)
                GOTO 9999
            ENDIF
        ENDIF
    ENDIF
    flags(ppm_ppt_partial) = .TRUE.
    flags(ppm_ppt_map_ghosts) = .TRUE.
    flags(ppm_ppt_map_parts) = .TRUE.


    ! Create the property
    CALL prop%create(datatype,npart,lda2,name2,flags,info,zero)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating property array failed',206,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_prop_create_d

SUBROUTINE part_prop_destroy_d(Pc,id,info)
    !!! Destroy a property from an existing particle set
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_prop_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%props)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'property id larger than size of properties array',&
                231,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            259,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE


    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_prop_destroy_d

SUBROUTINE part_prop_realloc_d(Pc,id,info,with_ghosts,datatype,lda)
    !!! Reallocate the property array to the correct size
    !!! (e.g. if the number of particles has changed or if the type
    !!! of the data changes)
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(IN   ) :: id
    INTEGER,               INTENT(OUT)    :: info
    LOGICAL, OPTIONAL                     :: with_ghosts
    !!! if true, then allocate with Mpart instead of the default size of Npart
    INTEGER, OPTIONAL                     :: datatype
    !!! deallocate the old data array and allocate a new one,
    !!! possibly of a different data type.
    INTEGER, OPTIONAL                     :: lda
    !!! deallocate the old data array and allocate a new one,
    !!! possibly of a different dimension

    INTEGER                               :: lda2,vec_size,npart,i,dtype
    CHARACTER(LEN=ppm_char)               :: caller = 'realloc_prop'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_part_prop_d),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_part_prop_d),               POINTER  :: prop => NULL()
    LOGICAL, DIMENSION(ppm_param_length_pptflags):: flags

    CALL substart(caller,t0,info)

    IF (.NOT. ASSOCIATED(Pc%props%vec(id)%t)) THEN
        ALLOCATE(Pc%props%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating property pointer failed',305,info)
            GOTO 9999
        ENDIF
    ENDIF

    prop => Pc%props%vec(id)%t
    flags = prop%flags
    name2 = prop%name

    npart = Pc%Npart
    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            IF (Pc%flags(ppm_part_ghosts)) THEN
                npart = Pc%Mpart
                flags(ppm_ppt_ghosts) = .TRUE.
            ELSE
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,&
            'trying to init property for ghosts when ghosts are not computed',&
                    324,info)
                GOTO 9999
            ENDIF
        ENDIF
    ENDIF
    flags(ppm_ppt_partial) = .TRUE.

    IF (PRESENT(lda)) THEN
        lda2 = lda
    ELSE
        lda2 = prop%lda
    ENDIF
    IF (PRESENT(datatype)) THEN
        dtype = datatype
    ELSE
        dtype = prop%data_type
    ENDIF
    IF (lda2.NE.prop%lda .OR. dtype.NE.prop%data_type) THEN
        CALL prop%destroy(info)
    ENDIF

    ! Create the property
    CALL prop%create(dtype,npart,lda2,name2,flags,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'reallocating property array failed',350,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_prop_realloc_d

SUBROUTINE prop_create_d(prop,datatype,npart,lda,name,flags,info,zero)
    !!! Constructor for particle property data structure
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_part_prop_d)      :: prop
    INTEGER,                INTENT(IN) :: datatype
    INTEGER,                INTENT(IN) :: npart
    INTEGER,                INTENT(IN) :: lda
    CHARACTER(LEN=*)                   :: name
    !!! name to this property
    LOGICAL, DIMENSION(ppm_param_length_pptflags),INTENT(IN) :: flags
    INTEGER,               INTENT(OUT) :: info
    LOGICAL, OPTIONAL,     INTENT( IN) :: zero
    !!! if true, then initialize the data to zero

    REAL(KIND(1.D0))                   :: t0
    INTEGER                            :: iopt
    CHARACTER(LEN=ppm_char)            :: caller = 'prop_create'
    LOGICAL                            :: is2d
    LOGICAL                            :: zero_data



    CALL substart(caller,t0,info)

    prop%lda       = lda
    prop%data_type = datatype
    prop%name      = name
    prop%flags     = flags

    IF (PRESENT(zero)) THEN
        zero_data = zero
    ELSE
        zero_data = .FALSE.
    ENDIF


    iopt   = ppm_param_alloc_grow

    IF (lda.GE.2) THEN
        ldc(1) = lda
        ldc(2) = npart
        is2d = .TRUE.
    ELSE
        ldc(1) = npart
        is2d = .FALSE.
    ENDIF


    IF (is2d) THEN
        SELECT CASE (datatype)
        CASE (ppm_type_int)
            CALL ppm_alloc(prop%data_2d_i,ldc,iopt,info)
            IF (zero_data) prop%data_2d_i(1:lda,1:npart) = 0
        CASE (ppm_type_longint)
            CALL ppm_alloc(prop%data_2d_li,ldc,iopt,info)
            IF (zero_data) prop%data_2d_li(1:lda,1:npart) = 0
        CASE (ppm_type_real)
            CALL ppm_alloc(prop%data_2d_r,ldc,iopt,info)
            IF (zero_data) prop%data_2d_r(1:lda,1:npart) = 0._MK
        CASE (ppm_type_comp)
            CALL ppm_alloc(prop%data_2d_c,ldc,iopt,info)
            IF (zero_data) prop%data_2d_c(1:lda,1:npart) = 0._MK
        CASE (ppm_type_logical )
            CALL ppm_alloc(prop%data_2d_l,ldc,iopt,info)
            IF (zero_data) prop%data_2d_l(1:lda,1:npart) = .FALSE.
        CASE DEFAULT
            info = ppm_error_fatal
            CALL ppm_error(ppm_err_argument,caller,   &
                &        'invalid type for particle property',427,info)
        END SELECT
    ELSE
        SELECT CASE (datatype)
        CASE (ppm_type_int)
            CALL ppm_alloc(prop%data_1d_i,ldc,iopt,info)
            IF (zero_data) prop%data_1d_i(1:npart) = 0
        CASE (ppm_type_longint)
            CALL ppm_alloc(prop%data_1d_li,ldc,iopt,info)
            IF (zero_data) prop%data_1d_li(1:npart) = 0
        CASE (ppm_type_real)
            CALL ppm_alloc(prop%data_1d_r,ldc,iopt,info)
            IF (zero_data) prop%data_1d_r(1:npart) = 0._MK
        CASE (ppm_type_comp)
            CALL ppm_alloc(prop%data_1d_c,ldc,iopt,info)
            IF (zero_data) prop%data_1d_c(1:npart) = 0._MK
        CASE (ppm_type_logical )
            CALL ppm_alloc(prop%data_1d_l,ldc,iopt,info)
            IF (zero_data) prop%data_1d_l(1:npart) = .FALSE.
        CASE DEFAULT
            info = ppm_error_fatal
            CALL ppm_error(ppm_err_argument,caller,   &
                &        'invalid type for particle property',449,info)
        END SELECT
    ENDIF

    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'allocating property failed',456,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE prop_create_d

SUBROUTINE prop_destroy_d(prop,info)
    CLASS(ppm_t_part_prop_d)      :: prop
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'prop_destroy'


    CALL substart(caller,t0,info)

    IF(ASSOCIATED(prop%data_1d_i)) DEALLOCATE(prop%data_1d_i,STAT=info)
    IF(ASSOCIATED(prop%data_2d_i)) DEALLOCATE(prop%data_2d_i,STAT=info)
    IF(ASSOCIATED(prop%data_1d_li)) DEALLOCATE(prop%data_1d_li,STAT=info)
    IF(ASSOCIATED(prop%data_2d_li)) DEALLOCATE(prop%data_2d_li,STAT=info)
    IF(ASSOCIATED(prop%data_1d_r)) DEALLOCATE(prop%data_1d_r,STAT=info)
    IF(ASSOCIATED(prop%data_2d_r)) DEALLOCATE(prop%data_2d_r,STAT=info)
    IF(ASSOCIATED(prop%data_1d_c)) DEALLOCATE(prop%data_1d_c,STAT=info)
    IF(ASSOCIATED(prop%data_2d_c)) DEALLOCATE(prop%data_2d_c,STAT=info)
    IF(ASSOCIATED(prop%data_1d_l)) DEALLOCATE(prop%data_1d_l,STAT=info)
    IF(ASSOCIATED(prop%data_2d_l)) DEALLOCATE(prop%data_2d_l,STAT=info)

    prop%data_type = ppm_type_none
    prop%lda = 0
    prop%flags = .FALSE.

    CALL substop(caller,t0,info)

END SUBROUTINE prop_destroy_d

SUBROUTINE part_neigh_create_d(Pc,id,info,&
        P_id,name,skin,symmetry,cutoff)
    !!! Create a data structure to store a neighbour list
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,               INTENT(  OUT)  :: id
    INTEGER,               INTENT(OUT)    :: info
    INTEGER, OPTIONAL                     :: P_id    
    !!! Id of the set of particles that this neighbor list refers to
    !!! The default, 0, stands for "self"
    CHARACTER(LEN=*) , OPTIONAL           :: name
    !!! name of this neighbour list
    REAL(MK), OPTIONAL                    :: skin
    REAL(MK), OPTIONAL                    :: cutoff
    LOGICAL, OPTIONAL                     :: symmetry    

    INTEGER                               :: vec_size,i
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_neigh_create'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_t_neighlist_d),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_neighlist_d),POINTER  :: Nlist
    REAL(MK), DIMENSION(:), POINTER       :: rcp => NULL()

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%neighs )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of property pointers
            id = id + 1
            write(*,*) cont%nb, cont%min_id,cont%max_id,cont%vec_size
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                write(*,*) '  id = ',id
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of property pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',541,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of property pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',552,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE
        
    IF (.NOT. ASSOCIATED(Pc%neighs%vec(id)%t)) THEN
        ALLOCATE(Pc%neighs%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating neighlist pointer failed',577,info)
            GOTO 9999
        ENDIF
    ENDIF

    Nlist => Pc%neighs%vec(id)%t

    ! Create the property

    IF (PRESENT(name)) THEN
        Nlist%name = name
    ELSE
        Nlist%name = particles_dflt_nlname(id)
    ENDIF

    IF (PRESENT(P_id)) THEN
        Nlist%P_id = P_id
    ELSE
        Nlist%P_id = 0
    ENDIF

    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_d)
        ASSOCIATE (ghosts => Pc%flags(ppm_part_ghosts))
            IF (Pc%rcp_id.LE.0) THEN
                CALL Pc%create_prop(Pc%rcp_id,ppm_type_real,info,&
                    name='rcp',with_ghosts=ghosts) 
            ENDIF
            CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=ghosts)
            IF (PRESENT(cutoff)) THEN
                rcp = cutoff
            ELSE
                rcp = Pc%ghostlayer
            ENDIF
            CALL Pc%set(rcp,Pc%rcp_id,ghosts_ok=ghosts)
        END ASSOCIATE
        Nlist%cutoff = -1._MK 
        !this field should not be used with adaptive particles
    CLASS DEFAULT
        IF (PRESENT(cutoff)) THEN
            Nlist%cutoff = cutoff
        ELSE
            Nlist%cutoff = Pc%ghostlayer
        ENDIF
    END SELECT

    IF (PRESENT(skin)) THEN
        Nlist%skin = skin
    ELSE
        Nlist%skin = 0._mk
    ENDIF

    IF (PRESENT(symmetry)) THEN
        IF (symmetry) THEN
            Nlist%isymm = 1
        ELSE
            Nlist%isymm = 0
        ENDIF
    ELSE
        Nlist%isymm = 0
    ENDIF

    Nlist%uptodate = .FALSE.
    Nlist%nneighmin = 0
    Nlist%nneighmax = 0

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_neigh_create_d

SUBROUTINE part_neigh_destroy_d(Pc,id,info)
    !!! Destroy a property from an existing particle set
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_neigh_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%neighs)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'property id larger than size of properties array',&
                664,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            692,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_neigh_destroy_d

SUBROUTINE neigh_destroy_d(neigh,info)
    CLASS(ppm_t_neighlist_d)      :: neigh
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'neigh_destroy'

    CALL substart(caller,t0,info)

    IF(ASSOCIATED(neigh%nvlist)) DEALLOCATE(neigh%nvlist,STAT=info)
    IF(ASSOCIATED(neigh%vlist))  DEALLOCATE(neigh%vlist,STAT=info)

    CALL substop(caller,t0,info)

END SUBROUTINE neigh_destroy_d

SUBROUTINE part_op_create_d(Pc,id,nterms,coeffs,degree,order,info,&
        name,with_ghosts,vector,interp,P_id,neigh_id)
    !!! Adds a differential operator to a particle set
    !!!------------------------------------------------------------------------!
    !!! Define a DC operator as a linear combination (with scalar coefficients)
    !!! of nterms partial derivatives of arbitrary degrees. 
    !!! These are given by a matrix
    !!! of integers where each row represents one term of the linear combination
    !!! and each of the ppm_dim columns is the order of differentiation in that
    !!! dimension.
    !!! The definition of the operator is stored in the ppm_t_operator derived 
    !!! type under the index eta_id. 
    !!! The operator itself is computed elsewhere and will be stored in 
    !!! the same data structure.
    !!!
    !!! Usage example:
    !!!
    !!!   The differential operator:
    !!!   3.0 df/dx -7.0 d^4f/dxdydz^2 + 8.0 d^3f/dx^2dz
    !!!   would be defined by calling particles_dcop_define with
    !!!   coeffs = (/3.0, -7.0, 8.0/)
    !!!   degree = (/1,0,0,  1,1,2,  2,0,1 /)
    !!!   order =  (/2,      1,      3     /)
    !!!   nterms = 3
    !!!------------------------------------------------------------------------!
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                       :: Pc
    INTEGER,                            INTENT(  OUT)   :: id
    !!! id for this operator 
    INTEGER,                            INTENT(IN   )   :: nterms
    !!! Number of terms in the linear combination
    REAL(MK),DIMENSION(:),              INTENT(IN   )   :: coeffs
    !!! Multiplicative coefficients of each term in the linear combination of
    !!! differential operators
    INTEGER,DIMENSION(:),               INTENT(IN   )   :: degree
    !!! Degree of differentiation of each term
    INTEGER,DIMENSION(:),               INTENT(IN   )   :: order
    !!! Order of approxmiation for each term
    LOGICAL,OPTIONAL,                   INTENT(IN   )   :: with_ghosts
    !!! True if the operator should be computed for ghost particles too. 
    !!! Note that the resulting values will be wrong for the ghost particles
    !!! that have some neighbours outside the ghost layers. Default is false.
    LOGICAL,OPTIONAL,                   INTENT(IN   )   :: vector
    !!! True if the operator is a vector field. Default is false.
    LOGICAL,OPTIONAL,                   INTENT(IN   )   :: interp
    !!! True if the operator interpolates data from one set of particles to
    !!! another. Default is false.
    INTEGER,OPTIONAL,                   INTENT(IN   )   :: P_id
    !!! Id of the set of particles that this operator takes data from.
    !!! The default, 0, stands for "self" (the operator is computed
    !!! on the same set of particles than the one which contains the data).
    INTEGER,OPTIONAL,                   INTENT(IN   )   :: neigh_id
    !!! Id of the neighbour list that should be used
    !!! The default, 1, refers to "self": the list of neighbours within
    !!! the same set of particles. 
    CHARACTER(LEN=*) , OPTIONAL           :: name
    !!! name for this operator
    INTEGER,               INTENT(OUT)    :: info

    INTEGER                               :: i,vec_size,npart,lpid,lnlid
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_op_create'
    CHARACTER(LEN=ppm_char)               :: lname
    LOGICAL                               :: lwith_ghosts,lvector,linterp
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_ops_d),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_operator_d),          POINTER  :: op => NULL()

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%ops )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of property pointers
            id = id + 1
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of property pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',809,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of property pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating property array failed',820,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE

    !Allocate operator struct
    IF (.NOT. ASSOCIATED(Pc%ops%vec(id)%t)) THEN
        ALLOCATE(Pc%ops%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating operator pointer failed',846,info)
            GOTO 9999
        ENDIF
    ENDIF

    op => Pc%ops%vec(id)%t

    IF (PRESENT(name)) THEN
        lname = name
    ELSE
        lname = particles_dflt_opname(id)
    ENDIF
    IF (PRESENT(with_ghosts)) THEN
        lwith_ghosts = with_ghosts
    ELSE
        lwith_ghosts = .FALSE.
    ENDIF
    IF (PRESENT(interp)) THEN
        linterp = interp
    ELSE
        linterp = .FALSE.
    ENDIF
    IF (PRESENT(vector)) THEN
        lvector = vector
    ELSE
        lvector = .FALSE.
    ENDIF
    IF (PRESENT(P_id)) THEN
        lpid = P_id
    ELSE
        lpid = 0
    ENDIF
    IF (PRESENT(neigh_id)) THEN
        lnlid = neigh_id
    ELSE
        lnlid = ppm_param_default_nlID
    ENDIF

    IF (.NOT. Pc%neighs%exists(lnlid)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Invalid neighbour list. Use comp_neigh() first.',&
            888,info)
        GOTO 9999
    ENDIF
    IF (Pc%neighs%vec(lnlid)%t%P_id .NE. lpid) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'incompatible P_id and neigh_id',894,info)
        GOTO 9999
    ENDIF

    ! Create/Initialize operator
    CALL op%create(nterms,coeffs,degree,order,&
        lname,lwith_ghosts,lvector,linterp,lpid,lnlid,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating operator object failed',904,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_op_create_d


SUBROUTINE part_op_destroy_d(Pc,id,info)
    !!! Destroy a property from an existing particle set
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_op_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%ops)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'property id larger than size of properties array',&
                930,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            958,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_op_destroy_d

SUBROUTINE op_create_d(op,nterms,coeffs,degree,order,&
        name,with_ghosts,vector,interp,pid,nlid,info)
    !!! Create a differential operator
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_operator_d)          :: op
    INTEGER,                INTENT(IN   ) :: nterms
    !!! Number of terms in the linear combination
    REAL(MK),DIMENSION(:),  INTENT(IN   ) :: coeffs
    !!! Multiplicative coefficients of each term in the linear combination of
    !!! differential operators
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: degree
    !!! Degree of differentiation of each term
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: order
    !!! Order of approxmiation for each term
    LOGICAL,                INTENT(IN   ) :: with_ghosts
    !!! True if the operator should be computed for ghost particles too. 
    !!! Note that the resulting values will be wrong for the ghost particles
    !!! that have some neighbours outside the ghost layers. Default is false.
    LOGICAL,                INTENT(IN   ) :: vector
    !!! True if the operator is a vector field. Default is false.
    LOGICAL,                INTENT(IN   ) :: interp
    !!! True if the operator interpolates data from one set of particles to
    !!! another. Default is false.
    INTEGER,                INTENT(IN   ) :: pid
    !!! Id of the set of particles that this operator takes data from.
    !!! The default, 0, stands for "self" (the operator is computed
    !!! on the same set of particles than the one which contains the data).
    INTEGER,                INTENT(IN   ) :: nlid
    !!! Id of the neighbour list that should be used
    !!! The default, 1, refers to "self": the list of neighbours within
    !!! the same set of particles. 
    CHARACTER(LEN=*)                      :: name
    !!! name for this operator
    INTEGER,                INTENT(OUT)   :: info
    !!! Returns status, 0 upon success.

    CHARACTER(LEN=ppm_char)               :: caller = 'op_create'
    REAL(KIND(1.D0))                      :: t0
    
    CALL substart(caller,t0,info)

    op%flags = .FALSE.
    op%flags(ppm_ops_inc_ghosts) = with_ghosts
    op%flags(ppm_ops_interp) = interp
    op%flags(ppm_ops_vector) = vector
    op%flags(ppm_ops_isdefined) = .TRUE.
    op%P_id = pid
    op%neigh_id = nlid

    IF (ASSOCIATED(op%desc)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,   &
            &       'operator struct not clean. Use destroy first ',&
            &       1025,info)
        GOTO 9999
    ENDIF

    ALLOCATE(op%desc,STAT=info)
    IF (info.NE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &       'allocation of ker or desc failed',1033,info)
        GOTO 9999
    ENDIF

    CALL op%desc%create(nterms,coeffs,degree,order,name,info)

    CALL substop(caller,t0,info)
    
    9999 CONTINUE

END SUBROUTINE op_create_d

SUBROUTINE op_destroy_d(op,info)
    !!! Destroy the description for a differential operator
    CLASS(ppm_t_operator_d)              :: op
    INTEGER                                   :: i
    INTEGER,                   INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'op_destroy'
    
    CALL substart(caller,t0,info)

    CALL ppm_alloc(op%ker,ldc,ppm_param_dealloc,info)
    IF (info.NE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_dealloc,caller,   &
            &       'ker deallocate failed ',1060,info)
        GOTO 9999
    ENDIF
    CALL op%desc%destroy(info)
    IF (info.NE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,   &
            &       'desc destroy failed ',1067,info)
        GOTO 9999
    ENDIF

    op%flags = .FALSE.
    op%P_id = -1
    op%neigh_id = 1

    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE op_destroy_d

SUBROUTINE part_op_compute_d(Pc,op_id,info,c,min_sv)

    USE ppm_module_write
    IMPLICIT NONE
    INCLUDE 'mpif.h'

    INTEGER, PARAMETER :: MK = ppm_kind_double
    !---------------------------------------------------------
    ! arguments
    !---------------------------------------------------------
    CLASS(ppm_t_particles_d)                        :: Pc
    !!! particles
    INTEGER,                             INTENT(IN   )   :: op_id
    !!! id of the operator 
    INTEGER,                             INTENT(  OUT)   :: info
    !!! non-zero on output if some error occurred
    !---------------------------------------------------------
    ! Optional arguments
    !---------------------------------------------------------
    REAL(MK),OPTIONAL                       :: c
    !!! ratio h/epsilon (default is 1.0)
    REAL(MK),OPTIONAL   ,  INTENT(  OUT)    :: min_sv
    !!! smallest singular value
    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    CHARACTER(LEN = ppm_char)               :: caller = 'part_dcop_compute'
    CHARACTER(LEN = ppm_char)               :: cbuf
    REAL(KIND(1.D0))                        :: t0,t1,t2
    TYPE(ppm_t_operator_d), POINTER    :: op => NULL()

    !-------------------------------------------------------------------------
    ! Initialize
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    t1 = MPI_WTIME(info)

    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT. ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,'Particles not defined',&
            1128,info)
        GOTO 9999
    ENDIF
    IF (.NOT. Pc%ops%exists(op_id)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            & 'No operator data structure found, use create_op() first',&
            1135,info)
        GOTO 9999
    ENDIF
    op => Pc%ops%vec(op_id)%t
    IF (.NOT. op%flags(ppm_ops_isdefined)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            & 'Operator not found, use create_op() first',&
            1143,info)
        GOTO 9999
    ENDIF
    IF (op%flags(ppm_ops_iscomputed)) THEN
        WRITE(cbuf,*) 'WARNING: The operator with id ',op_id,&
            & ' and name *',TRIM(ADJUSTL(op%desc%name)),&
            &'* seems to have already been computed. Unnecessary call to',&
            &' particles_dcop_compute()'
        CALL ppm_write(ppm_rank,caller,cbuf,info)
    ENDIF

    !-------------------------------------------------------------------------
    ! Compute the DC operator
    !-------------------------------------------------------------------------

    Pc%stats%nb_dc_comp = Pc%stats%nb_dc_comp + 1

    IF (ppm_dim .EQ. 2) THEN
        CALL Pc%ppm_dcop_compute2d_d(op_id,info,c,min_sv)
    ELSE
        CALL Pc%ppm_dcop_compute3d_d(op_id,info,c,min_sv)
    ENDIF
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            & 'ppm_dcop_compute failed',&
            1169,info)
        GOTO 9999
    ENDIF

    !-------------------------------------------------------------------------
    ! Update states
    !-------------------------------------------------------------------------
    op%flags(ppm_ops_iscomputed) = .TRUE.
    t2 = MPI_WTIME(info)
    Pc%stats%t_dc_comp = Pc%stats%t_dc_comp + (t2-t1)

    !-------------------------------------------------------------------------
    ! Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_op_compute_d

SUBROUTINE part_op_apply_d(Pc,from_id,to_id,op_id,info)
    !!!------------------------------------------------------------------------!
    !!! Apply DC kernel stored in op_id to the scalar property stored
    !!! prop_from_id and store the results in prop_to_id
    !!!------------------------------------------------------------------------!
    USE ppm_module_data, ONLY: ppm_rank

    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                       :: Pc
    !!! Data structure containing the particles
    INTEGER,                            INTENT(IN   )   :: from_id
    !!! id where the data is stored
    INTEGER,                            INTENT(INOUT)   :: to_id
    !!! id where the result should be stored (0 if it needs to be allocated)
    INTEGER,                            INTENT(IN   )   :: op_id
    !!! id where the DC kernel has been stored
    INTEGER,                            INTENT(  OUT)   :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)                  :: filename
    CHARACTER(LEN = ppm_char)                  :: caller = 'part_dcop_apply'
    INTEGER                                    :: ip,iq,ineigh,lda,np_target
    REAL(KIND(1.D0))                           :: t0,t1,t2
    REAL(MK),DIMENSION(:,:),POINTER            :: eta => NULL()
    REAL(MK),DIMENSION(:),  POINTER            :: wps1 => NULL(),wps2=>NULL()
    REAL(MK),DIMENSION(:,:),POINTER            :: wpv1 => NULL(),wpv2=>NULL()
    REAL(MK),DIMENSION(:),  POINTER            :: dwps => NULL()
    REAL(MK),DIMENSION(:,:),POINTER            :: dwpv => NULL()
    INTEGER, DIMENSION(:),  POINTER            :: nvlist => NULL()
    INTEGER, DIMENSION(:,:),POINTER            :: vlist => NULL()
    REAL(MK)                                   :: sig
    LOGICAL                                    :: vector_output
    LOGICAL                                    :: vector_input
    LOGICAL                                    :: with_ghosts,isinterp

    TYPE(ppm_t_sop_d),POINTER             :: Pc2 => NULL()
    TYPE(ppm_t_neighlist_d),POINTER       :: Nlist => NULL()
    TYPE(ppm_t_operator_d), POINTER       :: op => NULL()
    TYPE(ppm_t_part_prop_d), POINTER      :: prop_from => NULL()
    !-------------------------------------------------------------------------
    ! Initialize
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    t1 = MPI_WTIME(info)

    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (.NOT. ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,'Particles not defined',&
            1253,info)
        GOTO 9999
    ENDIF
    IF (.NOT. Pc%ops%exists(op_id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'No operator data structure found, use create_op() first',&
            1260,info)
        GOTO 9999
    ENDIF
    op => Pc%ops%vec(op_id)%t
    IF (.NOT. op%flags(ppm_ops_isdefined)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Operator not found, use create_op() first',&
            1268,info)
        GOTO 9999
    ENDIF
    IF (.NOT.op%flags(ppm_ops_iscomputed)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Operator not computed, use comp_op() first',&
            1275,info)
        GOTO 9999
    ENDIF

    isinterp = op%flags(ppm_ops_interp)
    vector_output =  op%flags(ppm_ops_vector)
    !if true, then each term of the differential opearator is stored as one
    !component in eta. This is used when computing e.g. the gradient opearator.
    !if false, the same input parameters would yield an operator approximating
    ! the divergence operator.
    with_ghosts = op%flags(ppm_ops_inc_ghosts)
    !if true, then the operator should be computed for ghost particles too. 
    !Note that the resulting values will be wrong for the ghost particles
    !that have some neighbours outside the ghost layers. Some of these particles
    !may also not have enough neighbours for the Vandermonde matrix to be
    !invertible. These particles will be skipped without raising a warning.

    IF (with_ghosts) THEN
        np_target = Pc%Mpart
    ELSE
        np_target = Pc%Npart
    ENDIF

    lda = op%desc%nterms

    IF (.NOT. Pc%neighs%exists(op%neigh_id)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Neighbour lists have not been created',&
            1304,info)
        GOTO 9999
    ENDIF

    Nlist => Pc%neighs%vec(op%neigh_id)%t
    IF (.NOT. Nlist%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Neighbour lists are not up to date',1312,info)
        GOTO 9999
    ENDIF
    nvlist => Nlist%nvlist
    vlist => Nlist%vlist


    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_d)
        IF (isinterp) THEN
            Pc2 => Pc%set_aPc%vec(op%P_id)%t
            IF (.NOT. Pc2%props%exists(from_id)) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,   &
                    & 'The operator input is not allocated.',&
                    1327,info)
                GOTO 9999
            ELSE
                prop_from => Pc2%props%vec(from_id)%t
            ENDIF
        ELSE
            IF (.NOT. Pc%props%exists(from_id)) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_argument,caller,   &
                    & 'The operator input is not allocated.',&
                    1337,info)
                GOTO 9999
            ELSE
                prop_from => Pc%props%vec(from_id)%t
            ENDIF
        ENDIF
    CLASS DEFAULT
        IF (.NOT. Pc%props%exists(from_id)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                & 'The operator input is not allocated.',&
                1348,info)
            GOTO 9999
        ELSE
            prop_from => Pc%props%vec(from_id)%t
        ENDIF
    END SELECT

    IF (.NOT.prop_from%flags(ppm_ppt_ghosts)) THEN
        WRITE(cbuf,*) 'Ghost values of ',TRIM(ADJUSTL(&
            prop_from%name)),' are needed.'
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Please call particles_mapping_ghosts first',&
            1362,info)
        GOTO 9999
    ENDIF

    IF (vector_output .AND. prop_from%lda .NE. lda) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            & 'Incompatible dimensions between operator and input data',&
            1370,info)
        GOTO 9999
    ENDIF
    vector_input = (prop_from%lda .GE.2)

    !allocate output field if needed
    !otherwise simply check that the output array had been allocated
    !to the right size
    IF (to_id.EQ.0) THEN
        IF (vector_output) THEN
            CALL Pc%create_prop(to_id,ppm_type_real,info,lda=lda,&  
                name="dflt_dcop_apply",with_ghosts=with_ghosts)
        ELSE
            CALL Pc%create_prop(to_id,ppm_type_real,info,&
                name="dflt_dcop_apply",with_ghosts=with_ghosts)
        ENDIF
    ELSE
        ASSOCIATE (prop_to => Pc%props%vec(to_id)%t)
        !Destroy and reallocate the target property data structure
        ! if its type/dimension do not match that of the operator
        IF (      vector_output.AND.prop_to%lda.LT.2 .OR. &
             .NOT.vector_output.AND.prop_to%lda.NE.1 .OR. &
             prop_to%data_type.NE.ppm_type_real) THEN 
                CALL Pc%realloc_prop(to_id,info,with_ghosts=with_ghosts,&
                    datatype=ppm_type_real,lda=lda)
        ENDIF
        !Resize the target property array if its size does not match
        !that of the operators output.
        IF (.NOT.Pc%props%vec(to_id)%t%flags(ppm_ppt_partial).OR. &
            &  with_ghosts .AND. &
            &  .NOT.Pc%props%vec(to_id)%t%flags(ppm_ppt_ghosts)) THEN
            CALL Pc%realloc_prop(to_id,info,with_ghosts=with_ghosts)
        ENDIF
        END ASSOCIATE
    ENDIF
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'ppm_prop_(re)allocate failed',1408,info)
        GOTO 9999
    ENDIF

    !zero the output array
    IF (vector_output) THEN
        CALL Pc%get(dwpv,to_id,with_ghosts=with_ghosts)
        DO ip = 1,np_target
            dwpv(1:lda,ip) = 0._MK
        ENDDO
    ELSE
        CALL Pc%get(dwps,to_id,with_ghosts=with_ghosts)
        DO ip = 1,np_target
            dwps(ip) = 0._MK
        ENDDO
    ENDIF
    eta => Pc%get_dcop(op_id,with_ghosts=with_ghosts)


    IF (isinterp) THEN
        IF (vector_output) THEN
            IF(vector_input) THEN
                CALL Pc2%get(wpv2,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            wpv2(1:lda,iq) * eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc2%set(wpv2,from_id,read_only=.TRUE.)
            ELSE
                CALL Pc2%get(wps2,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            wps2(iq) * eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc2%set(wps2,from_id,read_only=.TRUE.)
            ENDIF
        ELSE
            CALL Pc2%get(wps2,from_id,with_ghosts=.TRUE.)
            DO ip = 1,np_target
                DO ineigh = 1,nvlist(ip)
                    iq = vlist(ineigh,ip)
                    dwps(ip) = dwps(ip) + wps2(iq) * eta(ineigh,ip)
                ENDDO
            ENDDO
            CALL Pc2%set(wps2,from_id,read_only=.TRUE.)
        ENDIF
    ELSE
        sig = -1._mk 
        IF (vector_output) THEN
            IF(vector_input) THEN
                CALL Pc%get(wpv1,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            (wpv1(1:lda,iq) + sig*(wpv1(1:lda,ip)))* &
                            eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc%set(wpv1,from_id,read_only=.TRUE.)
            ELSE
                CALL Pc%get(wps1,from_id,with_ghosts=.TRUE.)
                DO ip = 1,np_target
                    DO ineigh = 1,nvlist(ip)
                        iq = vlist(ineigh,ip)
                        dwpv(1:lda,ip) = dwpv(1:lda,ip) + &
                            (wps1(iq) + sig*(wps1(ip)))* &
                            eta(1+(ineigh-1)*lda:ineigh*lda,ip)
                    ENDDO
                ENDDO
                CALL Pc%set(wps1,from_id,read_only=.TRUE.)
            ENDIF
        ELSE
            CALL Pc%get(wps1,from_id,with_ghosts=.TRUE.)
            DO ip = 1,np_target
                DO ineigh = 1,nvlist(ip)
                    iq = vlist(ineigh,ip)
                    dwps(ip) = dwps(ip) + &
                        (wps1(iq)+sig*(wps1(ip))) * eta(ineigh,ip)
                ENDDO
            ENDDO
            CALL Pc%set(wps1,from_id,read_only=.TRUE.)
        ENDIF
    ENDIF

    eta => Pc%set_dcop(op_id)
    IF (vector_output) THEN
        IF (with_ghosts) THEN
            !we assume that the ghosts are up-to-date even though
            !they clearly are not. we assume you know what you are
            !doing when using this option.
            CALL Pc%set(dwpv,to_id,ghosts_ok=.TRUE.)
        ELSE
            CALL Pc%set(dwpv,to_id)
        ENDIF
    ELSE
        IF (with_ghosts) THEN
            CALL Pc%set(dwps,to_id,ghosts_ok=.TRUE.)
        ELSE
            CALL Pc%set(dwps,to_id)
        ENDIF
    ENDIF
    nvlist => NULL()
    vlist => NULL()

    Pc%stats%nb_dc_apply = Pc%stats%nb_dc_apply + 1
    t2 = MPI_WTIME(info)
    Pc%stats%t_dc_apply = Pc%stats%t_dc_apply+(t2-t1)

    CALL substop(caller,t0,info)

    9999  CONTINUE ! jump here upon error


END SUBROUTINE part_op_apply_d




SUBROUTINE desc_create_d(desc,nterms,coeffs,degree,order,name,info)
    !!! Create a description for a differential operator
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_opdesc_d)            :: desc
    INTEGER,                INTENT(IN   ) :: nterms
    !!! Number of terms in the linear combination
    REAL(MK),DIMENSION(:),  INTENT(IN   ) :: coeffs
    !!! Multiplicative coefficients of each term in the linear combination of
    !!! differential operators
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: degree
    !!! Degree of differentiation of each term
    INTEGER,DIMENSION(:),   INTENT(IN   ) :: order
    !!! Order of approxmiation for each term
    CHARACTER(LEN=*)                      :: name
    !!! name for this operator
    INTEGER,                INTENT(OUT)   :: info
    !!! Returns status, 0 upon success.

    CHARACTER(LEN=ppm_char)               :: caller = 'desc_create'
    REAL(KIND(1.D0))                      :: t0
    
    CALL substart(caller,t0,info)

    !Check arguments
    IF (MINVAL(degree).LT.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &       'invalid degree: must be positive',1562,info)
        GOTO 9999
    ENDIF
    IF (MINVAL(order).LT.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &     'invalid approx order: must be positive',1568,info)
        GOTO 9999
    ENDIF
    IF (SIZE(degree).NE.ppm_dim*nterms) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &     'wrong number of terms in degree argument',1574,info)
        GOTO 9999
    ENDIF
    IF (SIZE(order).NE.nterms) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &      'wrong number of terms in order argument',1580,info)
        GOTO 9999
    ENDIF
    IF (SIZE(coeffs).NE.nterms) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &      'wrong number of terms in coeffs argument',1586,info)
        GOTO 9999
    ENDIF


    !allocate operators descriptors
    ldc(1) = ppm_dim * nterms
    CALL ppm_alloc(desc%degree,ldc,ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &            'failed to allocate ops%desc',1597,info)
        GOTO 9999
    ENDIF
    ldc(1) = nterms
    CALL ppm_alloc(desc%order,ldc,ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &            'failed to allocate ops%desc',1605,info)
        GOTO 9999
    ENDIF
    ldc(1) = nterms
    CALL ppm_alloc(desc%coeffs,ldc,ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &            'failed to allocate ops%desc',1613,info)
        GOTO 9999
    ENDIF
    desc%order = order 
    desc%coeffs = coeffs 
    desc%degree = degree 
    desc%nterms = nterms 
    desc%name = name


    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE desc_create_d

SUBROUTINE desc_destroy_d(desc,info)
    CLASS(ppm_t_opdesc_d)              :: desc
    INTEGER,                 INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    
    IF (ASSOCIATED(desc%degree)) DEALLOCATE(desc%degree,STAT=info)
    IF (ASSOCIATED(desc%order))  DEALLOCATE(desc%order,STAT=info)
    IF (ASSOCIATED(desc%coeffs)) DEALLOCATE(desc%coeffs,STAT=info)

END SUBROUTINE desc_destroy_d

SUBROUTINE part_create_d(Pc,Npart,info,name)

    !!! create a ppm_t_particles data type

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                                INTENT(IN   )  :: Npart
    !!! Number of particles 
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    CHARACTER(LEN=*) , OPTIONAL                            :: name
    !!! give a name to this Particle set
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    LOGICAL                                         :: lalloc,ldealloc
    INTEGER                                         :: i
    REAL(KIND(1.D0))                                :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_create_particles'
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  Destroy the DS if it already exists
    !-----------------------------------------------------------------
    IF (ASSOCIATED(Pc%xp)) THEN
        CALL Pc%destroy(info)
    ENDIF
    !-----------------------------------------------------------------
    !  Allocate memory for the positions
    !-----------------------------------------------------------------
    ldc(1) = ppm_dim
    ldc(2) = Npart
    CALL ppm_alloc(Pc%xp,ldc(1:2),ppm_param_alloc_fit,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,   &
            &        'Could not allocate Particles elements',1695,info)
        GOTO 9999
    ENDIF
    Pc%Npart = Npart
    Pc%Mpart = Npart
    Pc%flags(ppm_part_ghosts) = .FALSE.
    Pc%flags(ppm_part_areinside) = .FALSE.
    Pc%flags(ppm_part_partial) = .FALSE.
    Pc%flags(ppm_part_reqput) = .FALSE.
    Pc%flags(ppm_part_cartesian) = .FALSE.
    Pc%flags(ppm_part_neighlists) = .FALSE.
    Pc%flags(ppm_part_global_index) = .FALSE.
    Pc%active_topoid = -1
    ! No active topology yet

    ! Give a default name to this Particle set
    IF (PRESENT(name)) THEN
        Pc%name = ADJUSTL(TRIM(name))
    ELSE
        Pc%name = particles_dflt_partname()
    ENDIF

    ! Particles have not been initialised yet
    Pc%h_avg = -1._MK
    Pc%h_min = -1._MK

    Pc%time = 0._MK
    Pc%itime = 0

    Pc%gi_id = 0

    SELECT TYPE(Pc)
    CLASS IS (ppm_t_sop_d)
        !-----------------------------------------------------------------
        !  Initialize fields of the extended SOP type
        !-----------------------------------------------------------------
        ! Particles are by default not adaptive
        Pc%adaptive = .FALSE.
        Pc%adapt_wpid = 0
        Pc%rcp_id = 0
        Pc%D_id = 0
        Pc%Dtilde_id = 0
        Pc%nn_sq_id = 0
        ! Particles do not represent a level-set function
        Pc%level_set = .FALSE.
        Pc%level_id = 0
        !        Pc%level_old_id = 0
        Pc%level_grad_id = 0
        !        Pc%level_grad_old_id = 0
        ! Particles are by default isotropic
        Pc%anisotropic = .FALSE.
    CLASS DEFAULT
    END SELECT
    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_create_d


SUBROUTINE part_destroy_d(Pc,info)

    !!! Deallocate a ppm_t_particles data type

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the Pc
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.

    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    LOGICAL                                         :: lalloc,ldealloc
    INTEGER                                         :: i
    REAL(KIND(1.D0))                                :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_destroy_particles'
    TYPE(ppm_t_neighlist_d), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_d),  POINTER :: op => NULL()
    TYPE(ppm_t_part_prop_d), POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-------------------------------------------------------------------------
    !  Check arguments
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  If reallocating, deallocate old data first
    !-------------------------------------------------------------------------
    !----------------------------------------------------------------------
    !  deallocate
    !----------------------------------------------------------------------
    ! first deallocate all content of Pc
    IF (ASSOCIATED(Pc%xp)) THEN 
        DEALLOCATE(Pc%xp,STAT=info)
        NULLIFY(Pc%xp)
    ENDIF
    IF (ASSOCIATED(Pc%pcost)) THEN
        DEALLOCATE(Pc%pcost,STAT=info)
        NULLIFY(Pc%pcost)
    ENDIF

    !Deallocate neighbour lists
    CALL Pc%neighs%destroy(info)

    !Deallocate properties
    CALL Pc%props%destroy(info)

    !Deallocate operators
    CALL Pc%ops%destroy(info)

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_destroy_d

SUBROUTINE particles_initialize2d_d(Pc,Npart_global,info,&
        distrib,topoid,minphys,maxphys,cutoff,name)
    !!!-----------------------------------------------------------------------
    !!! Set initial particle positions
    !!!-----------------------------------------------------------------------
    USE ppm_module_substart
    USE ppm_module_substop
    USE ppm_module_data, ONLY: ppm_rank,ppm_nproc,ppm_topo,ppm_comm
    USE ppm_module_write

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particle cloud
    INTEGER,                             INTENT(INOUT)     :: Npart_global
    !!! total number of particles that will be initialized
    INTEGER,                             INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: distrib
    !!! type of initial distribution. One of
    !!! ppm_param_part_init_cartesian (default)
    !!! ppm_param_part_init_random
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: topoid
    !!! topology id (used only to get the extent of the physical domain)
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: minphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: maxphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),                   OPTIONAL,INTENT(IN   )     :: cutoff
    !!! cutoff of the particles
    CHARACTER(LEN=*),           OPTIONAL,INTENT(IN   )     :: name
    !!! name for this set of particles
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    INTEGER                               :: ip,i,j,k,Npart,iopt
    INTEGER                               :: nijk(ppm_dim),nijk_global(ppm_dim)
    CHARACTER(LEN = ppm_char)             :: filename,cbuf
    CHARACTER(LEN = ppm_char)             :: caller = 'particles_initialize'
    REAL(MK)                              :: y,z,h
    REAL(KIND(1.D0))                      :: t0
    INTEGER                               :: remaining_rows

    REAL(MK)                              :: shift
    INTEGER                               :: distribution,neigh_id
    TYPE(ppm_t_topo),POINTER              :: topo => NULL()
    REAL(MK), DIMENSION(ppm_dim)          :: min_phys,max_phys,len_phys

    REAL(MK), DIMENSION(:,:), POINTER     :: xp
    REAL(MK), DIMENSION(:  ), POINTER     :: randnb


    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    IF(PRESENT(distrib)) THEN
        distribution=distrib
    ELSE
        distribution=ppm_param_part_init_cartesian
    ENDIF

    !Get boundaries of computational domain
    IF (PRESENT(topoid) .AND. (PRESENT(minphys).OR.PRESENT(maxphys))) THEN
            info = ppm_error_error
            CALL ppm_error(999,caller,&
               'probable conflict of optional arguments. Use topoid OR minphys'&
               ,80,info)
            GOTO 9999
    ENDIF
    IF (PRESENT(topoid)) THEN
        topo => ppm_topo(topoid)%t
        IF (MK.EQ.ppm_kind_single) THEN
            min_phys = topo%min_physs
            max_phys = topo%max_physs
        ELSE IF (MK.EQ.ppm_kind_double) THEN
            min_phys = topo%min_physd
            max_phys = topo%max_physd
        ENDIF
    ELSE IF (PRESENT(minphys).AND.PRESENT(maxphys)) THEN
        min_phys = minphys
        max_phys = maxphys
    ELSE
        info = ppm_error_error
        CALL ppm_error(999,caller,&
            'optional arguments needed to define the domain boundaries'&
            ,99,info)
        GOTO 9999
    ENDIF
    len_phys=max_phys-min_phys
    IF (MINVAL(len_phys(1:ppm_dim)).LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Domain length is <= 0 along one dimension. Check input parameters'&
            ,107,info)
        GOTO 9999
    ENDIF


    h = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim))
    nijk_global = FLOOR(len_phys/h)
    Npart_global = PRODUCT(nijk_global)
    remaining_rows = MOD(nijk_global(ppm_dim),ppm_nproc)

    !number of particles along x and z
    nijk(1:ppm_dim) = nijk_global(1:ppm_dim)
    !number of particles along y 
    nijk(2) = nijk_global(ppm_dim)/ppm_nproc

    !number of particles on this processor
    Npart = PRODUCT(nijk)

    !last proc takes care of the additional rows (remainder)
    IF (ppm_rank.EQ.ppm_nproc-1) THEN
        Npart = Npart + remaining_rows * nijk(1)
    ENDIF

    !Deallocate Particles if already allocated
    IF (ASSOCIATED(Pc%xp)) THEN
        CALL Pc%destroy(info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_dealloc,caller,&
                'destroying Particle cloud failed',140,info)
            GOTO 9999
        ENDIF
    ENDIF

    CALL Pc%create(Npart,info,name=name)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'creating Particle cloud failed',149,info)
        GOTO 9999
    ENDIF

    !use a shortcut, for convenience
    xp => Pc%xp

    !-----------------------------------------------------------------------
    ! set particles
    !-----------------------------------------------------------------------
    ip = 0
    shift = 0._MK !shifts positions of the particles. Set to 0.5 to place
    !particles in the middle of each cell, set to 0 to place them in the lower
    !left corner

    if_cartesian: IF (distribution .EQ. ppm_param_part_init_cartesian) THEN
        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2)) + shift*h
            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                xp(2,ip) = y                  

                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)

            ENDDO
        ENDDO

        IF(ppm_rank.EQ.(ppm_nproc-1)) THEN
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                    xp(2,ip) = y                  

                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)

                ENDDO
            ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .TRUE.
    ELSE !random distribution
        iopt = ppm_param_alloc_fit
        ldc(1) = ppm_dim*Npart
        CALL ppm_alloc(randnb,ldc(1:1),iopt,info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,   &
                &            'allocation failed',246,info)
            GOTO 9999
        ENDIF
        IF (.NOT.ASSOCIATED(ppm_particles_seed)) THEN
            CALL RANDOM_SEED(SIZE=ppm_particles_seedsize)
            ldc(1) = ppm_particles_seedsize
            CALL ppm_alloc(ppm_particles_seed,ldc(1:1),iopt,info)
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_alloc,caller,   &
                    &            'allocation failed',256,info)
                GOTO 9999
            ENDIF
            DO i=1,ppm_particles_seedsize
                ppm_particles_seed(i)=i*i*i*i
            ENDDO
            CALL RANDOM_SEED(PUT=ppm_particles_seed)
        ENDIF
        CALL RANDOM_NUMBER(randnb)

        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2))  + shift* h

            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                ! uniformly random in cells
                xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                    randnb(ppm_dim*ip - 1)*h
                xp(2,ip) = y                   + &
                    randnb(ppm_dim*ip    )*h
                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
            ENDDO
        ENDDO
        IF(ppm_rank.EQ.0) THEN
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    ! uniformly random in cells
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                        randnb(ppm_dim*ip - 1)*h
                    xp(2,ip) = y                   + &
                        randnb(ppm_dim*ip    )*h
                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                ENDDO
            ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .FALSE.

        DEALLOCATE(randnb)

    ENDIF if_cartesian

    xp=>NULL()

    ! (global) average interparticle spacing
    Pc%h_avg = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim)) 
    ! min interparticle spacing (not needed now)
    Pc%h_min = -1._MK

    Pc%flags(ppm_part_areinside) = .TRUE.

    ! set cutoff to a default value
    IF (PRESENT(cutoff)) THEN
        Pc%ghostlayer = cutoff
    ELSE
        Pc%ghostlayer = 2.1_MK * Pc%h_avg
    ENDIF

    IF (PRESENT(topoid)) THEN
        Pc%active_topoid = topoid
    ENDIF

    CALL Pc%create_neighlist(neigh_id,info,name='self',&
        skin=0._MK,symmetry=.FALSE.,cutoff=cutoff)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating neighbour list failed',395,info)
        GOTO 9999
    ENDIF
    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE particles_initialize2d_d

SUBROUTINE particles_initialize3d_d(Pc,Npart_global,info,&
        distrib,topoid,minphys,maxphys,cutoff,name)
    !!!-----------------------------------------------------------------------
    !!! Set initial particle positions
    !!!-----------------------------------------------------------------------
    USE ppm_module_substart
    USE ppm_module_substop
    USE ppm_module_data, ONLY: ppm_rank,ppm_nproc,ppm_topo,ppm_comm
    USE ppm_module_write

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particle cloud
    INTEGER,                             INTENT(INOUT)     :: Npart_global
    !!! total number of particles that will be initialized
    INTEGER,                             INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: distrib
    !!! type of initial distribution. One of
    !!! ppm_param_part_init_cartesian (default)
    !!! ppm_param_part_init_random
    INTEGER,OPTIONAL,                    INTENT(IN   )     :: topoid
    !!! topology id (used only to get the extent of the physical domain)
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: minphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: maxphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),                   OPTIONAL,INTENT(IN   )     :: cutoff
    !!! cutoff of the particles
    CHARACTER(LEN=*),           OPTIONAL,INTENT(IN   )     :: name
    !!! name for this set of particles
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    INTEGER                               :: ip,i,j,k,Npart,iopt
    INTEGER                               :: nijk(ppm_dim),nijk_global(ppm_dim)
    CHARACTER(LEN = ppm_char)             :: filename,cbuf
    CHARACTER(LEN = ppm_char)             :: caller = 'particles_initialize'
    REAL(MK)                              :: y,z,h
    REAL(KIND(1.D0))                      :: t0
    INTEGER                               :: remaining_rows

    REAL(MK)                              :: shift
    INTEGER                               :: distribution,neigh_id
    TYPE(ppm_t_topo),POINTER              :: topo => NULL()
    REAL(MK), DIMENSION(ppm_dim)          :: min_phys,max_phys,len_phys

    REAL(MK), DIMENSION(:,:), POINTER     :: xp
    REAL(MK), DIMENSION(:  ), POINTER     :: randnb


    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    IF(PRESENT(distrib)) THEN
        distribution=distrib
    ELSE
        distribution=ppm_param_part_init_cartesian
    ENDIF

    !Get boundaries of computational domain
    IF (PRESENT(topoid) .AND. (PRESENT(minphys).OR.PRESENT(maxphys))) THEN
            info = ppm_error_error
            CALL ppm_error(999,caller,&
               'probable conflict of optional arguments. Use topoid OR minphys'&
               ,80,info)
            GOTO 9999
    ENDIF
    IF (PRESENT(topoid)) THEN
        topo => ppm_topo(topoid)%t
        IF (MK.EQ.ppm_kind_single) THEN
            min_phys = topo%min_physs
            max_phys = topo%max_physs
        ELSE IF (MK.EQ.ppm_kind_double) THEN
            min_phys = topo%min_physd
            max_phys = topo%max_physd
        ENDIF
    ELSE IF (PRESENT(minphys).AND.PRESENT(maxphys)) THEN
        min_phys = minphys
        max_phys = maxphys
    ELSE
        info = ppm_error_error
        CALL ppm_error(999,caller,&
            'optional arguments needed to define the domain boundaries'&
            ,99,info)
        GOTO 9999
    ENDIF
    len_phys=max_phys-min_phys
    IF (MINVAL(len_phys(1:ppm_dim)).LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Domain length is <= 0 along one dimension. Check input parameters'&
            ,107,info)
        GOTO 9999
    ENDIF


    h = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim))
    nijk_global = FLOOR(len_phys/h)
    Npart_global = PRODUCT(nijk_global)
    remaining_rows = MOD(nijk_global(ppm_dim),ppm_nproc)

    !number of particles along x and z
    nijk(1:ppm_dim) = nijk_global(1:ppm_dim)
    !number of particles along y 
    nijk(2) = nijk_global(ppm_dim)/ppm_nproc

    !number of particles on this processor
    Npart = PRODUCT(nijk)

    !last proc takes care of the additional rows (remainder)
    IF (ppm_rank.EQ.ppm_nproc-1) THEN
        Npart = Npart + remaining_rows * nijk(1)*nijk(3)
    ENDIF

    !Deallocate Particles if already allocated
    IF (ASSOCIATED(Pc%xp)) THEN
        CALL Pc%destroy(info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_dealloc,caller,&
                'destroying Particle cloud failed',140,info)
            GOTO 9999
        ENDIF
    ENDIF

    CALL Pc%create(Npart,info,name=name)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,&
            'creating Particle cloud failed',149,info)
        GOTO 9999
    ENDIF

    !use a shortcut, for convenience
    xp => Pc%xp

    !-----------------------------------------------------------------------
    ! set particles
    !-----------------------------------------------------------------------
    ip = 0
    shift = 0._MK !shifts positions of the particles. Set to 0.5 to place
    !particles in the middle of each cell, set to 0 to place them in the lower
    !left corner

    if_cartesian: IF (distribution .EQ. ppm_param_part_init_cartesian) THEN
        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2)) + shift*h
            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                xp(2,ip) = y                  
                xp(3,ip) = z 

                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)

            ENDDO
        ENDDO
        ENDDO

        IF(ppm_rank.EQ.(ppm_nproc-1)) THEN
        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift*h
                    xp(2,ip) = y                  
                    xp(3,ip) = z 

                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                    IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                    IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)

                ENDDO
            ENDDO
        ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .TRUE.
    ELSE !random distribution
        iopt = ppm_param_alloc_fit
        ldc(1) = ppm_dim*Npart
        CALL ppm_alloc(randnb,ldc(1:1),iopt,info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,   &
                &            'allocation failed',246,info)
            GOTO 9999
        ENDIF
        IF (.NOT.ASSOCIATED(ppm_particles_seed)) THEN
            CALL RANDOM_SEED(SIZE=ppm_particles_seedsize)
            ldc(1) = ppm_particles_seedsize
            CALL ppm_alloc(ppm_particles_seed,ldc(1:1),iopt,info)
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_alloc,caller,   &
                    &            'allocation failed',256,info)
                GOTO 9999
            ENDIF
            DO i=1,ppm_particles_seedsize
                ppm_particles_seed(i)=i*i*i*i
            ENDDO
            CALL RANDOM_SEED(PUT=ppm_particles_seed)
        ENDIF
        CALL RANDOM_NUMBER(randnb)

        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
        DO j = 1,nijk(2)
            h = len_phys(2)/REAL(nijk_global(2),MK)
            y = min_phys(2) + h*(j-1 + ppm_rank*nijk(2))  + shift* h

            DO i = 1,nijk(1)
                h = len_phys(1)/REAL(nijk(1),MK)

                ip = ip + 1
                ! uniformly random in cells
                xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                    randnb(ppm_dim*ip - 1)*h
                xp(2,ip) = y                   + &
                    randnb(ppm_dim*ip    )*h
                xp(3,ip) = z                   + &
                    randnb(ppm_dim*ip - 2)*h
                ! impose periodic boundaries:
                IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)
            ENDDO
        ENDDO
        ENDDO
        IF(ppm_rank.EQ.0) THEN
        DO k = 1,nijk(3)
            h = len_phys(3)/REAL(nijk(3),MK)
            z = min_phys(3) + h*(k-1) + shift*h
            DO j = 1,remaining_rows
                h = len_phys(2)/REAL(nijk_global(2),MK)
                y = min_phys(2) + h*(j-1 + ppm_nproc*nijk(2)) + shift*h
                DO i = 1,nijk(1)
                    h = len_phys(1)/REAL(nijk(1),MK)

                    ip = ip + 1
                    ! uniformly random in cells
                    xp(1,ip) = min_phys(1) + h*(i-1) + shift + &
                        randnb(ppm_dim*ip - 1)*h
                    xp(2,ip) = y                   + &
                        randnb(ppm_dim*ip    )*h
                    xp(3,ip) = z                   + &
                        randnb(ppm_dim*ip - 2)*h
                    ! impose periodic boundaries:
                    IF (xp(1,ip) .GE. max_phys(1)) xp(1,ip) = xp(1,ip) - len_phys(1)
                    IF (xp(2,ip) .GE. max_phys(2)) xp(2,ip) = xp(2,ip) - len_phys(2)
                    IF (xp(1,ip) .LT. min_phys(1)) xp(1,ip) = xp(1,ip) + len_phys(1)
                    IF (xp(2,ip) .LT. min_phys(2)) xp(2,ip) = xp(2,ip) + len_phys(2)
                    IF (xp(3,ip) .GE. max_phys(3)) xp(3,ip) = xp(3,ip) - len_phys(3)
                    IF (xp(3,ip) .LT. min_phys(3)) xp(3,ip) = xp(3,ip) + len_phys(3)
                ENDDO
            ENDDO
        ENDDO
        ENDIF
        Pc%flags(ppm_part_cartesian) = .FALSE.

        DEALLOCATE(randnb)

    ENDIF if_cartesian

    xp=>NULL()

    ! (global) average interparticle spacing
    Pc%h_avg = (PRODUCT(len_phys)/REAL(Npart_global))**(1./REAL(ppm_dim)) 
    ! min interparticle spacing (not needed now)
    Pc%h_min = -1._MK

    Pc%flags(ppm_part_areinside) = .TRUE.

    ! set cutoff to a default value
    IF (PRESENT(cutoff)) THEN
        Pc%ghostlayer = cutoff
    ELSE
        Pc%ghostlayer = 2.1_MK * Pc%h_avg
    ENDIF

    IF (PRESENT(topoid)) THEN
        Pc%active_topoid = topoid
    ENDIF

    CALL Pc%create_neighlist(neigh_id,info,name='self',&
        skin=0._MK,symmetry=.FALSE.,cutoff=cutoff)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating neighbour list failed',395,info)
        GOTO 9999
    ENDIF
    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE particles_initialize3d_d


!!temporary hack to deal with both 2d and 3d
SUBROUTINE part_initialize_d(Pc,Npart_global,info,&
        distrib,topoid,minphys,maxphys,cutoff,name)
    !-----------------------------------------------------------------------
    ! Set initial particle positions
    !-----------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                            INTENT(INOUT)      :: Npart_global
    !!! total number of particles that will be initialized
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER,OPTIONAL,                   INTENT(IN   )      :: distrib
    !!! type of initial distribution. One of
    !!! ppm_param_part_init_cartesian (default)
    !!! ppm_param_part_init_random
    INTEGER,OPTIONAL,                   INTENT(IN   )      :: topoid
    !!! topology id (used only to get the extent of the physical domain)
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: minphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),DIMENSION(ppm_dim),OPTIONAL,INTENT(IN   )     :: maxphys
    !!! extent of the physical domain. Only if topoid is not present.
    REAL(MK),                   OPTIONAL,INTENT(IN   )     :: cutoff
    !!! cutoff of the particles
    CHARACTER(LEN=*),           OPTIONAL,INTENT(IN   )     :: name
    !!! name for this set of particles

    IF (ppm_dim.EQ.2) THEN
        CALL  particles_initialize2d_d(Pc,Npart_global,info,&
            distrib,topoid,minphys,maxphys,cutoff,name=name)
    ELSE
        CALL  particles_initialize3d_d(Pc,Npart_global,info,&
            distrib,topoid,minphys,maxphys,cutoff,name=name)
    ENDIF
END SUBROUTINE part_initialize_d

SUBROUTINE part_print_info_d(Pc,info,level,fileunit)
    !-----------------------------------------------------------------------
    ! Print out summary information about this particle cloud
    ! (list of properties, operators, etc...)
    !-----------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: level
    !!! indentation level at which to printout the info. Default = 0
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: fileunit
    !!! Already open file unit for printout. Default = stdout
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                              :: lev,fileu
    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'part_print_info'
    CHARACTER(LEN = ppm_char)            :: myformat
    TYPE(ppm_t_part_prop_d),POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)


    IF (PRESENT(fileunit)) THEN
        fileu = fileunit
    ELSE
        fileu = 6
    ENDIF
    IF (PRESENT(level)) THEN
        lev = MAX(level,1)
    ELSE
        lev = 1
    ENDIF

    WRITE(myformat,'(A,I0,A)') '(',4*lev,'X,A,A,2X,2(A,I0),A)'

    WRITE(fileu,myformat) 'Particle cloud: ',TRIM(color_print(Pc%name,31)),&
       '(N = ',Pc%Npart,' M = ',Pc%Mpart,')'

    lev = lev + 1

    WRITE(myformat,'(A,I0,A,I0,A)') '(',4*lev,'X,A,',&
        ppm_param_length_partflags,'L)'
    WRITE(fileu,myformat) 'flags: ',Pc%flags

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        CALL prop%print_info(info,lev,fileunit,Pc%props%iter_id)
        prop => Pc%props%next()
    ENDDO

    CALL substop(caller,t0,info)

END SUBROUTINE part_print_info_d

SUBROUTINE prop_print_info_d(prop,info,level,fileunit,propid)
    !-----------------------------------------------------------------------
    ! Print out summary information about this property
    !-----------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_part_prop_d)                          :: prop
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: level
    !!! indentation level at which to printout the info. Default = 0
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: fileunit
    !!! Already open file unit for printout. Default = stdout
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: propid
    !!! id of this property in the parent struct
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                              :: lev,fileu,id
    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'prop_print_info'
    CHARACTER(LEN = ppm_char)            :: myformat
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)


    IF (PRESENT(fileunit)) THEN
        fileu = fileunit
    ELSE
        fileu = 6
    ENDIF
    IF (PRESENT(level)) THEN
        lev = MAX(level,1)
    ELSE
        lev = 1
    ENDIF
    IF (PRESENT(propid)) THEN
        id = propid
    ELSE
        id = 1
    ENDIF

    WRITE(myformat,'(A,I0,A)') '(',4*lev,'X,A,I0,A,A,A,I0)'

    WRITE(fileu,myformat) 'Property ',id,': ',TRIM(color_print(prop%name,33)),&
        ' Type: ',prop%data_type

    lev = lev + 1

    WRITE(myformat,'(A,I0,A)') '(',4*lev,'X,A,I0)'
    WRITE(fileu,myformat) 'lda: ',prop%lda

    WRITE(myformat,'(A,I0,A,I0,A)') '(',4*lev,'X,A,',&
        ppm_param_length_pptflags,'L)'
    WRITE(fileu,myformat) 'flags: ',prop%flags


    CALL substop(caller,t0,info)

END SUBROUTINE prop_print_info_d

SUBROUTINE part_del_parts_d(Pc,list_del_parts,nb_del,info)

    !!! remove some particles from a particle cloud
    !!! WARNING: this implementation is NOT efficient
    !!! if the number of particles to delete is large.

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,DIMENSION(:),POINTER,           INTENT(IN   )  :: list_del_parts
    !!! list of particles to be deleted
    INTEGER,                                INTENT(IN   )  :: nb_del
    !!! number of particles to be deleted
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    INTEGER                              :: i,ip,Npart,del_part,lda
    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_del_particles'
    TYPE(ppm_t_part_prop_d),POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  check arguments
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Pc structure had not been defined. Call allocate first',&
            &  2059,info)
        GOTO 9999
    ENDIF

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        IF (.NOT.prop%flags(ppm_ppt_partial)) THEN
            IF (prop%flags(ppm_ppt_map_parts)) THEN
                info = ppm_error_error
                CALL ppm_error(999,caller,   &
                    & 'property not mapped, data will be lost',&
                    &  2070,info)
                GOTO 9999
            ENDIF
        ENDIF
        prop => Pc%props%next()
    ENDDO

    !-----------------------------------------------------------------
    !  Delete particles
    !-----------------------------------------------------------------
    Npart = Pc%Npart

    del_part = 1

    DO i=1,nb_del
        ip = list_del_parts(i)

        ! copying particles from the end of xp to the index that has
        ! to be removed
        Pc%xp(1:ppm_dim,ip) = Pc%xp(1:ppm_dim,Npart-i+1)

        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_partial)) THEN

                    lda = prop%lda

                    IF (lda.GE.2) THEN
                        SELECT CASE (prop%data_type)
                        CASE (ppm_type_int)
                            prop%data_2d_i(1:lda,ip) = &
                                prop%data_2d_i(1:lda,Npart-i+1)
                        CASE (ppm_type_longint)
                            prop%data_2d_li(1:lda,ip) = &
                                prop%data_2d_li(1:lda,Npart-i+1)
                        CASE (ppm_type_real)
                            prop%data_2d_r(1:lda,ip) = &
                                prop%data_2d_r(1:lda,Npart-i+1)
                        CASE (ppm_type_comp)
                            prop%data_2d_c(1:lda,ip) = &
                                prop%data_2d_c(1:lda,Npart-i+1)
                        CASE (ppm_type_logical )
                            prop%data_2d_l(1:lda,ip) = &
                                prop%data_2d_l(1:lda,Npart-i+1)
                        END SELECT

                    ELSE
                        SELECT CASE (prop%data_type)
                        CASE (ppm_type_int)
                            prop%data_1d_i(ip) = &
                                prop%data_1d_i(Npart-i+1)
                        CASE (ppm_type_longint)
                            prop%data_1d_li(ip) = &
                                prop%data_1d_li(Npart-i+1)
                        CASE (ppm_type_real)
                            prop%data_1d_r(ip) = &
                                prop%data_1d_r(Npart-i+1)
                        CASE (ppm_type_comp)
                            prop%data_1d_c(ip) = &
                                prop%data_1d_c(Npart-i+1)
                        CASE (ppm_type_logical )
                            prop%data_1d_l(ip) = &
                                prop%data_1d_l(Npart-i+1)
                        END SELECT
                    ENDIF
                prop => Pc%props%next()
            ENDIF
        ENDDO
    ENDDO
    !New number of particles, after deleting some
    Pc%Npart = Npart - del_part

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_del_parts_d

SUBROUTINE part_prop_push_d(Pc,prop_id,info)

    !!! wrapper for ppm_map_part_push

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------
    USE ppm_module_map

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                                INTENT(IN   )  :: prop_id
    !!! id of the property to be pushed
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'map_part_push'
    INTEGER                              :: lda
    TYPE(ppm_t_part_prop_d),POINTER :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  Check arguments
    !-----------------------------------------------------------------

    !-----------------------------------------------------------------
    !  Call ppm_map_part_push
    !-----------------------------------------------------------------
    prop => Pc%props%vec(prop_id)%t
    lda = prop%lda

    IF (lda.GE.2) THEN
        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_push(&
            prop%data_2d_i,lda,Pc%Npart,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2209,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_push(&
            prop%data_2d_r,lda,Pc%Npart,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_push(&
            prop%data_2d_c,lda,Pc%Npart,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_push(&
            prop%data_2d_l,lda,Pc%Npart,info)
        END SELECT

    ELSE

        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_push(&
            prop%data_1d_i,Pc%Npart,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2232,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_push(&
            prop%data_1d_r,Pc%Npart,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_push(&
            prop%data_1d_c,Pc%Npart,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_push(&
            prop%data_1d_l,Pc%Npart,info)
        END SELECT
    ENDIF

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_prop_push_d

SUBROUTINE part_prop_pop_d(Pc,prop_id,Npart_new,info)

    !!! wrapper for ppm_map_part_pop

    !-------------------------------------------------------------------------
    !  Includes
    !-------------------------------------------------------------------------

    !-------------------------------------------------------------------------
    !  Modules
    !-------------------------------------------------------------------------
    USE ppm_module_map

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                          :: Pc
    !!! Data structure containing the particles
    INTEGER,                                INTENT(IN   )  :: prop_id
    !!! id of the property to be pushed
    INTEGER,                                INTENT(IN   )  :: Npart_new
    !!! number of particles to pop from the buffer
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------

    REAL(KIND(1.D0))                     :: t0
    CHARACTER(LEN = ppm_char)            :: caller = 'map_part_push'
    INTEGER                              :: lda
    TYPE(ppm_t_part_prop_d),POINTER :: prop
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-----------------------------------------------------------------
    !  Check arguments
    !-----------------------------------------------------------------

    !-----------------------------------------------------------------
    !  Call ppm_map_part_pop
    !-----------------------------------------------------------------
    prop => Pc%props%vec(prop_id)%t
    lda = prop%lda

    IF (lda.GE.2) THEN
        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_pop(&
            prop%data_2d_i,lda,Pc%Npart,Npart_new,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2315,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_pop(&
            prop%data_2d_r,lda,Pc%Npart,Npart_new,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_pop(&
            prop%data_2d_c,lda,Pc%Npart,Npart_new,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_pop(&
            prop%data_2d_l,lda,Pc%Npart,Npart_new,info)
        END SELECT

    ELSE

        SELECT CASE (prop%data_type)
        CASE (ppm_type_int)
            CALL ppm_map_part_pop(&
            prop%data_1d_i,Pc%Npart,Npart_new,info)
        CASE (ppm_type_longint)
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'Type not supported for mappings.',&
                &  2338,info)
            GOTO 9999
        CASE (ppm_type_real)
            CALL ppm_map_part_pop(&
            prop%data_1d_r,Pc%Npart,Npart_new,info)
        CASE (ppm_type_comp)
            CALL ppm_map_part_pop(&
            prop%data_1d_c,Pc%Npart,Npart_new,info)
        CASE (ppm_type_logical )
            CALL ppm_map_part_pop(&
            prop%data_1d_l,Pc%Npart,Npart_new,info)
        END SELECT
    ENDIF

    !-------------------------------------------------------------------------
    !  Finalize
    !-------------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE

END SUBROUTINE part_prop_pop_d


FUNCTION get_dcop_d(Pc,eta_id,with_ghosts)
    CLASS(ppm_t_particles_d)      :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_double
    INTEGER                            :: eta_id
    REAL(MK),DIMENSION(:,:),POINTER    :: get_dcop_d
    LOGICAL,OPTIONAL                   :: with_ghosts

    IF (eta_id .LE. 0 .OR. eta_id .GT. Pc%ops%max_id) THEN
        write(*,*) 'ERROR: failed to get operator for id ',eta_id
        get_dcop_d => NULL()
        RETURN
    ENDIF

    IF (PRESENT(with_ghosts)) THEN
        IF (with_ghosts) THEN
            get_dcop_d => &
                Pc%ops%vec(eta_id)%t%ker(:,1:Pc%Mpart)
            RETURN
        ENDIF
    ENDIF
    get_dcop_d => &
        Pc%ops%vec(eta_id)%t%ker(:,1:Pc%Npart)

END FUNCTION get_dcop_d

FUNCTION set_dcop_d(Pc,eta_id)
    CLASS(ppm_t_particles_d)   :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_double
    INTEGER                         :: eta_id
    REAL(MK),DIMENSION(:,:),POINTER :: set_dcop_d

    set_dcop_d => NULL()

END FUNCTION set_dcop_d

SUBROUTINE part_mapping_d(Pc,info,debug,global,topoid)

    !!!  Partial/Global mapping for particles
    !!!  Assumptions:
    !!! * All the particles have to be inside the domain
    !!!   (otherwise -> "unassigned particle error")

    USE ppm_module_map
    USE ppm_module_data, ONLY: ppm_comm
    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_d)                          :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_double
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional Arguments
    !-------------------------------------------------------------------------
    LOGICAL, OPTIONAL                                   :: debug
    !!! IF true, printout more
    LOGICAL, OPTIONAL                                   :: global
    !!! does a global mapping. Default is false (i.e. partial mapping)
    INTEGER, OPTIONAL                                   :: topoid
    !!! topology id
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                   :: Npart_new
    !!! new number of particles on this processor
    INTEGER                   :: ltopoid
    !!! index variable
    CHARACTER(LEN = ppm_char) :: caller = 'particles_mapping'
    REAL(KIND(1.D0))          :: t0,t1,t2
    LOGICAL                   :: dbg,partial
    TYPE(ppm_t_part_prop_d), POINTER :: prop => NULL()
    TYPE(ppm_t_neighlist_d), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_d),  POINTER :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    t1 = MPI_WTIME(info)
    dbg = .FALSE.
    IF (PRESENT(debug)) dbg = debug
    !-----------------------------------------------------------------
    !  Checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Pc structure had not been defined. Call allocate first',&
            &  2456,info)
        GOTO 9999
    ENDIF
    IF (.NOT.Pc%flags(ppm_part_areinside)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'some Pc may be outside the domain. Apply BC first',&
            &  2463,info)
        GOTO 9999
    ENDIF

    IF (PRESENT(global)) THEN
        IF(.NOT.PRESENT(topoid)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'need the topoid parameter for global mapping',&
                &  2472,info)
            GOTO 9999
        ENDIF
        IF (global) partial = .FALSE.
    ELSE
        partial = .TRUE.
    ENDIF

    IF (partial) THEN
        ltopoid = Pc%active_topoid
    ELSE
        ltopoid = topoid
    ENDIF

    !-----------------------------------------------------------------------
    !  Map the particles onto the topology
    !-----------------------------------------------------------------------
    IF (partial .AND. Pc%flags(ppm_part_partial)) THEN
        !Particles have already been mapped onto this topology
        !nothing to do
    ELSE
        t1 = MPI_WTIME(info)
        IF (partial) THEN
            CALL ppm_map_part_partial(ltopoid,Pc%xp,Pc%Npart,info) 
            Pc%stats%nb_part_map = Pc%stats%nb_part_map + 1
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(999,caller,&
                    'ppm_map_part_partial failed',2502,info)
                GOTO 9999
            ENDIF
        ELSE
            CALL ppm_map_part_global(ltopoid,Pc%xp,Pc%Npart,info) 
            Pc%stats%nb_global_map = Pc%stats%nb_global_map + 1
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(999,caller,&
                    'ppm_map_part_global failed',2511,info)
                GOTO 9999
            ENDIF
        ENDIF

        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_map_parts)) THEN
                IF(dbg) &
                    write(*,*) 'pushing property ',Pc%props%iter_id
                CALL Pc%map_part_push_legacy(Pc%props%iter_id,info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(999,caller,&
                        'ppm_map_part_prop_push failed',2525,info)
                    GOTO 9999
                ENDIF
            ENDIF
            prop => Pc%props%next()
        ENDDO

        CALL ppm_map_part_send(Pc%Npart,Npart_new,info)
        IF (info .NE. 0) THEN
            CALL ppm_error(0,caller,&
                'ppm_map_part_send failed',2535,info)
            GOTO 9999
        ENDIF

        prop => Pc%props%last()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_map_parts)) THEN
                IF(dbg) &
                    write(*,*) 'poping property ',Pc%props%iter_id
                CALL Pc%map_part_pop_legacy(Pc%props%iter_id,Npart_new,info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(999,caller,&
                        'ppm_map_part_prop_pop failed',2548,info)
                    GOTO 9999
                ENDIF
                prop%flags(ppm_ppt_partial) = .TRUE.
            ENDIF
            prop => Pc%props%prev()
        ENDDO

        IF(dbg) &
            write(*,*) 'popping xp'
        CALL ppm_map_part_pop(Pc%xp,ppm_dim,Pc%Npart,Npart_new,info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(999,caller,&
                'ppm_map_part_pop failed',2562,info)
            GOTO 9999
        ENDIF

        ! Update states
        ! Number of particles on this processor
        Pc%Npart = Npart_new
        Pc%Mpart = Pc%Npart

        ! This is the active topology for these particles
        IF (.NOT.partial) Pc%active_topoid = topoid

        ! Particles are now mapped on the active topology
        Pc%flags(ppm_part_partial) = .TRUE.
        ! Pc have been re-indexed and ghosts have not been computed
        Pc%flags(ppm_part_ghosts) = .FALSE.

        !   values for poperty arrays have been mapped and ghosts
        !   are no longer up-to-date
        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            prop%flags(ppm_ppt_ghosts) = .FALSE.
            prop => Pc%props%next()
        ENDDO

        ! particles have been re-indexed and neighbour lists not updated
        nl => Pc%neighs%begin()
        DO WHILE (ASSOCIATED(nl))
            nl%uptodate = .FALSE.
            nl => Pc%neighs%next()
        ENDDO
        Pc%flags(ppm_part_neighlists) = .FALSE.

        ! particles have been re-indexed and operators need be recomputed
        op => Pc%ops%begin()
        DO WHILE (ASSOCIATED(op))
            op%flags(ppm_ops_iscomputed) = .FALSE.
            op => Pc%ops%next()
        ENDDO

    ENDIF

    t2 = MPI_WTIME(info)
    IF (partial) THEN
        Pc%stats%t_part_map = Pc%stats%t_part_map + (t2-t1)
    ELSE
        Pc%stats%t_global_map = Pc%stats%t_global_map + (t2-t1)
    ENDIF

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_mapping_d

SUBROUTINE part_mapping_ghosts_d(Pc,info,ghostsize,debug)

    !!!  Ghost mapping for particles
    !!!  Assumptions:
    !!! * Particles positions need to have been mapped onto the topology
    !!!
    USE ppm_module_data, ONLY: ppm_topo
    USE ppm_module_map
    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_d)                       :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_double
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)   :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional Arguments
    !-------------------------------------------------------------------------
    REAL(MK), OPTIONAL                                  :: ghostsize
    !!! size of the ghost layers. Default is to use the particles cutoff
    LOGICAL, OPTIONAL                                   :: debug
    !!! IF true, printout more
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                                   :: topoid
    !!! index variable
    REAL(MK)                                  :: cutoff
    !!! cutoff radius
    TYPE(ppm_t_topo),POINTER                  :: topo => NULL()
    CHARACTER(LEN = ppm_char) :: caller = 'particles_mapping_ghosts'
    REAL(KIND(1.D0))                          :: t0,t1,t2
    LOGICAL                                   :: dbg
    LOGICAL                                   :: skip_ghost_get
    LOGICAL                                   :: skip_send
    TYPE(ppm_t_part_prop_d), POINTER :: prop => NULL()
    TYPE(ppm_t_neighlist_d), POINTER :: nl => NULL()
    TYPE(ppm_t_operator_d),  POINTER :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    dbg = .FALSE.
    IF (PRESENT(debug)) dbg=debug
    skip_ghost_get = .FALSE.
    skip_send = .TRUE.
    !we must not call ppm_map_part_send unless ppm_map_part_push (or ghost_get)
    ! has been called (in which case, skip_send is set to FALSE)

    !-----------------------------------------------------------------
    !  Checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  2683,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%flags(ppm_part_partial)) THEN
        !Particles have not been mapped onto this topology
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Do a partial/global mapping before doing a ghost mapping',&
            &  2692,info)
        GOTO 9999
    ENDIF
    IF (.NOT.Pc%flags(ppm_part_areinside)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'some particles may be outside the domain. Apply BC first',&
            &  2699,info)
        GOTO 9999
    ENDIF


    topoid = Pc%active_topoid
    topo=>ppm_topo(topoid)%t

    cutoff = Pc%ghostlayer
    IF (PRESENT(ghostsize)) THEN
        IF (ghostsize .LT. cutoff) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'using ghostsize < cutoff+skin. Increase ghostsize.',&
                &  2713,info)
            GOTO 9999
        ELSE
            cutoff = ghostsize
        ENDIF
    ENDIF

    IF (cutoff .GT. topo%ghostsized) THEN

        write(*,*) 'cutoff = ',cutoff
        write(*,*) 'cutoff used to create topology = ',topo%ghostsized

        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'ghostsize of topology may be smaller than that of particles',&
            &  2737,info)
        GOTO 9999
    ENDIF
    IF (cutoff .GT. 0._MK) THEN
        IF (Pc%flags(ppm_part_ghosts)) THEN
            IF (dbg) THEN
                write(*,*) 'ghosts have already been updated'
            ENDIF

            IF (ppm_map_type_isactive(ppm_param_map_ghost_get)) THEN
                IF (dbg) THEN
                    write(*,*) 'we skip the ghost_get and go straight to'
                    write(*,*) 'push/send/pop'
                ENDIF
                skip_ghost_get = .TRUE.
            ENDIF
        ENDIF

        IF (.NOT.skip_ghost_get) THEN
            Pc%stats%nb_ghost_get = Pc%stats%nb_ghost_get + 1
            t1 = MPI_WTIME(info)
            IF(dbg) &
                write(*,*) 'ghost-get '
            CALL ppm_map_part_ghost_get(topoid,Pc%xp,ppm_dim,&
                Pc%Npart,Pc%isymm,cutoff,info)
            IF (info .NE. 0) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_sub_failed,caller,&
                    'ppm_map_part_ghost_get failed',2768,info)
                GOTO 9999
            ENDIF
            t2 = MPI_WTIME(info)
            Pc%stats%t_ghost_get = Pc%stats%t_ghost_get + (t2-t1)
            skip_send = .FALSE.
        ELSE
            IF(dbg) &
                write(*,*) 'skipping ghost-get '
        ENDIF

        !Update the ghost for the properties if
        ! 1) they have been mapped to this topology,
        ! 2) the ghosts have not yet been updated, and
        ! 3) the user wants them to be updated
        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))

            IF (prop%flags(ppm_ppt_map_ghosts)) THEN
                IF (.NOT.prop%flags(ppm_ppt_ghosts)) THEN
                    IF (prop%flags(ppm_ppt_partial)) THEN

                        IF(dbg) &
                            write(*,*) 'pushing property ',Pc%props%iter_id,&
                            TRIM(prop%name)
                        Pc%stats%nb_ghost_push = &
                            Pc%stats%nb_ghost_push + 1
                        t1 = MPI_WTIME(info)
                        CALL Pc%map_part_push_legacy(Pc%props%iter_id,info)
                        IF (info .NE. 0) THEN
                            info = ppm_error_error
                            CALL ppm_error(ppm_err_sub_failed,caller,&
                                'ppm_map_part_push failed',2804,info)
                            GOTO 9999
                        ENDIF
                        t2 = MPI_WTIME(info)
                        Pc%stats%t_ghost_push = &
                            Pc%stats%t_ghost_push + (t2-t1)
                        skip_send = .FALSE.
                    ELSE
                        write(*,*) 'pushing property ',Pc%props%iter_id,TRIM(prop%name)
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_argument,caller,&
                            'getting ghosts for a property thats not mapped',&
                            2818,info)
                        GOTO 9999
                    ENDIF
                ENDIF
            ENDIF
            prop => Pc%props%next()
        ENDDO

        IF (.NOT. skip_send) THEN
            CALL ppm_map_part_send(Pc%Npart,Pc%Mpart,info)
            IF (info .NE. 0) THEN
                write(*,*) 'ppm_map_part_send failed with info = ',info
                info = ppm_error_error
                CALL ppm_error(ppm_err_sub_failed,caller,&
                    'ppm_map_part_send failed',2832,info)
                GOTO 9999
            ENDIF

            prop => Pc%props%last()
            DO WHILE (ASSOCIATED(prop))

                IF (prop%flags(ppm_ppt_map_ghosts)) THEN
                    IF (.NOT.prop%flags(ppm_ppt_ghosts)) THEN
                        IF (prop%flags(ppm_ppt_partial)) THEN

                            IF(dbg) &
                                write(*,*) 'popping property ',Pc%props%iter_id,&
                                TRIM(prop%name)
                            CALL Pc%map_part_pop_legacy(Pc%props%iter_id,Pc%Mpart,info)
                            IF (info .NE. 0) THEN
                                write(*,*) 'popping property ',Pc%props%iter_id,&
                                    TRIM(prop%name)
                                info = ppm_error_error
                                CALL ppm_error(ppm_err_sub_failed,caller,&
                                    'ppm_map_part_pop failed',2852,info)
                                GOTO 9999
                            ENDIF
                            prop%flags(ppm_ppt_ghosts) = .TRUE.
                        ENDIF
                    ENDIF
                ENDIF
                prop => Pc%props%prev()
            ENDDO

            IF (.NOT.skip_ghost_get) THEN
                IF(dbg) &
                    write(*,*) 'popping-xp '
                CALL ppm_map_part_pop(Pc%xp,ppm_dim,Pc%Npart,&
                    Pc%Mpart,info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_sub_failed,caller,&
                        'ppm_map_part_pop failed',2870,info)
                    GOTO 9999
                ENDIF
            ENDIF
        ENDIF !.NOT.skip_send

    ELSE ! if cutoff.LE.0

        IF(dbg) THEN
            write(*,*) 'cutoff = 0, nothing to do'
            write(*,*) 'setting all %has_ghost properties to true'
        ENDIF

        prop => Pc%props%begin()
        DO WHILE (ASSOCIATED(prop))
            IF (prop%flags(ppm_ppt_map_ghosts)) THEN
                prop%flags(ppm_ppt_ghosts) = .TRUE.
            ENDIF
            prop => Pc%props%next()
        ENDDO
    ENDIF


    ! Update states
    !   ghosts have been computed
    Pc%flags(ppm_part_ghosts) = .TRUE.
    ! the states for the properties have already been updated above

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_mapping_ghosts_d

SUBROUTINE part_apply_bc_d(Pc,info)

    !!!  Apply boundary conditions for particles positions
    !!!  Assumptions:
    !!! * Particles positions need to have been mapped onto the topology

    USE ppm_module_data, ONLY: ppm_topo,ppm_rank

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_d)                         :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_double
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    REAL(MK), DIMENSION(:,:),POINTER                      :: xp => NULL()
    !!! pointer to positions
    TYPE(ppm_t_topo),POINTER                              :: topo => NULL()
    !!! pointer to topology
    REAL(MK), DIMENSION(ppm_dim)                          :: min_phys,max_phys
    !!! computational domain corners
    REAL(MK), DIMENSION(ppm_dim)                          :: len_phys
    !!! length of the computational domain
    INTEGER                                               :: di,ip
    INTEGER                                               :: topoid
    INTEGER                                               :: Npart,del_part
    INTEGER,DIMENSION(:),POINTER                          :: list_del_parts
    REAL(ppm_kind_double)                                 :: t0
    CHARACTER(LEN = ppm_char)                   :: caller = 'particles_apply_bc'
    REAL(MK)                                              :: almostone
    TYPE(ppm_t_part_prop_d),POINTER                  :: prop => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    !-----------------------------------------------------------------
    !  checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  2953,info)
        GOTO 9999
    ENDIF

    topoid = Pc%active_topoid
    topo=>ppm_topo(topoid)%t
    xp=>Pc%xp
    Npart = Pc%Npart
    almostone = 1._MK - EPSILON(1._MK)

    !-----------------------------------------------------------------
    !  Move particles if needed
    !-----------------------------------------------------------------
    min_phys = topo%min_physd
    max_phys = topo%max_physd
    len_phys=max_phys-min_phys

    del_part = 0
    DO di=1,ppm_dim
        IF (topo%bcdef(di) .EQ. ppm_param_bcdef_periodic) THEN
            DO ip=1,Npart
                IF (xp(di,ip) .EQ. max_phys(di)) &
                    xp(di,ip) = xp(di,ip) - len_phys(di)*almostone
                IF (xp(di,ip) .GT. max_phys(di)) &
                    xp(di,ip) = xp(di,ip) - len_phys(di)
                IF (xp(di,ip) .LT. min_phys(di)) &
                    xp(di,ip) = xp(di,ip) + len_phys(di)
            ENDDO
        ELSE IF (topo%bcdef(di) .EQ. ppm_param_bcdef_freespace) THEN
            !delete particles that have crossed the boundary
            DO ip=Npart,1,-1
                IF (xp(di,ip).GE.max_phys(di).OR.xp(di,ip).LT.min_phys(di)) THEN
                    del_part = del_part+1
                ENDIF
            ENDDO
        ELSE
            info = ppm_error_error
            CALL ppm_error(999,caller,   &
                & 'this type of BC is not implemented/tested in this version',&
                &  2997,info)
            GOTO 9999
        ENDIF
    ENDDO

    IF (del_part .GT. 0 ) THEN
        ldc(1) = del_part
        CALL ppm_alloc(list_del_parts,ldc,ppm_param_alloc_fit,info)
        del_part = 0
        DO di=1,ppm_dim
            IF (topo%bcdef(di) .EQ. ppm_param_bcdef_freespace) THEN
                DO ip=Npart,1,-1
                    IF (xp(di,ip).GE.max_phys(di).OR.xp(di,ip).LT.min_phys(di)) THEN
                        del_part = del_part+1
                        list_del_parts(del_part)=ip
                    ENDIF
                ENDDO
            ENDIF
        ENDDO
        CALL Pc%del_parts(list_del_parts,del_part,info)
        IF (info.NE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_sub_failed,caller,   &
                & 'could not delete particles',&
                &  3021,info)
            GOTO 9999
        ENDIF
        DEALLOCATE(list_del_parts)
    ENDIF

    ! Update states
    Pc%Npart = Npart
    ! Particles are no longer on the right processors
    Pc%flags(ppm_part_partial) = .FALSE.
    ! But they are now all inside the computational domain
    Pc%flags(ppm_part_areinside) = .TRUE.
    ! Dangereous to use the ghosts
    Pc%flags(ppm_part_ghosts) = .FALSE.
    ! ghosts values for properties are also dangerous to use
    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        prop%flags(ppm_ppt_ghosts) = .FALSE.
        prop => Pc%props%next()
    ENDDO


    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    xp => NULL()
    topo => NULL()
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_apply_bc_d

SUBROUTINE part_move_d(Pc,disp,info)

    !!!  Move all particles according to some displacement field
    !!!  The size of disp must match the size of xp

    USE ppm_module_data, ONLY: ppm_topo,ppm_rank

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)                         :: Pc
    !!! Data structure containing the particles
    REAL(MK), DIMENSION(:,:), POINTER,  INTENT(IN   )     :: disp
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)     :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    REAL(ppm_kind_double)                                 :: t0
    INTEGER                                               :: ip
    CHARACTER(LEN = ppm_char)                 :: caller ='particles_move'
    REAL(MK),DIMENSION(:,:),POINTER                       :: xp=>NULL()
    TYPE(ppm_t_part_prop_d),POINTER                  :: prop => NULL()
    TYPE(ppm_t_operator_d), POINTER                  :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    !-----------------------------------------------------------------
    !  checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(999,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  3091,info)
        GOTO 9999
    ENDIF


    CALL Pc%get_xp(xp)
    FORALL (ip=1:Pc%Npart) &
            xp(1:ppm_dim,ip) = xp(1:ppm_dim,ip) + disp(1:ppm_dim,ip)
    CALL Pc%set_xp(xp)

    !-----------------------------------------------------------------
    !  update states
    !-----------------------------------------------------------------
    Pc%flags(ppm_part_ghosts) = .FALSE.

    prop => Pc%props%begin()
    DO WHILE (ASSOCIATED(prop))
        prop%flags(ppm_ppt_ghosts) = .FALSE.
        prop => Pc%props%next()
    ENDDO

    op => Pc%ops%begin()
    DO WHILE (ASSOCIATED(op))
        op%flags(ppm_ops_iscomputed) = .FALSE.
        op => Pc%ops%next()
    ENDDO

    Pc%flags(ppm_part_partial) = .FALSE.
    Pc%flags(ppm_part_cartesian) = .FALSE.

    !-----------------------------------------------------------------
    !  Finalize
    !-----------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_move_d

SUBROUTINE part_neighlist_d(Pc,info,&
        nlid,lstore,incl_ghosts,knn)
    !-----------------------------------------------------------------
    !  Neighbor lists for particles
    !-----------------------------------------------------------------
    !  Assumptions:
    ! * Particles positions need to have been mapped onto the topology
    ! * Ghost positions have been computed
    !
    USE ppm_module_neighlist
    USE ppm_module_inl_vlist
    
    INCLUDE "mpif.h"

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(ppm_t_particles_d)                          :: Pc
    INTEGER, PARAMETER :: MK = ppm_kind_double
    !!! Data structure containing the particles
    INTEGER,                            INTENT(  OUT)      :: info
    !!! Return status, on success 0.
    !-------------------------------------------------------------------------
    !  Optional arguments
    !-------------------------------------------------------------------------
    INTEGER, OPTIONAL,                  INTENT(INOUT)      :: nlid
    !!! which neighbour list are we computing. Default is 1
    LOGICAL, OPTIONAL,                  INTENT(IN   )      :: lstore
    !!! store verlet lists
    LOGICAL, OPTIONAL,                  INTENT(IN   )      :: incl_ghosts
    !!! if true, then verlet lists are computed for all particles, incl. ghosts.
    !!! Default is false.
    INTEGER, OPTIONAL,                  INTENT(IN   )      :: knn
    !!! if present, neighbour lists are constructed such that each particle
    !!! has at least knn neighbours.
    !-------------------------------------------------------------------------
    !  Local variables
    !-------------------------------------------------------------------------
    INTEGER                                   :: op_id,np_target,i
    INTEGER                                   :: ip,ineigh
    !!! index variable
    LOGICAL                                   :: symmetry
    !!! backward compatibility
    LOGICAL                                   :: ensure_knn
    !!! uses a neighbour-finding algorithm that finds enough neighbours
    REAL(MK),DIMENSION(2*ppm_dim):: ghostlayer
    !!!
    CHARACTER(LEN = ppm_char)                 :: caller = 'part_comp_neighlist'
    REAL(KIND(1.D0))                          :: t0,t1,t2
    TYPE(ppm_t_topo), POINTER                 :: topo
    INTEGER                                   :: neigh_id,topoid
    INTEGER                                   :: nneighmin,nneighmax
    TYPE(ppm_t_neighlist_d), POINTER      :: Nlist
    REAL(MK)                                  :: skin

    REAL(MK),DIMENSION(:),POINTER             :: rcp  => NULL()
    TYPE(ppm_t_operator_d), POINTER      :: op => NULL()
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)
    !-----------------------------------------------------------------
    !  Checks
    !-----------------------------------------------------------------
    IF (.NOT.ASSOCIATED(Pc%xp)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Particles structure had not been defined. Call allocate first',&
            &  3211,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%flags(ppm_part_partial)) THEN
        !Particles have not been mapped onto this topology
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Do a partial/global mapping before',&
            &  3220,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%flags(ppm_part_ghosts)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'Ghosts have not been updated. They are needed for neighlists',&
            &  3228,info)
        GOTO 9999
    ENDIF

    IF (Pc%neighs%vec_size.LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighlist DS not allocated. Call create_neighlist() first',&
            &  3236,info)
        GOTO 9999
    ENDIF

    !checks that the data structure for the neighbour list has been
    !defined already
    IF (PRESENT(nlid)) THEN
        neigh_id = nlid
        IF (.NOT. Pc%neighs%exists(neigh_id)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'invalid id for neighbour list.',&
                &  3248,info)
            GOTO 9999
        ENDIF
    ELSE
        neigh_id = 1
        IF (Pc%neighs%vec(neigh_id)%t%P_id.NE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
        &  'We assumed default neighlist, but the P_id is not default',&
                &  3257,info)
            GOTO 9999
        ENDIF
    ENDIF

    !define an alias for the neighbour list DS
    Nlist => Pc%neighs%vec(neigh_id)%t
    IF (.NOT.ASSOCIATED(Nlist)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour list not allocated. ',&
            &  3268,info)
        GOTO 9999
    ENDIF

    !check that we have a cutoff radius
    SELECT TYPE (Pc)
    CLASS IS (ppm_t_sop_d)
        IF (Pc%rcp_id.LE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'cutoff radii for adaptive particles have not been defined',&
                &  3279,info)
            GOTO 9999
        ENDIF
        CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=.TRUE.)
        IF (.NOT.ASSOCIATED(rcp)) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
                &  'DS for cutoff radii is not associated',&
                &  3287,info)
            GOTO 9999
        ENDIF
    CLASS DEFAULT
        IF (Nlist%cutoff.LE.0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,   &
            &  'cutoff is negative or zero - do we really want neighbour lists?',&
                &  3295,info)
            GOTO 9999
        ENDIF
    END SELECT

    IF (Nlist%isymm.EQ.1) THEN
        symmetry =.TRUE.
    ELSE
        symmetry = .FALSE.
    ENDIF
    IF (PRESENT(knn)) THEN
        ensure_knn = .TRUE.
    ELSE
        ensure_knn = .FALSE.
    ENDIF
    skin = Nlist%skin
    topoid = Pc%active_topoid

    do_something: IF (Nlist%uptodate .OR. Pc%Npart.EQ.0) THEN
        !neighbor lists are already up-to-date, or no particles on this proc
        !nothing to do
        IF (Nlist%uptodate) THEN
            info = ppm_error_notice
            CALL ppm_error(999,caller,   &
                &  'neighlists are already up-to-date, NOTHING to do',&
                &  3320,info)
            info = 0
        ELSE
            Nlist%nneighmin = 0
            Nlist%nneighmax = 0
        ENDIF
    ELSE
        !hack to build (potentially incomplete) neighbour lists even 
        !for ghost particles
        np_target = Pc%Npart
        IF (PRESENT(incl_ghosts)) THEN
            IF (incl_ghosts) THEN
                np_target = Pc%Mpart
                topo => ppm_topo(topoid)%t
                IF (MK.EQ.ppm_kind_single) THEN
                    topo%min_subs(:,:) = topo%min_subs(:,:) - topo%ghostsizes
                    topo%max_subs(:,:) = topo%max_subs(:,:) + topo%ghostsizes
                ELSE IF (MK.EQ.ppm_kind_double) THEN
                    topo%min_subd(:,:) = topo%min_subd(:,:) - topo%ghostsized
                    topo%max_subd(:,:) = topo%max_subd(:,:) + topo%ghostsized
                ENDIF
            ENDIF
        ENDIF

        IF (ensure_knn) THEN
                info = ppm_error_error
                CALL ppm_error(ppm_err_alloc,caller,   &
                    &   'option required the kdtree module.',3394,info)
                GOTO 9999
!__WITH_KDTREE
        ELSE  

            SELECT TYPE (Pc)
            CLASS IS (ppm_t_sop_d)

                !FIXME: when adaptive ghost layers are available
                ghostlayer(1:2*ppm_dim)=Pc%ghostlayer

!__WITH_CNL
                    Pc%stats%nb_inl = Pc%stats%nb_inl+1

                    t1 = MPI_WTIME(info)
                    CALL ppm_inl_vlist(topoid,Pc%xp,np_target,&
                        Pc%Mpart,rcp,skin,symmetry,ghostlayer,info,&
                        Nlist%vlist,Nlist%nvlist)
                    IF (info .NE. 0) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_sub_failed,caller,&
                            'ppm_inl_vlist failed',3453,info)
                        GOTO 9999
                    ENDIF
                    t2 = MPI_WTIME(info)
                    Pc%stats%t_inl = Pc%stats%t_inl + (t2 - t1)

            CLASS DEFAULT

                Pc%stats%nb_nl = Pc%stats%nb_nl+1

                t1 = MPI_WTIME(info)
                CALL ppm_neighlist_vlist(topoid,Pc%xp,Pc%Mpart,&
                    Nlist%cutoff,skin,symmetry,Nlist%vlist,&
                    Nlist%nvlist,info,lstore=lstore)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_sub_failed,caller,&
                        'ppm_neighlist_vlist failed',3477,info)
                    GOTO 9999
                ENDIF
                t2 = MPI_WTIME(info)
                Pc%stats%t_nl = Pc%stats%t_nl + (t2 - t1)
            END SELECT
        ENDIF

        !restore subdomain sizes (revert hack)
        IF (PRESENT(incl_ghosts)) THEN
            IF (incl_ghosts) THEN
                IF (MK.EQ.ppm_kind_single) THEN
                    topo%min_subs(:,:) = topo%min_subs(:,:) + topo%ghostsizes
                    topo%max_subs(:,:) = topo%max_subs(:,:) - topo%ghostsizes
                ELSE IF (MK.EQ.ppm_kind_double) THEN
                    topo%min_subd(:,:) = topo%min_subd(:,:) + topo%ghostsized
                    topo%max_subd(:,:) = topo%max_subd(:,:) - topo%ghostsized
                ENDIF
                topo => NULL()
            ENDIF
        ENDIF

        !-----------------------------------------------------------------------
        !Update state
        !-----------------------------------------------------------------------
        Nlist%uptodate = .TRUE.

        Nlist%nneighmin = MINVAL(Nlist%nvlist(1:Pc%Npart))
        Nlist%nneighmax = MAXVAL(Nlist%nvlist(1:np_target))

        ! DC operators that do not use a xset neighbour list, if they exist, 
        ! are no longer valid (they depend on the neighbour lists)
        op => Pc%ops%begin()
        DO WHILE (ASSOCIATED(op))
            IF (.NOT.op%flags(ppm_ops_interp)) THEN
                op%flags(ppm_ops_iscomputed) = .FALSE.
            ENDIF
            op => Pc%ops%next()
        ENDDO

        
        Nlist => NULL()

        !FIXME
        ! We want to distinguish between "self" neighbour lists
        ! and cross-set ones.
        IF (neigh_id .EQ. 1) THEN
            Pc%flags(ppm_part_neighlists) = .TRUE.
        ENDIF

    ENDIF do_something
    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_neighlist_d


FUNCTION part_DS_exists_d(cont,id,caller) RESULT(exists)
    !!!------------------------------------------------------------------------!
    !!! Check whether a Data Structure exists and can be accessed at this id
    !!!------------------------------------------------------------------------!

    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_container_d)                       :: cont
    !!! Data structure containing the particles
    INTEGER,                            INTENT(IN   )   :: id
    !!! id where the data is stored
    LOGICAL                                             :: exists
    !!! Return status, on success 0.
    CHARACTER(LEN = *),OPTIONAL                         :: caller
    !!! Calling routine
    
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)               :: lcaller
    INTEGER                                 :: info


    IF (PRESENT(caller)) THEN
        lcaller = TRIM(ADJUSTL(caller))
    ELSE
        lcaller = 'ppm_DS_exists'
    ENDIF
    exists = .FALSE.
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (id.LE.0 .OR. id.GT.cont%max_id) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,lcaller,   &
            & 'Invalid id for this data structure, use create() first',&
            3578,info)
        RETURN
    ENDIF

    !NB: ugly code b/c no templating
    SELECT TYPE(cont)
    TYPE IS (ppm_c_props_d)
        IF (ASSOCIATED(cont%vec)) THEN
            IF (ASSOCIATED(cont%vec(id)%t)) THEN
                exists = .TRUE.
                RETURN
            ENDIF
        ENDIF
    TYPE IS (ppm_c_operators_d)
        IF (ASSOCIATED(cont%vec)) THEN
            IF (ASSOCIATED(cont%vec(id)%t)) THEN
                exists = .TRUE.
                RETURN
            ENDIF
        ENDIF
    TYPE IS (ppm_c_neighlists_d)
        IF (ASSOCIATED(cont%vec)) THEN
            IF (ASSOCIATED(cont%vec(id)%t)) THEN
                exists = .TRUE.
                RETURN
            ENDIF
        ENDIF
    END SELECT


    info = ppm_error_error
    CALL ppm_error(ppm_err_argument,lcaller,   &
        & 'No data structure found, use create() first',&
        3611,info)
    RETURN



END FUNCTION part_DS_exists_d

SUBROUTINE part_set_cutoff_d(Pc,cutoff,info,nlid)
    !!! Set a cutoff radius for a particle cloud and update the
    !!! the ghostlayer sizes.
    !!! The cutoff radius concerns the default neighbor list, unless
    !!! specified otherwise.
    !-------------------------------------------------------------------------
    ! Arguments
    !-------------------------------------------------------------------------
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)            :: Pc
    REAL(MK),                 INTENT(IN   )  :: cutoff
    !!! cutoff radius
    INTEGER,                  INTENT(   OUT) :: info
    !!! return status. On success, 0
    INTEGER,OPTIONAL,         INTENT(IN    ) :: nlid
    !!! ID of the neighbor list for which this cutoff radius
    !!! applies. Default is ppm_param_default_nlID
    
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    TYPE(ppm_t_neighlist_d),     POINTER :: nl => NULL()
    INTEGER                                   :: neigh_id 
    CHARACTER(LEN = ppm_char)                 :: caller = 'part_set_cutoff'
    REAL(KIND(1.D0))                          :: t0

    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    !-------------------------------------------------------------------------
    !  Set new cutoff
    !-------------------------------------------------------------------------
    IF (PRESENT(nlid)) THEN
        neigh_id = nlid
    ELSE
        neigh_id = ppm_param_default_nlID
    ENDIF
    
    Pc%neighs%vec(neigh_id)%t%cutoff = cutoff

    ! Compute ghostlayer sizes
    IF (cutoff.GT.Pc%ghostlayer) THEN
        !If the new cutoff is larger than the current ghostsize
        ! then the new ghostsize is the new cutoff
        Pc%ghostlayer = cutoff
        ! update states
        Pc%flags(ppm_part_ghosts) = .FALSE.
    ELSE IF (cutoff .LT. Pc%ghostlayer) THEN
        !Else, we find the new maximum cutoff radius amongst
        !all existing neighbor lists on this particle cloud
        Pc%ghostlayer = 0._mk
        nl => Pc%neighs%begin()
        DO WHILE (ASSOCIATED(nl))
            IF (nl%cutoff .GT. Pc%ghostlayer) THEN
                Pc%ghostlayer = nl%cutoff
            ENDIF
            nl => Pc%neighs%next()
        ENDDO
        !no need to update states: ghosts are still ok.
    ENDIF

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_set_cutoff_d

SUBROUTINE part_comp_global_index_d(Pc,info)
    !!! Compute a global index for particles
    !!! (Uses MPI communications)
    !-------------------------------------------------------------------------
    ! Arguments
    !-------------------------------------------------------------------------
    INCLUDE "mpif.h"

    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_particles_d)            :: Pc
    INTEGER,                  INTENT(   OUT) :: info
    !!! return status. On success, 0

    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)                 :: caller = 'part_global_index'
    REAL(KIND(1.D0))                          :: t0

    INTEGER                        :: offset
    INTEGER                        :: i
    INTEGER, DIMENSION(:), POINTER :: wp
    !-------------------------------------------------------------------------
    !  Initialise
    !-------------------------------------------------------------------------
    CALL substart(caller,t0,info)

    IF (.NOT. Pc%flags(ppm_part_global_index)) THEN
        CALL Pc%create_prop(Pc%gi_id,ppm_type_int,info,name="GlobalIndex")
        Pc%flags(ppm_part_global_index) = .TRUE.
    END IF
    CALL MPI_Scan(Pc%Npart,offset,1,MPI_INTEGER,MPI_SUM,ppm_comm,info)
    offset = offset - Pc%Npart
    CALL Pc%get(wp,Pc%gi_id)
    FORALL (i=1:Pc%Npart) wp(i) = offset + i !- 1 !uncomment if index from 0
    CALL Pc%set(wp,Pc%gi_id)

    !-----------------------------------------------------------------------
    ! Finalize
    !-----------------------------------------------------------------------
    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE part_comp_global_index_d










SUBROUTINE part_map_create_d(Pc,id,source_topoid,target_topoid,info)
    !!! Adds a property to an existing particle set
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(  OUT) :: id
    INTEGER,                INTENT(IN   ) :: source_topoid
    INTEGER,                INTENT(IN   ) :: target_topoid
    INTEGER,               INTENT(OUT)    :: info

    INTEGER                               :: vec_size,npart,i
    CHARACTER(LEN=ppm_char)               :: caller = 'particle_map_create'
    CHARACTER(LEN=ppm_char)               :: name2
    REAL(KIND(1.D0))                      :: t0
    TYPE(ppm_ptr_part_mapping_d),DIMENSION(:),POINTER  :: vec_tmp => NULL()
    TYPE(ppm_t_part_mapping_d),               POINTER  :: map => NULL()
    LOGICAL, DIMENSION(ppm_param_length_pptflags):: flags

    CALL substart(caller,t0,info)

    !Generate a new id (we should use templating here...)
    ASSOCIATE (cont => Pc%maps )
        id = 0
        IF (cont%nb.LT.cont%vec_size) THEN
            !there is at least one empty slot in the array
            ! of mapping pointers
            id = id + 1
            DO WHILE (ASSOCIATED(cont%vec(id)%t))
                id = id + 1
            ENDDO
        ELSE
            IF (.NOT. ASSOCIATED(cont%vec)) THEN
                !need to allocate the array of mapping pointers 
                vec_size=20
                ALLOCATE(cont%vec(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating mapping array failed',3787,info)
                    GOTO 9999
                ENDIF
                id = 1
            ELSE
                !need to resize the array of mapping pointers 
                vec_size=MAX(2*cont%vec_size,20)
                ALLOCATE(vec_tmp(vec_size),STAT=info)
                IF (info .NE. 0) THEN
                    info = ppm_error_error
                    CALL ppm_error(ppm_err_alloc,caller,&
                        'allocating mapping array failed',3798,info)
                    GOTO 9999
                ENDIF
                DO i=1,cont%vec_size
                    vec_tmp(i)%t => cont%vec(i)%t
                ENDDO
                DEALLOCATE(cont%vec)
                cont%vec => vec_tmp
            ENDIF
            cont%vec_size = vec_size
            id = cont%nb + 1
        ENDIF
        cont%nb = cont%nb + 1
            

        IF (id .GT. cont%max_id) cont%max_id = id
        IF (id .LT. cont%min_id) cont%min_id = id

    END ASSOCIATE

    IF (.NOT. ASSOCIATED(Pc%maps%vec(id)%t)) THEN
        ALLOCATE(Pc%maps%vec(id)%t,STAT=info)
        IF (info .NE. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                'allocating mapping pointer failed',3823,info)
            GOTO 9999
        ENDIF
    ENDIF

    map => Pc%maps%vec(id)%t

    ! Create the mapping
    CALL map%create(source_topoid,target_topoid,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_sub_failed,caller,&
            'creating mapping failed',3835,info)
        GOTO 9999
    ENDIF

    CALL substop(caller,t0,info)
    9999  CONTINUE

END SUBROUTINE part_map_create_d

SUBROUTINE part_map_destroy_d(Pc,id,info)
    !!! Destroy a mapping from an existing particle set
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,                INTENT(INOUT) :: id
    INTEGER,               INTENT(OUT)    :: info

    CHARACTER(LEN=ppm_char)               :: caller = 'particle_map_destroy'
    REAL(KIND(1.D0))                      :: t0

    CALL substart(caller,t0,info)

    ASSOCIATE (cont => Pc%maps)
        IF (id .LE. 0 .OR. id .GT. cont%vec_size) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_alloc,caller,&
                &    'mapping id larger than size of mappings array',&
                3860,info)
            GOTO 9999
        ENDIF

        CALL cont%vec(id)%t%destroy(info)
        NULLIFY(cont%vec(id)%t)

        cont%nb = cont%nb - 1
        IF (id .EQ. cont%max_id) THEN
            cont%max_id = cont%max_id - 1
            IF (cont%max_id .GT. 0) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%max_id)%t))
                    cont%max_id = cont%max_id - 1
                    IF (cont%max_id .EQ. 0) EXIT
                ENDDO
            ENDIF
        ENDIF
        IF (cont%nb.EQ.0) THEN
            cont%min_id = HUGE(1)
        ELSE IF (id .EQ. cont%min_id) THEN
            cont%min_id = cont%min_id + 1
            IF (cont%min_id .LE. cont%vec_size) THEN
                DO WHILE(.NOT.ASSOCIATED(cont%vec(cont%min_id)%t))
                    cont%min_id = cont%min_id + 1
                    IF (cont%min_id .GT. cont%vec_size) THEN
                        info = ppm_error_error
                        CALL ppm_error(ppm_err_alloc,caller,&
                            &    'coding error in the data structure',&
                            3888,info)
                        GOTO 9999
                    ENDIF
                ENDDO
            ENDIF
        ENDIF
    END ASSOCIATE


    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE part_map_destroy_d


SUBROUTINE map_create_d(map,source_topoid,target_topoid,info)
    !!! Constructor for particle mapping data structure
    INTEGER, PARAMETER :: MK = ppm_kind_double
    CLASS(ppm_t_part_mapping_d)   :: map
    INTEGER,                INTENT(IN) :: source_topoid
    INTEGER,                INTENT(IN) :: target_topoid
    INTEGER,               INTENT(OUT) :: info

    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'map_create'



    CALL substart(caller,t0,info)

    map%source_topoid = source_topoid
    map%target_topoid = target_topoid

    CALL substop(caller,t0,info)

    9999  CONTINUE

END SUBROUTINE map_create_d

SUBROUTINE map_destroy_d(map,info)
    CLASS(ppm_t_part_mapping_d)   :: map
    INTEGER,                                INTENT(  OUT)  :: info
    !!! Returns status, 0 upon success.
    REAL(KIND(1.D0))                   :: t0
    CHARACTER(LEN=ppm_char)            :: caller = 'map_destroy'


    CALL substart(caller,t0,info)

    map%source_topoid = -1
    map%target_topoid = -1

    IF(ASSOCIATED(map%send)) DEALLOCATE(map%send,STAT=info)
    IF(ASSOCIATED(map%recv)) DEALLOCATE(map%recv,STAT=info)
    IF(ASSOCIATED(map%nsend)) DEALLOCATE(map%nsend,STAT=info)
    IF(ASSOCIATED(map%nrecv)) DEALLOCATE(map%nrecv,STAT=info)
    IF(ASSOCIATED(map%psend)) DEALLOCATE(map%psend,STAT=info)
    IF(ASSOCIATED(map%precv)) DEALLOCATE(map%precv,STAT=info)
    IF(ASSOCIATED(map%pp)) DEALLOCATE(map%pp,STAT=info)
    IF(ASSOCIATED(map%qq)) DEALLOCATE(map%qq,STAT=info)

    map%oldNpart = 0
    map%newNpart = 0

    CALL substop(caller,t0,info)

END SUBROUTINE map_destroy_d

















!-------------------------------------------------------------
! Primitive function as defined in Chen et al., 
!             Int. J. Numer. Meth. Engng 2003; 56:935-960.
! (here, the quartic spline)
!-------------------------------------------------------------
FUNCTION primitive_d(x)

    IMPLICIT NONE
    INTEGER, PARAMETER :: MK = ppm_kind_double
    !arguments
    REAL(MK), INTENT(IN) :: x
    REAL(MK)             :: primitive_d
    IF(x.GT.1._MK) THEN 
        primitive_d = 0._MK 
    ELSE
        primitive_d = 1._MK + x**2 * (-6._MK + x * (8._MK -3._MK * x))
    ENDIF

END FUNCTION

SUBROUTINE solveLSE_d(A,x_or_b,info)

    !=======================================================================!
    ! solves the LSE A*x=b
    ! if necessary, singularities are removed &
    ! (WARNING: no check is performed on the 
    ! validity of the solution after that)
    ! x_or_b is expected to contain b on input
    ! x_or_b contains x on output
    ! A is not altered

    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_double
    ! arguments
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(IN   ) :: A 
    REAL(MK), DIMENSION (:)  , POINTER,INTENT(INOUT) :: x_or_b
    INTEGER,                           INTENT(  OUT) :: info

    ! local variables
    INTEGER , DIMENSION (:)  , POINTER   :: indx=>NULL(),valid=>NULL()
    INTEGER , DIMENSION (:)  , POINTER   :: indxnew=>NULL(),roworder=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: bnew=>NULL(),exact_b=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: real_b=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: Anew=>NULL(),Acopy=>NULL()
    REAL(MK)                             :: tolerance_lse = 1e-1

    INTEGER                              :: n,nnew
    INTEGER                              :: i,j,inew,jnew,itemp
    LOGICAL                              :: check = .TRUE.
    CHARACTER(LEN = 256),PARAMETER       :: caller = 'solveLSE'
    CHARACTER(LEN = 256)                 :: cbuf
    REAL(MK)                             :: closetozero

    !=======================================================================!
    ! init
    info = 0
    n = SIZE(A,1)
    !closetozero = SQRT(EPSILON(closetozero))
    closetozero = 100._MK*(EPSILON(closetozero))

    ALLOCATE(indx(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(valid(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(Acopy(n,n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF
    Acopy = A

    IF (check) THEN
        ALLOCATE(exact_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b = x_or_b

        ALLOCATE(real_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! compute the LU factorization of A
    CALL dgetrf(n,n,Acopy,n,indx,info)
    ! if info = i > 0, then U_ii = 0 and the matrix is singular
    ! this case will be dealt with below when checking for singularities
    IF (info .LT. 0) THEN
        WRITE(cbuf,'(A,I2)') ' getrf failed with info = ', info
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    !=======================================================================!
    ! check for singularities

    ! mark redundant eqs/coefficients
    valid = 1
    DO j=1,n
        IF (ABS(Acopy(j,j)) .LT. closetozero) THEN
            valid(j) = 0
        ENDIF
    ENDDO

    nnew = SUM(valid) ! size of reduced system

    ! if necessary, remove redundant equations/coefficients
    IF (nnew .NE. n) THEN

        ALLOCATE(roworder(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        DO i= 1,n
            roworder(i) = i
        ENDDO
        DO i= 1,n
            itemp = roworder(i)
            roworder(i) = roworder(indx(i))
            roworder(indx(i)) = itemp
        ENDDO

        !====================================================================!
        ! create new LSE

        ! allocation
        ALLOCATE(bnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(indxnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(Anew(nnew,nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        ! delete singular rows/columns in A
        ! delete corresponding entries in b
        inew = 0
        DO i = 1,n

            IF (valid(i) .EQ. 1) THEN

                inew = inew + 1
                bnew(inew) = x_or_b(roworder(i))

                jnew = 0
                DO  j = 1,n
                    IF (valid(j) .EQ. 1) THEN

                        jnew = jnew + 1
                        Anew(inew,jnew) = A(roworder(i),roworder(j))

                    ENDIF
                ENDDO

            ENDIF

        ENDDO

        !====================================================================!
        ! solve new LSE
        CALL dgetrf(nnew,nnew,Anew,nnew,indxnew,info)
        IF (info .NE. 0) THEN
            !get the value of info
            WRITE(cbuf,'(A,I2)') ' getrf new failed with info = ', info

            IF (info.GT.0) THEN
                OPEN(81,FILE='DumpA.dat',FORM='FORMATTED',STATUS='REPLACE',IOSTAT=info)
                DO i=1,n
                    WRITE(81,'(10E20.12)') A(i,:)
                ENDDO
                CLOSE(81)
            ENDIF

            !print the error message
            CALL ppm_write(ppm_rank,caller,cbuf,info)

            info = -1
            GOTO 9999
        ENDIF

        CALL dgetrs('N',nnew,1,Anew,nnew,indxnew,bnew,nnew,info)
        IF (info .NE. 0) THEN
            WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        !====================================================================!
        ! sort solution (coefficients) into old places, remaining places are
        ! set to zero 
        jnew = 0
        DO j = 1,n
            x_or_b(j) = 0._MK
        ENDDO
        DO j = 1,n

            IF (valid(j) .EQ. 1) THEN
                jnew = jnew + 1
                x_or_b(roworder(j)) = bnew(jnew)
            ENDIF

        ENDDO

        DEALLOCATE(roworder)
        DEALLOCATE(indxnew)
        DEALLOCATE(bnew)
        DEALLOCATE(Anew)

    ELSE ! no singularities

        !====================================================================!
        ! solve originial LSE
        CALL dgetrs('N',n,1,Acopy,n,indx,x_or_b,n,info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': getrs failed'
            info = -1
            GOTO 9999
        ENDIF

    ENDIF

    !=======================================================================!
    ! check if equations were solved right (if you trust in LAPACK and this 
    ! code PUT THIS IN IF BRANCH FOR THE REDUCED SYSTEM)
    IF (check) THEN
        CALL dgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
            SIZE(A,1),x_or_b,1,0._MK,real_b,1)
        IF (SUM(ABS(real_b - exact_b)) .GT. tolerance_LSE) THEN
            WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
            CALL ppm_write(ppm_rank,caller,&
                'Error in moment conditions too large.',info)
            WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                SUM(ABS(real_b - exact_b))
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            DO i=1,n
                DO j=1,n
                    WRITE(9001,'(1(E30.22))') A(i,j)
                ENDDO
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'moment matrix written in file fort.9001',info)
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! dealloc
    DEALLOCATE(valid)
    DEALLOCATE(indx)
    DEALLOCATE(Acopy)
    IF (check) THEN
        DEALLOCATE(exact_b)
        DEALLOCATE(real_b)
    ENDIF

    9999 CONTINUE ! jump here upon error

END SUBROUTINE solveLSE_d

SUBROUTINE solveLSE_2_d(A,x_or_b,x_or_b_2,info)

    !=======================================================================!
    ! solves the LSE A*x1=b1 and A*x2=b2
    ! if necessary, singularities are removed 
    ! (WARNING: no check is performed on the 
    ! validity of the solution after that)
    ! x_or_b is expected to contain b on input
    ! x_or_b contains x on output
    ! A is not altered

    IMPLICIT NONE
    INTEGER, PARAMETER :: MK = ppm_kind_double
    ! arguments
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(IN   )  :: A 
    REAL(MK), DIMENSION (:)  , POINTER,INTENT(INOUT)  :: x_or_b, x_or_b_2
    INTEGER, INTENT(OUT)                  :: info
    ! local variables
    INTEGER , DIMENSION (:)  , POINTER   :: indx=>NULL(),valid=>NULL()
    INTEGER , DIMENSION (:)  , POINTER   :: indxnew=>NULL(),roworder=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: bnew=>NULL(),bnew_2=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: exact_b=>NULL(),exact_b_2=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: real_b=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: Anew=>NULL(),Acopy=>NULL()
    REAL(MK)                             :: tolerance_lse = 1e-1
    INTEGER                              :: n,nnew
    INTEGER                              :: i,j,inew,jnew,itemp
    LOGICAL                              :: check = .TRUE.
    CHARACTER(LEN = 256),PARAMETER       :: caller = 'solveLSE_2'
    CHARACTER(LEN = 256)                 :: cbuf
    REAL(MK)                             :: closetozero

    !=======================================================================!
    ! init
    info = 0
    n = SIZE(A,1)
    !closetozero = SQRT(EPSILON(closetozero))
    closetozero = 100._MK*(EPSILON(closetozero))

    ALLOCATE(indx(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(valid(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(Acopy(n,n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF
    Acopy = A

    IF (check) THEN
        ALLOCATE(exact_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b = x_or_b

        ALLOCATE(exact_b_2(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b_2 = x_or_b_2

        ALLOCATE(real_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! compute the LU factorization of A
    CALL dgetrf(n,n,Acopy,n,indx,info)
    ! if info = i > 0, then U_ii = 0 and the matrix is singular
    ! this case will be dealt with below when checking for singularities
    IF (info .LT. 0) THEN
        WRITE(cbuf,'(A,I2)') ' getrf failed with info = ', info
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    !=======================================================================!
    ! check for singularities

    ! mark redundant eqs/coefficients
    valid = 1
    DO j=1,n
        IF (ABS(Acopy(j,j)) .LT. closetozero) THEN
            valid(j) = 0
        ENDIF
    ENDDO

    nnew = SUM(valid) ! size of reduced system

    ! if necessary, remove redundant equations/coefficients
    IF (nnew .NE. n) THEN

        ALLOCATE(roworder(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        DO i= 1,n
            roworder(i) = i
        ENDDO
        DO i= 1,n
            itemp = roworder(i)
            roworder(i) = roworder(indx(i))
            roworder(indx(i)) = itemp
        ENDDO

        !====================================================================!
        ! create new LSE

        ! allocation
        ALLOCATE(bnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(bnew_2(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(indxnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(Anew(nnew,nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        ! delete singular rows/columns in A
        ! delete corresponding entries in b
        inew = 0
        DO i = 1,n

            IF (valid(i) .EQ. 1) THEN

                inew = inew + 1
                bnew(inew)   = x_or_b(roworder(i))
                bnew_2(inew) = x_or_b_2(roworder(i))

                jnew = 0
                DO  j = 1,n
                    IF (valid(j) .EQ. 1) THEN

                        jnew = jnew + 1
                        Anew(inew,jnew) = A(roworder(i),roworder(j))

                    ENDIF
                ENDDO

            ENDIF

        ENDDO

        !====================================================================!
        ! solve new LSE
        CALL dgetrf(nnew,nnew,Anew,nnew,indxnew,info)
        IF (info .NE. 0) THEN
            !get the value of info
            WRITE(cbuf,'(A,I2)') ' getrf new failed with info = ', info

            IF (info.GT.0) THEN
                OPEN(81,FILE='DumpA.dat',FORM='FORMATTED',STATUS='REPLACE',IOSTAT=info)
                DO i=1,n
                    WRITE(81,'(10E20.12)') A(i,:)
                ENDDO
                CLOSE(81)
            ENDIF

            !print the error message
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        CALL dgetrs('N',nnew,1,Anew,nnew,indxnew,bnew,nnew,info)
        IF (info .NE. 0) THEN
            WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF
        CALL dgetrs('N',nnew,1,Anew,nnew,indxnew,bnew_2,nnew,info)
        IF (info .NE. 0) THEN
            WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        !====================================================================!
        ! sort solution (coefficients) into old places, remaining places are
        ! set to zero 
        jnew = 0
        DO j = 1,n
            x_or_b(j) = 0._MK
            x_or_b_2(j) = 0._MK
        ENDDO
        DO j = 1,n

            IF (valid(j) .EQ. 1) THEN
                jnew = jnew + 1
                x_or_b(roworder(j)) = bnew(jnew)
                x_or_b_2(roworder(j)) = bnew_2(jnew)
            ENDIF

        ENDDO

        DEALLOCATE(roworder)
        DEALLOCATE(indxnew)
        DEALLOCATE(bnew)
        DEALLOCATE(bnew_2)
        DEALLOCATE(Anew)

    ELSE ! no singularities

        !====================================================================!
        ! solve originial LSE
        CALL dgetrs('N',n,1,Acopy,n,indx,x_or_b,n,info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': getrs failed'
            info = -1
            GOTO 9999
        ENDIF
        CALL dgetrs('N',n,1,Acopy,n,indx,x_or_b_2,n,info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': getrs failed'
            info = -1
            GOTO 9999
        ENDIF

    ENDIF

    !=======================================================================!
    ! check if equations were solved right (if you trust in LAPACK and this 
    ! code PUT THIS IN IF BRANCH FOR THE REDUCED SYSTEM)
    IF (check) THEN
        CALL dgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
            SIZE(A,1),x_or_b,1,0._MK,real_b,1)
        IF (SUM(ABS(real_b - exact_b)) .GT. tolerance_LSE) THEN
            WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
            CALL ppm_write(ppm_rank,caller,&
                'Error in moment conditions 1 too large.',info)
            WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                SUM(ABS(real_b - exact_b))
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            DO i=1,n
                DO j=1,n
                    WRITE(9001,'(1(E30.22))') A(i,j)
                ENDDO
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'moment matrix written in file fort.9001',info)
            info = -1
            GOTO 9999
        ENDIF
        CALL dgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
            SIZE(A,1),x_or_b_2,1,0._MK,real_b,1)
        IF (SUM(ABS(real_b - exact_b_2)) .GT. tolerance_LSE) THEN
            WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
            CALL ppm_write(ppm_rank,caller,&
                'Error in moment conditions 2 too large.',info)
            WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                SUM(ABS(real_b - exact_b_2))
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! dealloc
    DEALLOCATE(valid)
    DEALLOCATE(indx)
    DEALLOCATE(Acopy)
    IF (check) THEN
        DEALLOCATE(exact_b)
        DEALLOCATE(exact_b_2)
        DEALLOCATE(real_b)
    ENDIF

    9999 CONTINUE ! jump here upon error

END SUBROUTINE solveLSE_2_d

SUBROUTINE solveLSE_n_d(A,x_or_b,n_eq,info)

    !=======================================================================!
    ! solves the LSE A*x_i=b_i  for i=1..n_eq
    ! if necessary, singularities are removed 
    ! (WARNING: no check is performed on the 
    ! validity of the solution after that)
    ! x_or_b is expected to contain b on input
    ! x_or_b contains x on output
    ! A is not altered

    IMPLICIT NONE
    INTEGER, PARAMETER :: MK = ppm_kind_double
    ! arguments
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(IN   )  :: A 
    REAL(MK), DIMENSION (:,:), POINTER,INTENT(INOUT)  :: x_or_b
    INTEGER, INTENT(IN)                               :: n_eq
    INTEGER, INTENT(OUT)                              :: info

    ! local variables
    INTEGER , DIMENSION (:)  , POINTER   :: indx=>NULL(),valid=>NULL()
    INTEGER , DIMENSION (:)  , POINTER   :: indxnew=>NULL(),roworder=>NULL()
    REAL(MK), DIMENSION (:)  , POINTER   :: real_b=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: bnew_n=>NULL(),exact_b_n=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: Anew=>NULL(),Acopy=>NULL()
    REAL(MK)                             :: tolerance_lse = 1e-1
    INTEGER                              :: n,nnew
    INTEGER                              :: i,j,k,inew,jnew,itemp
    LOGICAL                              :: check = .TRUE.
    CHARACTER(LEN = 256),PARAMETER       :: caller = 'solveLSE_n'
    CHARACTER(LEN = 256)                 :: cbuf
    REAL(MK)                             :: closetozero

    !=======================================================================!
    ! init
    info = 0
    n = SIZE(A,1)
    !closetozero = SQRT(EPSILON(closetozero))
    closetozero = 100._MK*(EPSILON(closetozero))

    ALLOCATE(indx(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(valid(n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF

    ALLOCATE(Acopy(n,n),STAT=info)
    IF (info .NE. 0) THEN
        WRITE(*,*)caller,': allocation failed.'
        info = -1
        GOTO 9999
    ENDIF
    Acopy = A

    IF (check) THEN
        ALLOCATE(exact_b_n(n,n_eq),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        exact_b_n = x_or_b

        ALLOCATE(real_b(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
    ENDIF

    !=======================================================================!
    ! compute the LU factorization of A
    CALL dgetrf(n,n,Acopy,n,indx,info)
    ! if info = i > 0, then U_ii = 0 and the matrix is singular
    ! this case will be dealt with below when checking for singularities
    IF (info .LT. 0) THEN
        WRITE(cbuf,'(A,I2)') ' getrf failed with info = ', info
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    !=======================================================================!
    ! check for singularities

    ! mark redundant eqs/coefficients
    valid = 1
    DO j=1,n
        IF (ABS(Acopy(j,j)) .LT. closetozero) THEN
            valid(j) = 0
        ENDIF
    ENDDO

    nnew = SUM(valid) ! size of reduced system

    ! if necessary, remove redundant equations/coefficients
    IF (nnew .NE. n) THEN

        ALLOCATE(roworder(n),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        DO i= 1,n
            roworder(i) = i
        ENDDO
        DO i= 1,n
            itemp = roworder(i)
            roworder(i) = roworder(indx(i))
            roworder(indx(i)) = itemp
        ENDDO

        !====================================================================!
        ! create new LSE

        ! allocation
        ALLOCATE(bnew_n(nnew,n_eq),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(indxnew(nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF
        ALLOCATE(Anew(nnew,nnew),STAT=info)
        IF (info .NE. 0) THEN
            WRITE(*,*)caller,': allocation failed.'
            info = -1
            GOTO 9999
        ENDIF

        ! delete singular rows/columns in A
        ! delete corresponding entries in b
        inew = 0
        DO i = 1,n

            IF (valid(i) .EQ. 1) THEN

                inew = inew + 1
                bnew_n(inew,1:n_eq)   = x_or_b(roworder(i),1:n_eq)

                jnew = 0
                DO  j = 1,n
                    IF (valid(j) .EQ. 1) THEN

                        jnew = jnew + 1
                        Anew(inew,jnew) = A(roworder(i),roworder(j))

                    ENDIF
                ENDDO

            ENDIF

        ENDDO

        !====================================================================!
        ! solve new LSE
        CALL dgetrf(nnew,nnew,Anew,nnew,indxnew,info)
        IF (info .NE. 0) THEN
            !get the value of info
            WRITE(cbuf,'(A,I2)') ' getrf new failed with info = ', info

            IF (info.GT.0) THEN
                OPEN(81,FILE='DumpA.dat',FORM='FORMATTED',STATUS='REPLACE',IOSTAT=info)
                DO i=1,n
                    WRITE(81,'(10E20.12)') A(i,:)
                ENDDO
                CLOSE(81)
            ENDIF

            !print the error message
            CALL ppm_write(ppm_rank,caller,cbuf,info)
            info = -1
            GOTO 9999
        ENDIF

        DO k=1,n_eq
            CALL dgetrs('N',nnew,1,Anew,nnew,indxnew,bnew_n(:,k),nnew,info)
            IF (info .NE. 0) THEN
                WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
                CALL ppm_write(ppm_rank,caller,cbuf,info)
                info = -1
                GOTO 9999
            ENDIF
        ENDDO

        !====================================================================!
        ! sort solution (coefficients) into old places, remaining places are
        ! set to zero 
        jnew = 0
        DO j = 1,n
            x_or_b(j,1:n_eq) = 0._MK
        ENDDO
        DO j = 1,n

            IF (valid(j) .EQ. 1) THEN
                jnew = jnew + 1
                DO k=1,n_eq
                    x_or_b(roworder(j),k) = bnew_n(jnew,k)
                ENDDO
            ENDIF

        ENDDO

        DEALLOCATE(roworder)
        DEALLOCATE(indxnew)
        DEALLOCATE(bnew_n)
        DEALLOCATE(Anew)

    ELSE ! no singularities

        !====================================================================!
        ! solve originial LSE
        DO k=1,n_eq
            CALL dgetrs('N',n,1,Acopy,n,indx,x_or_b(:,k),n,info)
            IF (info .NE. 0) THEN
                WRITE(cbuf,'(A,I2)') ' getrs new failed with info = ', info
                CALL ppm_write(ppm_rank,caller,cbuf,info)
                info = -1
                GOTO 9999
            ENDIF
        ENDDO

    ENDIF

    !=======================================================================!
    ! check if equations were solved right (if you trust in LAPACK and this 
    ! code PUT THIS IN IF BRANCH FOR THE REDUCED SYSTEM)
    IF (check) THEN
        DO k=1,n_eq
            CALL dgemv('N',SIZE(A,1),SIZE(A,2),1._MK,A,&
                SIZE(A,1),x_or_b(:,k),1,0._MK,real_b,1)
            
            IF (SUM(ABS(real_b - exact_b_n(:,k))) .GT. tolerance_LSE) THEN
                WRITE(*,*)'WARNING from ', TRIM(caller),': no solution!'
                CALL ppm_write(ppm_rank,caller,&
                    'Error in moment conditions 1 too large.',info)
                WRITE(cbuf,'(A,E12.3)')'The l1-norm of the error is ',&
                    SUM(ABS(real_b - exact_b_n(:,k)))
                CALL ppm_write(ppm_rank,caller,cbuf,info)
                DO i=1,n
                    DO j=1,n
                        WRITE(9001,'(1(E30.22))') A(i,j)
                    ENDDO
                ENDDO
                CALL ppm_write(ppm_rank,caller,&
                    'moment matrix written in file fort.9001',info)
                info = -1
                GOTO 9999
            ENDIF
        ENDDO
    ENDIF

    !=======================================================================!
    ! dealloc
    DEALLOCATE(valid)
    DEALLOCATE(indx)
    DEALLOCATE(Acopy)
    IF (check) THEN
        DEALLOCATE(exact_b_n)
        DEALLOCATE(real_b)
    ENDIF

    9999 CONTINUE ! jump here upon error

END SUBROUTINE solveLSE_n_d

SUBROUTINE ppm_matrix_svd_d(Z,n,m,info,min_sv)
    USE ppm_module_write
    USE ppm_module_data, ONLY: ppm_rank

    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_double
    ! arguments
    REAL(MK),DIMENSION(:,:),          INTENT(IN   ) :: Z
    INTEGER,                          INTENT(IN   ) :: n
    INTEGER,                          INTENT(IN   ) :: m
    INTEGER,                          INTENT(  OUT) :: info

    ! optional argument
    REAL(MK),OPTIONAL,                INTENT(  OUT) :: min_sv
    ! local variables
    INTEGER                              :: j
    CHARACTER(LEN = ppm_char)            :: cbuf
    CHARACTER(LEN = ppm_char)            :: caller = 'ppm_matrix_svd'
    REAL(KIND(1.D0))                     :: t0

    REAL(MK), DIMENSION (:),   POINTER   :: offdiag=>NULL(), diag=>NULL()
    INTEGER                              :: lwork,mm,nnn
    REAL(MK), DIMENSION (:),   POINTER   :: work=>NULL()
    REAL(MK), DIMENSION (:,:), POINTER   :: tauq=>NULL(),taup=>NULL()
    REAL(MK), PARAMETER                  :: ppm_tolerance_svd = 1E-10


    mm = m
    nnn = n
    ALLOCATE(offdiag(nnn-1),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    ALLOCATE(diag(nnn),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    
    ALLOCATE(taup(mm,nnn),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    ALLOCATE(tauq(mm,nnn),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF
    lwork= -1
    ALLOCATE(work(1),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF

    !get the size for lwork
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'dgebrd failed on workspace query',info)
        info=-1
        GOTO 9999
    ENDIF

    lwork= work(1)
    DEALLOCATE(work)
    ALLOCATE(work(lwork),STAT=info)
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        info=-1
        GOTO 9999
    ENDIF

    !decomposition
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'dgebrd failed',info)
        info=-1
        GOTO 9999
    ENDIF

    !get singular values
    IF (info.NE.0) THEN
        CALL ppm_write(ppm_rank,caller,'bdsqr failed',info)
        info=-1
        GOTO 9999
    ENDIF

    DEALLOCATE(taup)
    DEALLOCATE(tauq)
    DEALLOCATE(work)

    !!----------------------------------------------------------------------
    !! Raise an error if the singular value is below a threshold
    !!----------------------------------------------------------------------

    IF (MINVAL(diag) .LT. ppm_tolerance_svd) THEN
        WRITE(cbuf,'(A,E20.6)')'singular value. Min = ', MINVAL(diag)
        CALL ppm_write(ppm_rank,caller,cbuf, info)
        info = -1
        GOTO 9999
    ENDIF
    IF (PRESENT(min_sv)) min_sv=MINVAL(diag)
    
    9999 CONTINUE ! jump here upon error


END SUBROUTINE ppm_matrix_svd_d


!#if    2 == 1
!SUBROUTINE ppm_dcop_check_vandermonde_s(xp,ncoeff,npoints,info,min_sv)
!#elif  2 == 2
!SUBROUTINE ppm_dcop_check_vandermonde_d(xp,ncoeff,npoints,info,min_sv)
!#endif
    !USE ppm_module_write
    !USE ppm_module_data, ONLY: ppm_rank
!#ifdef __MKL
    !USE mkl95_lapack
    !USE mkl95_blas
!#endif

    !IMPLICIT NONE

!#if    2 == 1 
    !INTEGER, PARAMETER :: MK = ppm_kind_single
!#elif  2 == 2
    !INTEGER, PARAMETER :: MK = ppm_kind_double
!#endif
    !! arguments
    !REAL(MK),DIMENSION(:,:),          INTENT(IN   ) :: Z
    !INTEGER,                          INTENT(IN   ) :: ncoeff
    !INTEGER,                          INTENT(IN   ) :: npoints
    !INTEGER,                          INTENT(  OUT) :: info

    !! optional argument
    !REAL(MK),OPTIONAL,                INTENT(  OUT) :: min_sv
    !! local variables
    !INTEGER                               :: j
    !CHARACTER(LEN = ppm_char)             :: cbuf
    !CHARACTER(LEN = ppm_char)             :: caller = 'ppm_dcop_check_vandermonde'
    !REAL(KIND(1.D0))                      :: t0

    !REAL(MK), DIMENSION (:), POINTER      :: offdiag, diag
    !INTEGER                               :: lwork, mm,nnn
    !REAL(MK), DIMENSION (:), POINTER      :: work
    !REAL(MK), DIMENSION (:,:), POINTER    :: tauq,taup


    !mm = npoints
    !nnn = ncoeff
    !ALLOCATE(offdiag(nnn-1),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    !ALLOCATE(diag(nnn),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    
    !ALLOCATE(taup(mm,nnn),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    !ALLOCATE(tauq(mm,nnn),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF
    !lwork= -1
    !ALLOCATE(work(1),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !!get the size for lwork
!#ifdef __MKL
    !CALL dgebrd(mm,nnn,Z,mm,diag,offdiag,tauq,taup,work,lwork,info)
!#endif
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'dgebrd failed on workspace query',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !lwork= work(1)
    !DEALLOCATE(work)
    !ALLOCATE(work(lwork),STAT=info)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'allocation failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !!decomposition
!#ifdef __MKL
    !CALL dgebrd(mm,nnn,Z,mm,diag,offdiag,tauq,taup,work,lwork,info)
!#endif
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'dgebrd failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !!get singular values
    !CALL bdsqr(diag,offdiag)
    !IF (info.NE.0) THEN
        !CALL ppm_write(ppm_rank,caller,'bdsqr failed',info)
        !info=-1
        !GOTO 9999
    !ENDIF

    !DEALLOCATE(taup)
    !DEALLOCATE(tauq)
    !DEALLOCATE(work)

    !!!----------------------------------------------------------------------
    !!! Raise an error if the singular value is below a threshold
    !!!----------------------------------------------------------------------

    !IF (MINVAL(diag) .LT. 0.001_mk) THEN
        !WRITE(cbuf,'(A,E20.6)')'singular value. Min = ', MINVAL(diag)
        !CALL ppm_write(ppm_rank,caller,cbuf, info)
        !info = -1
        !GOTO 9999
    !ENDIF
    !IF (PRESENT(min_sv)) min_sv=MINVAL(diag)
    
    !9999 CONTINUE ! jump here upon error


!#if    2 == 1
!END SUBROUTINE ppm_dcop_check_vandermonde_s
!#elif  2 == 2
!END SUBROUTINE ppm_dcop_check_vandermonde_d
!#endif
SUBROUTINE ppm_dcop_compute2d_d(Pc,op_id,info,c,min_sv)
    !!! Computes generalized DC operators
    !!! if the optional argument interp is true, the routine uses
    !!! one set of particles (Pc2) as input data and
    !!! compute the differential opearator on the new set
    !!! If it has to do be interpolating (if the quantity to be computed
    !!! is the field itself, ie. if the degree of one term of the 
    !!! differential operator is zero), then the nearest-neighbour 
    !!! distances within Pc2 must have been already computed.
    USE ppm_module_error
    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_double
    !---------------------------------------------------------
    ! arguments
    !---------------------------------------------------------
    CLASS(ppm_t_particles_d)                        :: Pc
    !!! particles
    INTEGER,                             INTENT(IN   )   :: op_id
    !!! id of the operator kernel
    INTEGER,                             INTENT(  OUT)   :: info
    !!! non-zero on output if some error occurred
    !---------------------------------------------------------
    ! Optional arguments
    !---------------------------------------------------------
    REAL(MK),                  OPTIONAL, INTENT(IN   )   :: c
    !!! ratio h/epsilon
    REAL(MK),                  OPTIONAL, INTENT(  OUT)   :: min_sv
    !!! if present, compute the singular value decomposition of the 
    !!! vandermonde matrix for each operator and return the smallest one

    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    INTEGER                               :: i,j,k,ip,iq,beta(ppm_dim),ineigh
    INTEGER                               :: ncoeff,n_odd,np_target
    CHARACTER(LEN = 256)                  :: caller='ppm_dcop_compute'
    CHARACTER(LEN = 256)                  :: cbuf
    CHARACTER(LEN = 32)                   :: myformat
    REAL(KIND(1.D0))                      :: t0
    REAL(MK)                              :: expo,byh
    REAL(MK),DIMENSION(:),ALLOCATABLE     :: byh0powerbeta
    REAL(MK)                              :: sv,dist2
    REAL(MK)                              :: nn_scaled
    REAL(MK), DIMENSION(:,:),POINTER      :: b=>NULL(),b_0=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z_copy=>NULL()
    REAL(MK),DIMENSION(:)  ,ALLOCATABLE   :: d2_one2all
    REAL(MK),DIMENSION(:,:),ALLOCATABLE   :: dx
    INTEGER, DIMENSION(:,:),ALLOCATABLE   :: alpha,gamma
    INTEGER                               :: order_a
    INTEGER,DIMENSION(ppm_dim)            :: degree
    INTEGER,DIMENSION(:),ALLOCATABLE      :: sum_degree
    REAL(MK),DIMENSION(:),POINTER         :: coeffs=>NULL()
    INTEGER,DIMENSION(3)                  :: ldc
    INTEGER                               :: degree_poly
    LOGICAL                               :: cartesian,isinterp,adaptive,vector
    LOGICAL                               :: with_ghosts

    REAL(MK), DIMENSION(:,:),  POINTER    :: xp1=>NULL()
    !!! particles (or points) where the operators are computed
    REAL(MK), DIMENSION(:,:),  POINTER    :: xp2=>NULL()
    !!! particles that contain the data to be used (xp1 can be equal to xp2) 
    !!! A case where xp1 .ne. xp2 is for interpolation.
    REAL(MK), DIMENSION(:),  POINTER      :: rcp=>NULL()
    REAL(MK), DIMENSION(:),  POINTER      :: nn_sq=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: eta=>NULL()
    INTEGER, DIMENSION(:),   POINTER      :: nvlist=>NULL()
    INTEGER, DIMENSION(:,:), POINTER      :: vlist=>NULL()
    INTEGER                               :: nterms
    !!! number of terms of the differential operator
    REAL(MK)                              :: c_value
    REAL(MK)                              :: min_sv_p

    TYPE(ppm_t_sop_d),POINTER  :: Pc2 => NULL()
    TYPE(ppm_t_operator_d),POINTER   :: op  => NULL()
    TYPE(ppm_t_neighlist_d),POINTER  :: Nlist => NULL()

    !!---------------------------------------------------------------------!
    !! Initialize
    !!---------------------------------------------------------------------!
    info = 0 ! change if error occurs
    CALL substart(caller,t0,info)

    IF (PRESENT(c)) THEN
        c_value=c
    ELSE
        c_value=1._MK
    ENDIF

    op => Pc%ops%vec(op_id)%t

    isinterp = op%flags(ppm_ops_interp)
    vector = op%flags(ppm_ops_vector)
    !if true, then each term of the differential opearator is stored as one
    !component in eta. This is used when computing e.g. the gradient opearator.
    !if false, the same input parameters would yield an operator approximating
    ! the divergence operator.
    with_ghosts = op%flags(ppm_ops_inc_ghosts)
    !if true, then the operator should be computed for ghost particles too. 
    !Note that the resulting values will be wrong for the ghost particles
    !that have some neighbours outside the ghost layers. Some of these particles
    !may also not have enough neighbours for the Vandermonde matrix to be
    !invertible. These particles will be skipped without raising a warning.


    Nlist => Pc%neighs%vec(op%neigh_id)%t
    IF (.NOT. Nlist%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Need to specify which set of particles &
            &   (Pc2) should be used for interpolation',&
            & 117,info)
        GOTO 9999
    ENDIF

    nterms = op%desc%nterms
    ALLOCATE(sum_degree(nterms),byh0powerbeta(nterms))

    cartesian=Pc%flags(ppm_part_cartesian)
    IF (cartesian .AND. nterms .GT. 1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Case where nterms>1 is not yet implemented for Cartesian particles',&
            129,info)
        GOTO 9999
    ENDIF

    !IF (Pc%adaptive) THEN
        !adaptive = .TRUE.
    !ELSE
        !adaptive = .FALSE.
    !ENDIF

    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_d)
        CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=with_ghosts)
        adaptive = .TRUE.
        IF (isinterp) THEN
            Pc2 => Pc%set_aPc%vec(op%P_id)%t
        ENDIF

        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%get(nn_sq,Pc2%nn_sq_id,with_ghosts=.TRUE.)
            !!! nearest-neighbour distances within Pc2 
            !!! (they must have been already computed)
        ENDIF
    CLASS DEFAULT
        byh = 1._MK/Pc%h_avg
        adaptive = .FALSE.
    END SELECT


    IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
        IF (Pc2%nn_sq_id .EQ. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                & 'need to call particles_nearest_neighbors first',162,info)
            GOTO 9999
        ENDIF
    ENDIF


    !Determine number of coefficients needed for this operator
    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        sum_degree(i) = SUM(degree)
        order_a=op%desc%order(i)

        degree_poly = sum_degree(i) + order_a - 1

        IF (degree_poly .LT. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                'Negative degree for polynomial basis',179,info)
            GOTO 9999
        ENDIF

        IF (cartesian) THEN
            n_odd = 0
            DO j = 1,ppm_dim
                n_odd = n_odd + MOD(degree(j),2)
            ENDDO
            ncoeff = binomial((sum_degree(i)-n_odd)/2 + &
                CEILING(order_a/2.0) -1 + ppm_dim,ppm_dim) 
        ELSE 
            ncoeff = binomial(degree_poly+ppm_dim,ppm_dim)
        ENDIF

        !write(*,*) 'degree: ',degree, sum_degree(i)
        !write(*,*) 'degree_poly: ',degree_poly, ncoeff
    ENDDO

    IF (ncoeff.LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Could not compute number of coefficients',201,info)
        GOTO 9999
    ENDIF

    ALLOCATE(gamma(ppm_dim,ncoeff),alpha(ppm_dim,ncoeff),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',208,info)
        GOTO 9999
    ENDIF ! Generate the polynomial basis for particle approximation
    !   alpha is the approximation basis
    !   gamma is the template for DC operators
    ip = 0
    alpha = 0 

    DO i=0,degree_poly

        loopj: DO j=0,i
            !if cartesian, it is not needed to compute coefficients 
            !for which gamma+order_d contains odd elements
            IF (cartesian) THEN 
                IF (MOD(j+degree(1),2)  .NE.0) CYCLE loopj
                IF (MOD(i-j+degree(2),2).NE.0) CYCLE loopj
            ENDIF
            ip=ip+1
            alpha(1,ip) = j
            alpha(2,ip) = i-j
        ENDDO loopj
    ENDDO

    IF (ip.NE.ncoeff) THEN
        WRITE(cbuf,*) 'Something wrong when computing coefficients. Theory: ',&
            ncoeff,', we have ',ip
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    ncoeff = ip
    gamma = alpha

    IF (Nlist%nneighmin .LT. ncoeff) THEN
        CALL ppm_write(ppm_rank,caller,'Not enough neighbours',info)
        WRITE(cbuf,*) 'For this DC-operator, we need ',&
            ncoeff,' neighbours. We have ',Nlist%nneighmin
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF


    ALLOCATE(d2_one2all(Nlist%nneighmax),dx(ppm_dim,Nlist%nneighmax),&
        Z(ncoeff,ncoeff),b(ncoeff,nterms),b_0(ncoeff,nterms),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',275,info)
        GOTO 9999
    ENDIF

    !only used to compute the SVD, mainly for debugging.
    IF(PRESENT(min_sv)) THEN
        min_sv = HUGE(1._MK)
        ALLOCATE(Z_copy(ncoeff,ncoeff))
    ENDIF

    IF (vector) THEN
        ldc(1) = Nlist%nneighmax*nterms; 
    ELSE
        ldc(1) = Nlist%nneighmax; 
    ENDIF
    IF (with_ghosts) THEN
        np_target = Pc%Mpart
    ELSE
        np_target = Pc%Npart
    ENDIF
    ldc(2) = np_target
    CALL ppm_alloc(op%ker,ldc,ppm_param_alloc_grow,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',299,info)
        GOTO 9999
    ENDIF
    eta => Pc%get_dcop(op_id,with_ghosts=with_ghosts)
    FORALL(i=1:ldc(1),j=1:np_target) eta(i,j)=0._MK

    !----------------------------------------------------------------------!
    ! Compute diff op weights
    !----------------------------------------------------------------------!
    b_0 = 0._MK

    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        DO j=1,ncoeff
            IF (MAXVAL(ABS(alpha(:,j)-degree)).EQ.0) THEN
                b_0(j,i)=(-1)**(sum_degree(i))*factorial_m(degree,ppm_dim)
            ENDIF
        ENDDO

        !When applicable, and for stability reasons, set the zeroth moment to 5
        IF (.NOT.isinterp) THEN
            IF (SUM(alpha(1:ppm_dim,1)).EQ. 0 .AND. MOD(sum_degree(i),2) .EQ.0)&
                b_0(1,i) = 5._MK
        ENDIF
    ENDDO
    
    IF (isinterp) THEN
        CALL Pc%get_xp(xp1,with_ghosts=with_ghosts)
        CALL Pc2%get_xp(xp2,with_ghosts=.TRUE.)
    ELSE
        CALL Pc%get_xp(xp1,with_ghosts=.TRUE.)
        xp2 => xp1
    ENDIF
    nvlist => Nlist%nvlist
    vlist => Nlist%vlist
    coeffs => op%desc%coeffs(1:nterms)

    particle_loop: DO ip = 1,np_target ! loop over all target particles

        IF (ip .GT. Pc%Npart .AND. nvlist(ip).LT.ncoeff) THEN
            !not enough neigbours for this ghost particle - skip it
            CYCLE particle_loop
        ENDIF

        Z = 0._MK
        b = b_0
        ! loop over their neighbors
        IF (adaptive) THEN
            !byh = 2._MK/rcp(ip)
            byh = 0.5_MK/rcp(ip)
        ENDIF


        neighbour_loop: DO ineigh = 1,nvlist(ip) 
            iq = vlist(ineigh,ip) ! index in the "old particles" set

            ! distance squared between the new particle and the old ones
            dx(1:ppm_dim,ineigh) = (xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))*byh
            d2_one2all(ineigh) = SUM(dx(1:ppm_dim,ineigh)**2)

            expo = exp(-c_value**2*d2_one2all(ineigh))

            ! Fill matrix Z
            ! moments in alpha order: (alphas = rows)
            ! coefficients in gamma order (gammas = cols):

            DO j=1,ncoeff
                DO i=1,ncoeff
                    beta = alpha(1:ppm_dim,i) + gamma(1:ppm_dim,j)

                    Z(i,j) = Z(i,j) + &
                        dx(1,ineigh)**beta(1) * &
                        dx(2,ineigh)**beta(2) * expo
                ENDDO
            ENDDO

        ENDDO neighbour_loop

        IF (isinterp) THEN
            DO i=1,nterms
                IF (sum_degree(i).NE.0) CYCLE
                ! Assemble the rhs for the linear system that has to be solved for 
                ! interpolating functions
                DO ineigh = 1,nvlist(ip)
                    !rescaled nearest-neighbour distance  
                    iq = vlist(ineigh,ip)
                    dist2 = SUM((xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))**2)
                    eta(ineigh,ip) = &
                        primitive_d(SQRT(dist2/nn_sq(iq)) / 0.9_MK)

                    !reuse the variable to assemble the rhs
                    DO j=1,ncoeff
                        b(j,i) = b(j,i) - &
                            eta(ineigh,ip)* &
                            dx(1,ineigh)**alpha(1,j) * dx(2,ineigh)**alpha(2,j)
                    ENDDO
                ENDDO
            ENDDO
        ENDIF


        CALL solveLSE_n_d(Z,b,nterms,info)
        ! now b contain the solutions to the LSEs A*x_i=b_i for i=1:nterms
        IF (info .NE. 0) THEN
            IF (ip .GT. Pc%Npart) THEN
                !ignore error in matrix inversion for ghost particles
                ! simply skip it
                CYCLE particle_loop
            ENDIF
            !writes the coordinate of the stencil that lead to the error
            IF (ppm_dim .EQ. 2 ) THEN
                myformat = TRIM(ADJUSTL('(2(E30.22))'))
            ELSE
                myformat = TRIM(ADJUSTL('(3(E30.22))'))
            ENDIF
            WRITE(9000,myformat) xp1(1:ppm_dim,ip)
            DO ineigh = 1,nvlist(ip)
                WRITE(9000,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'stencil written in file fort.9000',info)

            WRITE(9003,myformat) xp1(1:ppm_dim,ip)*byh
            DO ineigh = 1,nvlist(ip)
                WRITE(9003,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))*byh
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'h-scaled stencil written in file fort.9003',info)
            info = ppm_error_error
            CALL ppm_error(ppm_err_sub_failed,caller,&
                'Failed to solve the LSE', 472,info)
            GOTO 9999
        ENDIF

        DO i=1,nterms 
            byh0powerbeta(i) = byh**(sum_degree(i))
        ENDDO


        !------------------------------------------------------------------!
        ! Compute the operators
        !------------------------------------------------------------------!
        ! loop over old particles
        IF (isinterp) THEN
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo
                    ELSE
                        eta(ineigh,ip) = eta(ineigh,ip) + &
                            SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo

                            !note: do not factorise out expo, like for eta. 
                            ! eta_interp already contains some data (the primitive &
                            ! function) that should not be multiplied by expo.
                    ENDIF
                ENDDO
            ENDDO
        ELSE
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ELSE

                    eta(ineigh,ip) = eta(ineigh,ip) +&
                        SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ENDIF
                ENDDO
                IF (vector) THEN
                    eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) * expo
                ELSE
                    eta(ineigh,ip) = eta(ineigh,ip) * expo
                ENDIF
            ENDDO
        ENDIF

    ENDDO particle_loop

    coeffs=> NULL()
    CALL Pc%set_xp(xp1,read_only=.TRUE.)
    IF (isinterp) THEN
        CALL Pc2%set_xp(xp2,read_only=.TRUE.)
    ELSE
        xp2 => NULL()
    ENDIF
    eta => Pc%set_dcop(op_id)

    SELECT TYPE (Pc)
    TYPE IS (ppm_t_sop_d)
        CALL Pc%set(rcp,Pc%rcp_id,read_only=.TRUE.)
        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%set(nn_sq,Pc2%nn_sq_id,read_only=.TRUE.)
        ENDIF
    END SELECT

    !!---------------------------------------------------------------------!
    !! Finalize
    !!---------------------------------------------------------------------!
    DEALLOCATE(Z,b,b_0,d2_one2all,dx,gamma,alpha,sum_degree,byh0powerbeta)

    IF(PRESENT(min_sv)) THEN
        DEALLOCATE(Z_copy)
    ENDIF

    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE ppm_dcop_compute2d_d

SUBROUTINE ppm_dcop_compute3d_d(Pc,op_id,info,c,min_sv)
    !!! Computes generalized DC operators
    !!! if the optional argument interp is true, the routine uses
    !!! one set of particles (Pc2) as input data and
    !!! compute the differential opearator on the new set
    !!! If it has to do be interpolating (if the quantity to be computed
    !!! is the field itself, ie. if the degree of one term of the 
    !!! differential operator is zero), then the nearest-neighbour 
    !!! distances within Pc2 must have been already computed.
    USE ppm_module_error
    IMPLICIT NONE

    INTEGER, PARAMETER :: MK = ppm_kind_double
    !---------------------------------------------------------
    ! arguments
    !---------------------------------------------------------
    CLASS(ppm_t_particles_d)                        :: Pc
    !!! particles
    INTEGER,                             INTENT(IN   )   :: op_id
    !!! id of the operator kernel
    INTEGER,                             INTENT(  OUT)   :: info
    !!! non-zero on output if some error occurred
    !---------------------------------------------------------
    ! Optional arguments
    !---------------------------------------------------------
    REAL(MK),                  OPTIONAL, INTENT(IN   )   :: c
    !!! ratio h/epsilon
    REAL(MK),                  OPTIONAL, INTENT(  OUT)   :: min_sv
    !!! if present, compute the singular value decomposition of the 
    !!! vandermonde matrix for each operator and return the smallest one

    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    INTEGER                               :: i,j,k,ip,iq,beta(ppm_dim),ineigh
    INTEGER                               :: ncoeff,n_odd,np_target
    CHARACTER(LEN = 256)                  :: caller='ppm_dcop_compute'
    CHARACTER(LEN = 256)                  :: cbuf
    CHARACTER(LEN = 32)                   :: myformat
    REAL(KIND(1.D0))                      :: t0
    REAL(MK)                              :: expo,byh
    REAL(MK),DIMENSION(:),ALLOCATABLE     :: byh0powerbeta
    REAL(MK)                              :: sv,dist2
    REAL(MK)                              :: nn_scaled
    REAL(MK), DIMENSION(:,:),POINTER      :: b=>NULL(),b_0=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: Z_copy=>NULL()
    REAL(MK),DIMENSION(:)  ,ALLOCATABLE   :: d2_one2all
    REAL(MK),DIMENSION(:,:),ALLOCATABLE   :: dx
    INTEGER, DIMENSION(:,:),ALLOCATABLE   :: alpha,gamma
    INTEGER                               :: order_a
    INTEGER,DIMENSION(ppm_dim)            :: degree
    INTEGER,DIMENSION(:),ALLOCATABLE      :: sum_degree
    REAL(MK),DIMENSION(:),POINTER         :: coeffs=>NULL()
    INTEGER,DIMENSION(3)                  :: ldc
    INTEGER                               :: degree_poly
    LOGICAL                               :: cartesian,isinterp,adaptive,vector
    LOGICAL                               :: with_ghosts

    REAL(MK), DIMENSION(:,:),  POINTER    :: xp1=>NULL()
    !!! particles (or points) where the operators are computed
    REAL(MK), DIMENSION(:,:),  POINTER    :: xp2=>NULL()
    !!! particles that contain the data to be used (xp1 can be equal to xp2) 
    !!! A case where xp1 .ne. xp2 is for interpolation.
    REAL(MK), DIMENSION(:),  POINTER      :: rcp=>NULL()
    REAL(MK), DIMENSION(:),  POINTER      :: nn_sq=>NULL()
    REAL(MK), DIMENSION(:,:),POINTER      :: eta=>NULL()
    INTEGER, DIMENSION(:),   POINTER      :: nvlist=>NULL()
    INTEGER, DIMENSION(:,:), POINTER      :: vlist=>NULL()
    INTEGER                               :: nterms
    !!! number of terms of the differential operator
    REAL(MK)                              :: c_value
    REAL(MK)                              :: min_sv_p

    TYPE(ppm_t_sop_d),POINTER  :: Pc2 => NULL()
    TYPE(ppm_t_operator_d),POINTER   :: op  => NULL()
    TYPE(ppm_t_neighlist_d),POINTER  :: Nlist => NULL()

    !!---------------------------------------------------------------------!
    !! Initialize
    !!---------------------------------------------------------------------!
    info = 0 ! change if error occurs
    CALL substart(caller,t0,info)

    IF (PRESENT(c)) THEN
        c_value=c
    ELSE
        c_value=1._MK
    ENDIF

    op => Pc%ops%vec(op_id)%t

    isinterp = op%flags(ppm_ops_interp)
    vector = op%flags(ppm_ops_vector)
    !if true, then each term of the differential opearator is stored as one
    !component in eta. This is used when computing e.g. the gradient opearator.
    !if false, the same input parameters would yield an operator approximating
    ! the divergence operator.
    with_ghosts = op%flags(ppm_ops_inc_ghosts)
    !if true, then the operator should be computed for ghost particles too. 
    !Note that the resulting values will be wrong for the ghost particles
    !that have some neighbours outside the ghost layers. Some of these particles
    !may also not have enough neighbours for the Vandermonde matrix to be
    !invertible. These particles will be skipped without raising a warning.


    Nlist => Pc%neighs%vec(op%neigh_id)%t
    IF (.NOT. Nlist%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Need to specify which set of particles &
            &   (Pc2) should be used for interpolation',&
            & 117,info)
        GOTO 9999
    ENDIF

    nterms = op%desc%nterms
    ALLOCATE(sum_degree(nterms),byh0powerbeta(nterms))

    cartesian=Pc%flags(ppm_part_cartesian)
    IF (cartesian .AND. nterms .GT. 1) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Case where nterms>1 is not yet implemented for Cartesian particles',&
            129,info)
        GOTO 9999
    ENDIF

    !IF (Pc%adaptive) THEN
        !adaptive = .TRUE.
    !ELSE
        !adaptive = .FALSE.
    !ENDIF

    SELECT TYPE(Pc)
    TYPE IS (ppm_t_sop_d)
        CALL Pc%get(rcp,Pc%rcp_id,with_ghosts=with_ghosts)
        adaptive = .TRUE.
        IF (isinterp) THEN
            Pc2 => Pc%set_aPc%vec(op%P_id)%t
        ENDIF

        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%get(nn_sq,Pc2%nn_sq_id,with_ghosts=.TRUE.)
            !!! nearest-neighbour distances within Pc2 
            !!! (they must have been already computed)
        ENDIF
    CLASS DEFAULT
        byh = 1._MK/Pc%h_avg
        adaptive = .FALSE.
    END SELECT


    IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
        IF (Pc2%nn_sq_id .EQ. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                & 'need to call particles_nearest_neighbors first',162,info)
            GOTO 9999
        ENDIF
    ENDIF


    !Determine number of coefficients needed for this operator
    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        sum_degree(i) = SUM(degree)
        order_a=op%desc%order(i)

        degree_poly = sum_degree(i) + order_a - 1

        IF (degree_poly .LT. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,&
                'Negative degree for polynomial basis',179,info)
            GOTO 9999
        ENDIF

        IF (cartesian) THEN
            n_odd = 0
            DO j = 1,ppm_dim
                n_odd = n_odd + MOD(degree(j),2)
            ENDDO
            ncoeff = binomial((sum_degree(i)-n_odd)/2 + &
                CEILING(order_a/2.0) -1 + ppm_dim,ppm_dim) 
        ELSE 
            ncoeff = binomial(degree_poly+ppm_dim,ppm_dim)
        ENDIF

        !write(*,*) 'degree: ',degree, sum_degree(i)
        !write(*,*) 'degree_poly: ',degree_poly, ncoeff
    ENDDO

    IF (ncoeff.LE.0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,&
            'Could not compute number of coefficients',201,info)
        GOTO 9999
    ENDIF

    ALLOCATE(gamma(ppm_dim,ncoeff),alpha(ppm_dim,ncoeff),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',208,info)
        GOTO 9999
    ENDIF ! Generate the polynomial basis for particle approximation
    !   alpha is the approximation basis
    !   gamma is the template for DC operators
    ip = 0
    alpha = 0 

    DO i=0,degree_poly

        DO j=0,i
            loopk: DO k=0,i-j
                !if cartesian, it is not needed to compute coefficients 
                !for which gamma+order_d contains odd elements
                IF (cartesian) THEN
                    IF (MOD(j+degree(1),2)    .NE.0) CYCLE loopk
                    IF (MOD(k+degree(2),2)    .NE.0) CYCLE loopk
                    IF (MOD(i-j-k+degree(3),2).NE.0) CYCLE loopk
                ENDIF

                ip=ip+1
                alpha(1,ip) = j
                alpha(2,ip) = k
                alpha(3,ip) = i-j-k
            ENDDO loopk
        ENDDO
    ENDDO

    IF (ip.NE.ncoeff) THEN
        WRITE(cbuf,*) 'Something wrong when computing coefficients. Theory: ',&
            ncoeff,', we have ',ip
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF

    ncoeff = ip
    gamma = alpha

    IF (Nlist%nneighmin .LT. ncoeff) THEN
        CALL ppm_write(ppm_rank,caller,'Not enough neighbours',info)
        WRITE(cbuf,*) 'For this DC-operator, we need ',&
            ncoeff,' neighbours. We have ',Nlist%nneighmin
        CALL ppm_write(ppm_rank,caller,cbuf,info)
        info = -1
        GOTO 9999
    ENDIF


    ALLOCATE(d2_one2all(Nlist%nneighmax),dx(ppm_dim,Nlist%nneighmax),&
        Z(ncoeff,ncoeff),b(ncoeff,nterms),b_0(ncoeff,nterms),STAT=info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',275,info)
        GOTO 9999
    ENDIF

    !only used to compute the SVD, mainly for debugging.
    IF(PRESENT(min_sv)) THEN
        min_sv = HUGE(1._MK)
        ALLOCATE(Z_copy(ncoeff,ncoeff))
    ENDIF

    IF (vector) THEN
        ldc(1) = Nlist%nneighmax*nterms; 
    ELSE
        ldc(1) = Nlist%nneighmax; 
    ENDIF
    IF (with_ghosts) THEN
        np_target = Pc%Mpart
    ELSE
        np_target = Pc%Npart
    ENDIF
    ldc(2) = np_target
    CALL ppm_alloc(op%ker,ldc,ppm_param_alloc_grow,info)
    IF (info .NE. 0) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_alloc,caller,'Allocation failed',299,info)
        GOTO 9999
    ENDIF
    eta => Pc%get_dcop(op_id,with_ghosts=with_ghosts)
    FORALL(i=1:ldc(1),j=1:np_target) eta(i,j)=0._MK

    !----------------------------------------------------------------------!
    ! Compute diff op weights
    !----------------------------------------------------------------------!
    b_0 = 0._MK

    DO i=1,nterms
        degree = op%desc%degree(1+(i-1)*ppm_dim:i*ppm_dim)
        DO j=1,ncoeff
            IF (MAXVAL(ABS(alpha(:,j)-degree)).EQ.0) THEN
                b_0(j,i)=(-1)**(sum_degree(i))*factorial_m(degree,ppm_dim)
            ENDIF
        ENDDO

        !When applicable, and for stability reasons, set the zeroth moment to 5
        IF (.NOT.isinterp) THEN
            IF (SUM(alpha(1:ppm_dim,1)).EQ. 0 .AND. MOD(sum_degree(i),2) .EQ.0)&
                b_0(1,i) = 5._MK
        ENDIF
    ENDDO
    
    IF (isinterp) THEN
        CALL Pc%get_xp(xp1,with_ghosts=with_ghosts)
        CALL Pc2%get_xp(xp2,with_ghosts=.TRUE.)
    ELSE
        CALL Pc%get_xp(xp1,with_ghosts=.TRUE.)
        xp2 => xp1
    ENDIF
    nvlist => Nlist%nvlist
    vlist => Nlist%vlist
    coeffs => op%desc%coeffs(1:nterms)

    particle_loop: DO ip = 1,np_target ! loop over all target particles

        IF (ip .GT. Pc%Npart .AND. nvlist(ip).LT.ncoeff) THEN
            !not enough neigbours for this ghost particle - skip it
            CYCLE particle_loop
        ENDIF

        Z = 0._MK
        b = b_0
        ! loop over their neighbors
        IF (adaptive) THEN
            !byh = 2._MK/rcp(ip)
            byh = 0.5_MK/rcp(ip)
        ENDIF


        neighbour_loop: DO ineigh = 1,nvlist(ip) 
            iq = vlist(ineigh,ip) ! index in the "old particles" set

            ! distance squared between the new particle and the old ones
            dx(1:ppm_dim,ineigh) = (xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))*byh
            d2_one2all(ineigh) = SUM(dx(1:ppm_dim,ineigh)**2)

            expo = exp(-c_value**2*d2_one2all(ineigh))

            ! Fill matrix Z
            ! moments in alpha order: (alphas = rows)
            ! coefficients in gamma order (gammas = cols):

            DO j=1,ncoeff
                DO i=1,ncoeff
                    beta = alpha(1:ppm_dim,i) + gamma(1:ppm_dim,j)

                    Z(i,j) = Z(i,j) + &
                        dx(1,ineigh)**beta(1) * &
                        dx(3,ineigh)**beta(3) * &
                        dx(2,ineigh)**beta(2) * expo
                ENDDO
            ENDDO

        ENDDO neighbour_loop

        IF (isinterp) THEN
            DO i=1,nterms
                IF (sum_degree(i).NE.0) CYCLE
                ! Assemble the rhs for the linear system that has to be solved for 
                ! interpolating functions
                DO ineigh = 1,nvlist(ip)
                    !rescaled nearest-neighbour distance  
                    iq = vlist(ineigh,ip)
                    dist2 = SUM((xp1(1:ppm_dim,ip) - xp2(1:ppm_dim,iq))**2)
                    eta(ineigh,ip) = &
                        primitive_d(SQRT(dist2/nn_sq(iq)) / 0.9_MK)

                    !reuse the variable to assemble the rhs
                    DO j=1,ncoeff
                        b(j,i) = b(j,i) - &
                            eta(ineigh,ip)* &
                            dx(1,ineigh)**alpha(1,j) * dx(2,ineigh)**alpha(2,j) * &
                                dx(3,ineigh)**alpha(3,j)
                    ENDDO
                ENDDO
            ENDDO
        ENDIF


        CALL solveLSE_n_d(Z,b,nterms,info)
        ! now b contain the solutions to the LSEs A*x_i=b_i for i=1:nterms
        IF (info .NE. 0) THEN
            IF (ip .GT. Pc%Npart) THEN
                !ignore error in matrix inversion for ghost particles
                ! simply skip it
                CYCLE particle_loop
            ENDIF
            !writes the coordinate of the stencil that lead to the error
            IF (ppm_dim .EQ. 2 ) THEN
                myformat = TRIM(ADJUSTL('(2(E30.22))'))
            ELSE
                myformat = TRIM(ADJUSTL('(3(E30.22))'))
            ENDIF
            WRITE(9000,myformat) xp1(1:ppm_dim,ip)
            DO ineigh = 1,nvlist(ip)
                WRITE(9000,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'stencil written in file fort.9000',info)

            WRITE(9003,myformat) xp1(1:ppm_dim,ip)*byh
            DO ineigh = 1,nvlist(ip)
                WRITE(9003,myformat) xp2(1:ppm_dim,vlist(ineigh,ip))*byh
            ENDDO
            CALL ppm_write(ppm_rank,caller,&
                'h-scaled stencil written in file fort.9003',info)
            info = ppm_error_error
            CALL ppm_error(ppm_err_sub_failed,caller,&
                'Failed to solve the LSE', 472,info)
            GOTO 9999
        ENDIF

        DO i=1,nterms 
            byh0powerbeta(i) = byh**(sum_degree(i))
        ENDDO


        !------------------------------------------------------------------!
        ! Compute the operators
        !------------------------------------------------------------------!
        ! loop over old particles
        IF (isinterp) THEN
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(3,ineigh)**gamma(3,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo
                    ELSE
                        eta(ineigh,ip) = eta(ineigh,ip) + &
                            SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                            dx(1,ineigh)**gamma(1,j)* &
                            dx(3,ineigh)**gamma(3,j)* &
                            dx(2,ineigh)**gamma(2,j)* expo

                            !note: do not factorise out expo, like for eta. 
                            ! eta_interp already contains some data (the primitive &
                            ! function) that should not be multiplied by expo.
                    ENDIF
                ENDDO
            ENDDO
        ELSE
            DO ineigh = 1,nvlist(ip) 
                expo = exp(-c_value**2*d2_one2all(ineigh))
                DO j=1,ncoeff
                    IF (vector) THEN
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                            eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) + &
                            b(j,1:nterms)*coeffs*byh0powerbeta* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(3,ineigh)**gamma(3,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ELSE

                    eta(ineigh,ip) = eta(ineigh,ip) +&
                        SUM(b(j,1:nterms)*coeffs*byh0powerbeta)* &
                        dx(1,ineigh)**gamma(1,j)* &
                        dx(3,ineigh)**gamma(3,j)* &
                        dx(2,ineigh)**gamma(2,j)
                    ENDIF
                ENDDO
                IF (vector) THEN
                    eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) = &
                        eta(1+(ineigh-1)*nterms:ineigh*nterms,ip) * expo
                ELSE
                    eta(ineigh,ip) = eta(ineigh,ip) * expo
                ENDIF
            ENDDO
        ENDIF

    ENDDO particle_loop

    coeffs=> NULL()
    CALL Pc%set_xp(xp1,read_only=.TRUE.)
    IF (isinterp) THEN
        CALL Pc2%set_xp(xp2,read_only=.TRUE.)
    ELSE
        xp2 => NULL()
    ENDIF
    eta => Pc%set_dcop(op_id)

    SELECT TYPE (Pc)
    TYPE IS (ppm_t_sop_d)
        CALL Pc%set(rcp,Pc%rcp_id,read_only=.TRUE.)
        IF (isinterp .AND. MINVAL(sum_degree).EQ.0) THEN
            CALL Pc2%set(nn_sq,Pc2%nn_sq_id,read_only=.TRUE.)
        ENDIF
    END SELECT

    !!---------------------------------------------------------------------!
    !! Finalize
    !!---------------------------------------------------------------------!
    DEALLOCATE(Z,b,b_0,d2_one2all,dx,gamma,alpha,sum_degree,byh0powerbeta)

    IF(PRESENT(min_sv)) THEN
        DEALLOCATE(Z_copy)
    ENDIF

    CALL substop(caller,t0,info)

    9999 CONTINUE ! jump here upon error

END SUBROUTINE ppm_dcop_compute3d_d


!BEGIN
FUNCTION begin_op_d(this) RESULT (iterator)
    CLASS(ppm_c_operators_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_d),   POINTER      :: iterator

    this%iter_id = this%min_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%min_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION begin_op_d

FUNCTION begin_neigh_d(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_d),   POINTER      :: iterator

    this%iter_id = this%min_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%min_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION begin_neigh_d

FUNCTION begin_prop_d(this) RESULT (iterator)
    CLASS(ppm_c_props_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_d),POINTER   :: iterator

    this%iter_id = this%min_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%min_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION begin_prop_d

!LAST
FUNCTION last_op_d(this) RESULT (iterator)
    CLASS(ppm_c_operators_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_d),   POINTER      :: iterator

    this%iter_id = this%max_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%max_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION last_op_d

FUNCTION last_neigh_d(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_d),   POINTER      :: iterator

    this%iter_id = this%max_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%max_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION last_neigh_d

FUNCTION last_prop_d(this) RESULT (iterator)
    CLASS(ppm_c_props_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_d),POINTER   :: iterator

    this%iter_id = this%max_id
    IF (this%nb.GT.0) THEN
        iterator => this%vec(this%max_id)%t
    ELSE
        iterator => NULL()
    ENDIF

END FUNCTION last_prop_d


!NEXT
FUNCTION next_op_d(this) RESULT (iterator)
    CLASS(ppm_c_operators_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_d),   POINTER      :: iterator

    DO WHILE(this%iter_id.LT.this%max_id)
        this%iter_id = this%iter_id + 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN
       
END FUNCTION next_op_d

FUNCTION next_neigh_d(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_d),  INTENT(INOUT):: this
    TYPE(ppm_t_neighlist_d),   POINTER      :: iterator

    DO WHILE(this%iter_id.LT.this%max_id)
        this%iter_id = this%iter_id + 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION next_neigh_d

FUNCTION next_prop_d(this) RESULT (iterator)
    CLASS(ppm_c_props_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_d),POINTER   :: iterator

    DO WHILE(this%iter_id.LT.this%max_id)
        this%iter_id = this%iter_id + 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION next_prop_d


!PREVIOUS
FUNCTION prev_op_d(this) RESULT (iterator)
    CLASS(ppm_c_operators_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_d),   POINTER      :: iterator

    DO WHILE(this%iter_id.GT.this%min_id)
        this%iter_id = this%iter_id - 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN
       
END FUNCTION prev_op_d

FUNCTION prev_neigh_d(this) RESULT (iterator)
    CLASS(ppm_c_neighlists_d),  INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_d),   POINTER      :: iterator

    DO WHILE(this%iter_id.GT.this%min_id)
        this%iter_id = this%iter_id - 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION prev_neigh_d

FUNCTION prev_prop_d(this) RESULT (iterator)
    CLASS(ppm_c_props_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_d),POINTER   :: iterator

    DO WHILE(this%iter_id.GT.this%min_id)
        this%iter_id = this%iter_id - 1
        IF (ASSOCIATED(this%vec(this%iter_id)%t)) THEN 
            iterator => this%vec(this%iter_id)%t
            RETURN
        ENDIF
    ENDDO
    iterator => NULL()
    RETURN

END FUNCTION prev_prop_d

! Destructors
SUBROUTINE op_container_destroy_d(this,info)
    CLASS(ppm_c_operators_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_operator_d),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    info = 0
    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec)
    NULLIFY(this%vec)
    this%min_id = HUGE(1)
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

END SUBROUTINE op_container_destroy_d

SUBROUTINE neigh_container_destroy_d(this,info)
    CLASS(ppm_c_neighlists_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_neighlist_d),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    info = 0
    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec)
    NULLIFY(this%vec)
    this%min_id = HUGE(1)
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

END SUBROUTINE neigh_container_destroy_d

SUBROUTINE prop_container_destroy_d(this,info)
    CLASS(ppm_c_props_d), INTENT(INOUT)   :: this
    TYPE(ppm_t_part_prop_d),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    info = 0
    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec)
    NULLIFY(this%vec)
    this%min_id = HUGE(1)
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

END SUBROUTINE prop_container_destroy_d
SUBROUTINE get_vlist_d(Pc,nvlist,vlist,nlid)
    !!! returns pointers to the arrays nvlist and vlist
    !!! that contain the Verlet lists for the neighbour list
    !!! of ID nlid.
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,DIMENSION(:),        POINTER  :: nvlist
    !!! number of neighbours for each particle
    INTEGER,DIMENSION(:,:),      POINTER  :: vlist
    !!! verlet list
    INTEGER                               :: nlid
    !!! id of the neighbour list 
    INTEGER                               :: info


    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    CHARACTER(LEN = ppm_char)             :: caller = 'get_vlist'

    
    nvlist => NULL()
    vlist => NULL()

    IF (.NOT.Pc%neighs%exists(nlid)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour list is invalid or not allocated',&
            &  28,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%neighs%vec(nlid)%t%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour lists have not been computed',&
            &  36,info)
        GOTO 9999
    ENDIF

    nvlist => Pc%neighs%vec(nlid)%t%nvlist
    vlist => Pc%neighs%vec(nlid)%t%vlist


    9999 CONTINUE

END SUBROUTINE get_vlist_d

SUBROUTINE get_nvlist_d(Pc,nvlist,nlid)
    !!! returns a pointer to the array of nb of neighbors
    !!! for the neighbour list of id nlID
    CLASS(ppm_t_particles_d)         :: Pc
    INTEGER,DIMENSION(:),        POINTER  :: nvlist
    !!! number of neighbours for each particle
    INTEGER                               :: nlid
    !!! id of the neighbour list 
    INTEGER                               :: info

    !---------------------------------------------------------
    ! local variables
    !---------------------------------------------------------
    CHARACTER(LEN = ppm_char)             :: caller = 'get_nvlist'
    
    nvlist => NULL()

    IF (.NOT.Pc%neighs%exists(nlid)) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour list is invalid or not allocated',&
            &  69,info)
        GOTO 9999
    ENDIF

    IF (.NOT.Pc%neighs%vec(nlid)%t%uptodate) THEN
        info = ppm_error_error
        CALL ppm_error(ppm_err_argument,caller,   &
            &  'neighbour lists have not been computed',&
            &  77,info)
        GOTO 9999
    ENDIF

    nvlist => Pc%neighs%vec(nlid)%t%nvlist

    9999 CONTINUE

END SUBROUTINE get_nvlist_d




      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1d_s(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      REAL(MK), DIMENSION(:  ), POINTER    :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_single) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-single into single ',211,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = ppm_recvbuffers(ibuffer)
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1d_s


      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1di_s(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      INTEGER , DIMENSION(:  ), POINTER    :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_integer) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-integer into integer ',241,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = INT(ppm_recvbufferd(ibuffer))
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = INT(ppm_recvbuffers(ibuffer))
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1di_s


      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1dl_s(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      LOGICAL , DIMENSION(:  ), POINTER    :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_logical) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-logical into logical ',248,info)
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            IF (ppm_recvbufferd(ibuffer) .GT.     &
     &         (1.0_ppm_kind_double-ppm_myepsd)) THEN
               pdata(ipart) = .TRUE.
            ELSE
               pdata(ipart) = .FALSE.
            ENDIF 
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            IF (ppm_recvbuffers(ibuffer) .GT.      &
     &         (1.0_ppm_kind_single-ppm_myepss)) THEN
               pdata(ipart) = .TRUE.
            ELSE
               pdata(ipart) = .FALSE.
            ENDIF 
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1dl_s


      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1dc_s(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      COMPLEX(MK), DIMENSION(:  ), POINTER :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      ! for complex, the effective dimension is half the data dimension
      edim = bdim/2
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_single) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-single-complex into single-complex',  &
     &       226,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 2
            pdata(ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &          ppm_recvbufferd(ibuffer),ppm_kind_single)
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 2
            pdata(ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &          ppm_recvbuffers(ibuffer),ppm_kind_double)
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1dc_s



      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2d_s(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      REAL(MK), DIMENSION(:,:), POINTER    :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_single) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-single into single ',211,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 1
               pdata(5,ipart) = REAL(ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = REAL(ppm_recvbufferd(ibuffer),       &
     &                ppm_kind_single)
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbuffers(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbuffers(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = ppm_recvbuffers(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = ppm_recvbuffers(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = ppm_recvbuffers(ibuffer)
               ibuffer = ibuffer + 1
               pdata(5,ipart) = ppm_recvbuffers(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = ppm_recvbuffers(ibuffer)
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2d_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2di_s(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      INTEGER , DIMENSION(:,:), POINTER    :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_integer) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-integer into integer ',241,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(5,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = INT(ppm_recvbufferd(ibuffer))
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(5,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = INT(ppm_recvbuffers(ibuffer))
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2di_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2dl_s(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      LOGICAL , DIMENSION(:,:), POINTER    :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_logical) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-logical into logical ',248,info)
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(5,ipart) = .TRUE.
               ELSE
                  pdata(5,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  IF (ppm_recvbufferd(ibuffer) .GT.     &
     &               (1.0_ppm_kind_double-ppm_myepsd)) THEN
                     pdata(k,ipart) = .TRUE.
                  ELSE
                     pdata(k,ipart) = .FALSE.
                  ENDIF 
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(5,ipart) = .TRUE.
               ELSE
                  pdata(5,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  IF (ppm_recvbuffers(ibuffer) .GT.      &
     &               (1.0_ppm_kind_single-ppm_myepss)) THEN
                     pdata(k,ipart) = .TRUE.
                  ELSE
                     pdata(k,ipart) = .FALSE.
                  ENDIF 
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2dl_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2dc_s(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)        :: Pc
      INTEGER                              :: mapID
      COMPLEX(MK), DIMENSION(:,:), POINTER :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      ! for complex, the effective dimension is half the data dimension
      edim = bdim/2
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_single) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-single-complex into single-complex',  &
     &       226,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(5,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 2
                  pdata(k,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &                ppm_recvbufferd(ibuffer),ppm_kind_single)
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(5,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 2
                  pdata(k,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &                ppm_recvbuffers(ibuffer),ppm_kind_double)
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2dc_s


      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1d_s(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      REAL(MK), DIMENSION(:  ), INTENT(IN   )    :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_single

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(pdata(ipart),ppm_kind_double)
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = pdata(ipart)
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1d_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1di_s(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      INTEGER , DIMENSION(:  ), INTENT(IN   )    :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_integer

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(pdata(ipart),ppm_kind_double)
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(pdata(ipart),ppm_kind_single)
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1di_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1dl_s(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      LOGICAL , DIMENSION(:  ), INTENT(IN   )    :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_logical

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               IF (pdata(ipart)) THEN
                  ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
               ELSE
                  ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
               ENDIF
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               IF (pdata(ipart)) THEN
                  ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
               ELSE
                  ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
               ENDIF
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1dl_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1dc_s(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      COMPLEX(MK), DIMENSION(:  ), INTENT(IN   ) :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = 2*lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_single

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(pdata(ipart),ppm_kind_double)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(ipart)),  &
     &             ppm_kind_double)
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(pdata(ipart),ppm_kind_single)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(ipart)),  &
     &             ppm_kind_single)
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1dc_s


      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2d_s(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      REAL(MK), DIMENSION(:,:), INTENT(IN   )    :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_single

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(5,ipart),   &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) = REAL(pdata(k,ipart),   &
     &                   ppm_kind_double)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(1,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(2,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(2,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(3,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(2,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(3,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(4,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(2,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(3,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(4,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = pdata(5,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = pdata(k,ipart)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2d_s
      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2di_s(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      INTEGER , DIMENSION(:,:), INTENT(IN   )    :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_integer

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(4,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(4,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(5,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) = REAL(pdata(k,ipart),    &
     &                   ppm_kind_double)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(5,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(pdata(k,ipart),   &
     &                   ppm_kind_single)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2di_s
      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2dl_s(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      LOGICAL , DIMENSION(:,:), INTENT(IN   )    :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_logical

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(5,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     IF (pdata(k,ipart)) THEN
                        ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                     ELSE
                        ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                     ENDIF
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(5,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     IF (pdata(k,ipart)) THEN
                        ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                     ELSE
                        ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                     ENDIF
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2dl_s
      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2dc_s(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      COMPLEX(MK), DIMENSION(:,:), INTENT(IN   ) :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = 2*lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_single

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(3,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(3,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(4,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(3,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(4,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(5,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(5,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) =         &
     &                          REAL(pdata(k,ipart),ppm_kind_double)
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(k,ipart)),  &
     &                   ppm_kind_double)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(5,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(5,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(pdata(k,ipart),   &
     &                   ppm_kind_single)
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(k,ipart)),  &
     &                   ppm_kind_single)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2dc_s

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_send
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_send_s(Pc,mapID,info)
      !!! This routine performs the actual send/recv of the particles and all
      !!! pushed data.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data. The
      !!! packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! The two send/recv of the integers should be combined into one
      !!! send/receive

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------
      INCLUDE 'mpif.h'
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_s)           :: Pc
      !!! Particle set
      INTEGER                 , INTENT(IN   ) :: mapID
      !!! mapping ID
      INTEGER                 , INTENT(  OUT) :: info
      !!! Return status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldl,ldu
      INTEGER               :: i,j,k,idom,nbuffer,ibuffer,jbuffer,bdim,sbdim
      INTEGER               :: iopt,count,tag1,qpart,msend,mrecv
      INTEGER               :: npart_send,npart_recv
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller ='map_part_send'
      REAL(ppm_kind_double) :: t0
      INTEGER, DIMENSION(MPI_STATUS_SIZE) :: status
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)
      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 3) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,caller,    &
     &          'Buffer is empty: skipping send!',101,info)
        ENDIF
        GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Allocate
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow
      ldu(1) = MAX(ppm_nsendlist,1)
      IF ((ppm_nsendlist.NE.old_nsendlist) .OR.  &
     &    (ppm_buffer_set.NE.old_buffer_set)) THEN
          old_nsendlist = ppm_nsendlist
          old_buffer_set = ppm_buffer_set
          CALL ppm_alloc(nsend,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'send counter NSEND',119,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(nrecv,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'receive counter NRECV',126,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(psend,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle send counter PSEND',133,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(precv,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle receive counter PRECV',140,info)
              GOTO 9999
          ENDIF
          ldu(2) = ppm_buffer_set 
          CALL ppm_alloc(pp,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'work buffer PP',148,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(qq,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'work buffer QQ',155,info)
              GOTO 9999
          ENDIF
      ENDIF
      !-------------------------------------------------------------------------
      !  Count the total size of the buffer dimensions 
      !  It is handy... simplifies many summations, avoids loops, etc...
      !-------------------------------------------------------------------------
      sbdim = 0
      DO j=1,ppm_buffer_set
         sbdim    = sbdim + ppm_buffer_dim(j)
      ENDDO
      !-------------------------------------------------------------------------
      !  Count the size of the buffer that will NOT be sent
      !-------------------------------------------------------------------------
      qpart   = (ppm_psendbuffer(2) - ppm_psendbuffer(1))
      ibuffer = sbdim*qpart

      !-------------------------------------------------------------------------
      !  Initialize the counter for the total set of new particles 
      !JHW 20060928     IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get.OR. &
          ppm_map_type.EQ.ppm_param_map_ghost_put) THEN
         Mpart = qpart + Npart
      ELSE
         Mpart = qpart
      ENDIF

      !-------------------------------------------------------------------------
      !  Count the size of the buffer that WILL be sent
      !-------------------------------------------------------------------------
      ppm_nrecvbuffer = ibuffer
      nsend(1)        = ibuffer
      nrecv(1)        = ibuffer
      psend(1)        = qpart
      precv(1)        = qpart
      mrecv           = -1
      msend           = -1

      DO k=2,ppm_nsendlist

         !----------------------------------------------------------------------
         !  The number of particles send off to the k-th processor in the 
         !  sendlist
         !----------------------------------------------------------------------
         qpart    = (ppm_psendbuffer(k+1) - ppm_psendbuffer(k))

         !----------------------------------------------------------------------
         !  Store the number of particles to send
         !----------------------------------------------------------------------
         psend(k) = qpart ! store the number of particles to send 

         !----------------------------------------------------------------------
         !  Store the size of the data to be send
         !----------------------------------------------------------------------
         nsend(k) = sbdim*qpart

         !----------------------------------------------------------------------
         !  Make a send/recv of the number of particles and data size to that 
         !  has to be send/recv
         !----------------------------------------------------------------------
         ! The following IF is needed in order to skip "dummy"
         ! communication rounds where the current processor has to wait
         ! (only needed in the partial mapping).
         IF (ppm_isendlist(k) .GE. 0 .AND. ppm_irecvlist(k) .GE. 0) THEN
             tag1 = 100
             IF (ppm_debug .GT. 1) THEN
                 WRITE(mesg,'(A,I5,2(A,I9))') 'sending to ',   &
     &               ppm_isendlist(k),', nsend=',nsend(k),', psend=',psend(k)
                 CALL ppm_write(ppm_rank,caller,mesg,info)
             ENDIF
             CALL MPI_SendRecv(psend(k),1,MPI_INTEGER,ppm_isendlist(k),tag1, &
     &                         precv(k),1,MPI_INTEGER,ppm_irecvlist(k),tag1, &
     &                         ppm_comm,status,info)
     
             ! Compute nrecv(k) from precv(k)
             nrecv(k) = sbdim*precv(k)

             IF (ppm_debug .GT. 1) THEN
                 WRITE(mesg,'(A,I5,2(A,I9))') 'received from ',   &
     &               ppm_irecvlist(k),', nrecv=',nrecv(k),', precv=',precv(k)
                 CALL ppm_write(ppm_rank,caller,mesg,info)
             ENDIF
         ELSE
             ! skip this round, i.e. neither send nor receive any
             ! particles.
             nrecv(k) = 0
             precv(k) = 0
         ENDIF

      ENDDO
      !----------------------------------------------------------------------
      !  Find the required (maximum) size of the send/recv buffers
      !----------------------------------------------------------------------
      DO k=2,ppm_nsendlist
         IF (mrecv.LE.nrecv(k)) mrecv = nrecv(k)
      ENDDO
      DO k=2,ppm_nsendlist
         IF (msend.LE.nsend(k)) msend = nsend(k)
      ENDDO
      !----------------------------------------------------------------------
      !  Increment the total receive buffer
      !----------------------------------------------------------------------
      DO k=2,ppm_nsendlist
         ppm_nrecvbuffer = ppm_nrecvbuffer + nrecv(k)
      ENDDO
      !----------------------------------------------------------------------
      !  Increment the total number of particle to receive
      !----------------------------------------------------------------------
      DO k=2,ppm_nsendlist
         Mpart           = Mpart           + precv(k)
      ENDDO
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'mrecv=',mrecv,', msend=',msend
          CALL ppm_write(ppm_rank,caller,mesg,info)
          WRITE(mesg,'(A,I9)') 'ppm_nrecvbuffer=',ppm_nrecvbuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
          WRITE(mesg,'(A,I9)') 'Mpart=',Mpart
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF


      !-------------------------------------------------------------------------
      !  Allocate the memory for the copy of the particle buffer
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow
      ldu(1) = ppm_nrecvbuffer 
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
      ELSE
         CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
      ENDIF 
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'global receive buffer PPM_RECVBUFFER',293,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Allocate memory for the smaller send and receive buffer
      !-------------------------------------------------------------------------
      ! only allocate if there actually is anything to be sent/recvd with
      ! other processors. Otherwise mrecv and msend would both still be -1
      ! (as initialized above) and the alloc would throw a FATAL. This was
      ! Bug ID 000012.
      IF (ppm_nsendlist .GT. 1) THEN
          iopt   = ppm_param_alloc_grow
          ldu(1) = MAX(mrecv,1)
          IF (ppm_kind.EQ.ppm_kind_double) THEN
             CALL ppm_alloc(recvd,ldu,iopt,info)
          ELSE
             CALL ppm_alloc(recvs,ldu,iopt,info)
          ENDIF 
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'local receive buffer RECV',315,info)
              GOTO 9999
          ENDIF

          ldu(1) = MAX(msend,1)
          IF (ppm_kind.EQ.ppm_kind_double) THEN
             CALL ppm_alloc(sendd,ldu,iopt,info)
          ELSE
             CALL ppm_alloc(sends,ldu,iopt,info)
          ENDIF 
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'local send buffer SEND',328,info)
              GOTO 9999
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Debugging print of the number of sets in the buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ppm_buffer_set=',ppm_buffer_set
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  Compute the total number of particles to send 
      !  As it is now, this should be equal to Npart
      !-------------------------------------------------------------------------
      npart_send = 0
      DO j=1,ppm_nsendlist
         npart_send = npart_send + psend(j)
      ENDDO

      !-------------------------------------------------------------------------
      !  Compute the pointer to the position of the data in the main send 
      !  buffer 
      !-------------------------------------------------------------------------
      DO k=1,ppm_buffer_set
         IF (k.EQ.1) THEN
            qq(1,k) = 1
         ELSE
            qq(1,k) = qq(1,k-1) + npart_send*ppm_buffer_dim(k-1)
         ENDIF
         bdim    = ppm_buffer_dim(k)
         DO j=2,ppm_nsendlist
            qq(j,k) = qq(j-1,k) + psend(j-1)*bdim
            IF (ppm_debug .GT. 1) THEN
                WRITE(mesg,'(A,I9)') 'qq(j,k)=',qq(j,k)
                CALL ppm_write(ppm_rank,caller,mesg,info)
            ENDIF
         ENDDO
      ENDDO


      !-------------------------------------------------------------------------
      !  Compute the total number of particles to receive
      !  As it is now, this should be equal to Mpart
      !-------------------------------------------------------------------------
      npart_recv = 0
      DO j=1,ppm_nsendlist
         npart_recv = npart_recv + precv(j)
      ENDDO

      !-------------------------------------------------------------------------
      !  Compute the pointer to the position of the data in the main receive 
      !  buffer 
      !-------------------------------------------------------------------------
      DO k=1,ppm_buffer_set
         IF (k.EQ.1) THEN
            pp(1,k) = 1 
         ELSE
            pp(1,k) = pp(1,k-1) + npart_recv*ppm_buffer_dim(k-1)
         ENDIF
         bdim    = ppm_buffer_dim(k)
         DO j=2,ppm_nsendlist
            pp(j,k) = pp(j-1,k) + precv(j-1)*bdim
            IF (ppm_debug .GT. 1) THEN
                WRITE(mesg,'(A,I9)') 'pp(j,k)=',pp(j,k)
                CALL ppm_write(ppm_rank,caller,mesg,info)
                WRITE(mesg,'(A,I9,A,I4)') 'precv(j-1)=',precv(j-1),', bdim=',bdim
                CALL ppm_write(ppm_rank,caller,mesg,info)
            ENDIF
         ENDDO
      ENDDO

      !-------------------------------------------------------------------------
      !  First copy the on processor data - which is in the first buffer
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         DO k=1,ppm_buffer_set
            ibuffer = pp(1,k) - 1
            jbuffer = qq(1,k) - 1
            DO j=1,psend(1)*ppm_buffer_dim(k)
               ibuffer                  = ibuffer + 1
               jbuffer                  = jbuffer + 1
               ppm_recvbufferd(ibuffer) = ppm_sendbufferd(jbuffer)
            ENDDO 
         ENDDO 
      ELSE
         DO k=1,ppm_buffer_set
            ibuffer = pp(1,k) - 1
            jbuffer = qq(1,k) - 1
            DO j=1,psend(1)*ppm_buffer_dim(k)
               ibuffer                  = ibuffer + 1
               jbuffer                  = jbuffer + 1
               ppm_recvbuffers(ibuffer) = ppm_sendbuffers(jbuffer)
            ENDDO 
         ENDDO 
      ENDIF 

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist(); skip the first entry
      !  which is the local processor
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  For each send/recv 
         !----------------------------------------------------------------------
         DO k=2,ppm_nsendlist
            !-------------------------------------------------------------------
            !  Collect each data type (xp, vp, etc)
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = qq(k,j) - 1
               !----------------------------------------------------------------
               !  Collect the data into the send buffer
               !----------------------------------------------------------------
               DO i=1,psend(k)*ppm_buffer_dim(j)
                  ibuffer        = ibuffer + 1
                  jbuffer        = jbuffer + 1
                  sendd(ibuffer) = ppm_sendbufferd(jbuffer)
               ENDDO 
            ENDDO 

            !-------------------------------------------------------------------
            !  Perform the actual send/recv
            !-------------------------------------------------------------------
            ! The following IF is needed in order to skip "dummy"
            ! communication rounds where the current processor has to wait
            ! (only needed in the partial mapping).
            IF (ppm_isendlist(k) .GE. 0 .AND. ppm_irecvlist(k) .GE. 0) THEN
                tag1 = 300
                CALL MPI_SendRecv( &
     &             sendd,nsend(k),ppm_mpi_kind,ppm_isendlist(k),tag1, &
     &             recvd,nrecv(k),ppm_mpi_kind,ppm_irecvlist(k),tag1, &
     &             ppm_comm,status,info)
            ENDIF
            !-------------------------------------------------------------------
            !  Store the data back in the recv buffer
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = pp(k,j) - 1
               DO i=1,precv(k)*ppm_buffer_dim(j)
                  ibuffer                  = ibuffer + 1
                  jbuffer                  = jbuffer + 1
                  ppm_recvbufferd(jbuffer) = recvd(ibuffer)
               ENDDO 
            ENDDO 
         ENDDO
      ELSE
         !----------------------------------------------------------------------
         !  For each send/recv 
         !----------------------------------------------------------------------
         DO k=2,ppm_nsendlist
            !-------------------------------------------------------------------
            !  Collect each data type (xp, vp, etc)
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = qq(k,j) - 1 
               !----------------------------------------------------------------
               !  Collect the data into the send buffer
               !----------------------------------------------------------------
               DO i=1,psend(k)*ppm_buffer_dim(j)
                  ibuffer        = ibuffer + 1
                  jbuffer        = jbuffer + 1
                  sends(ibuffer) = ppm_sendbuffers(jbuffer)
               ENDDO 
            ENDDO 

            !-------------------------------------------------------------------
            !  Perform the actual send/recv
            !-------------------------------------------------------------------
            ! The following IF is needed in order to skip "dummy"
            ! communication rounds where the current processor has to wait
            ! (only needed in the partial mapping).
            IF (ppm_isendlist(k) .GE. 0 .AND. ppm_irecvlist(k) .GE. 0) THEN
                tag1 = 400
                CALL MPI_SendRecv(                                    &
     &             sends,nsend(k),ppm_mpi_kind,ppm_isendlist(k),tag1, & 
     &             recvs,nrecv(k),ppm_mpi_kind,ppm_irecvlist(k),tag1, &
     &             ppm_comm,status,info)
            ENDIF

            !-------------------------------------------------------------------
            !  Store the data back in the recv buffer
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = pp(k,j) - 1
               DO i=1,precv(k)*ppm_buffer_dim(j)
                  ibuffer                  = ibuffer + 1
                  jbuffer                  = jbuffer + 1
                  ppm_recvbuffers(jbuffer) = recvs(ibuffer)
               ENDDO 
            ENDDO
         ENDDO
      ENDIF 

      !-------------------------------------------------------------------------
      !  before we through away the precv() data let us store it for later use:
      !  when sending ghosts back (ppm_map_part_ghost_put())
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ldu(1) = ppm_nsendlist + 1
         iopt   = ppm_param_alloc_grow
         CALL ppm_alloc(ppm_precvbuffer,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global recv buffer pointer PPM_PRECVBUFFER',547,info)
             GOTO 9999
         ENDIF
         ppm_precvbuffer(1) = Npart + 1
         DO k=1,ppm_nsendlist
            ppm_precvbuffer(k+1) = ppm_precvbuffer(k) + precv(k)
         ENDDO

      ENDIF

      !-------------------------------------------------------------------------
      !  low level debugging
      !-------------------------------------------------------------------------
!write(mesg,'(a,i4.4)') 'recvbuf',ppm_rank
!open(10,file=mesg)
!do i=1,ppm_nrecvbuffer,2
!   write(10,*) ppm_recvbuffers(i),ppm_recvbuffers(i+1)
!enddo
!close(10)

      !-------------------------------------------------------------------------
      !  Deallocate the send buffer to save memory
      !-------------------------------------------------------------------------
      iopt = ppm_param_dealloc
      IF (ppm_kind .EQ. ppm_kind_single) THEN
          CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
      ELSE
          CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
      ENDIF
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'send buffer PPM_SENDBUFFER',579,info)
      ENDIF
    
      !-------------------------------------------------------------------------
      !  Deallocate
      !-------------------------------------------------------------------------
      iopt = ppm_param_dealloc
!      CALL ppm_alloc(nsend,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'send counter NSEND',590,info)
!      ENDIF
!      CALL ppm_alloc(nrecv,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'receive counter NRECV',596,info)
!      ENDIF
!      CALL ppm_alloc(psend,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'particle send counter PSEND',602,info)
!      ENDIF
!      CALL ppm_alloc(precv,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'particle receive counter PRECV',608,info)
!      ENDIF
!      CALL ppm_alloc(   pp,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'work array PP',614,info)
!      ENDIF
!      CALL ppm_alloc(   qq,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'work array QQ',620,info)
!      ENDIF
      CALL ppm_alloc(recvd,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local receive buffer RECVD',626,info)
      ENDIF
      CALL ppm_alloc(recvs,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local receive buffer RECVS',632,info)
      ENDIF
      CALL ppm_alloc(sendd,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local send buffer SENDD',638,info)
      ENDIF
      CALL ppm_alloc(sends,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local send buffer SENDS',644,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
        IF (Npart .LT. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,  &
     &          'Npart must be >=0',658,info)
            GOTO 8888
        ENDIF
 8888   CONTINUE
      END SUBROUTINE check
      END SUBROUTINE map_part_send_s



      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1d_d(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      REAL(MK), DIMENSION(:  ), POINTER    :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_double) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-double into double ',218,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = ppm_recvbufferd(ibuffer)
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1d_d


      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1di_d(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      INTEGER , DIMENSION(:  ), POINTER    :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_integer) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-integer into integer ',241,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = INT(ppm_recvbufferd(ibuffer))
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            pdata(ipart) = INT(ppm_recvbuffers(ibuffer))
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1di_d


      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1dl_d(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      LOGICAL , DIMENSION(:  ), POINTER    :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_logical) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-logical into logical ',248,info)
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            IF (ppm_recvbufferd(ibuffer) .GT.     &
     &         (1.0_ppm_kind_double-ppm_myepsd)) THEN
               pdata(ipart) = .TRUE.
            ELSE
               pdata(ipart) = .FALSE.
            ENDIF 
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 1
            IF (ppm_recvbuffers(ibuffer) .GT.      &
     &         (1.0_ppm_kind_single-ppm_myepss)) THEN
               pdata(ipart) = .TRUE.
            ELSE
               pdata(ipart) = .FALSE.
            ENDIF 
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1dl_d


      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_1dc_d(Pc,mapID,pdata,info)

      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      COMPLEX(MK), DIMENSION(:  ), POINTER :: pdata

      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      INTEGER, PARAMETER    :: lda = 1
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      ! for complex, the effective dimension is half the data dimension
      edim = bdim/2
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.1) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'buffer does not contain 1d data!',198,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_single) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-single-complex into single-complex',  &
     &       226,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 2
            pdata(ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &          ppm_recvbufferd(ibuffer),ppm_kind_single)
         ENDDO
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Scalar version
         !----------------------------------------------------------------------
         DO ipart=istart,newNpart
            ibuffer = ibuffer + 2
            pdata(ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &          ppm_recvbuffers(ibuffer),ppm_kind_double)
         ENDDO
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1360,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_1dc_d



      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2d_d(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      REAL(MK), DIMENSION(:,:), POINTER    :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_double) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-double into double ',218,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbufferd(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbufferd(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = ppm_recvbufferd(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = ppm_recvbufferd(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = ppm_recvbufferd(ibuffer)
               ibuffer = ibuffer + 1
               pdata(5,ipart) = ppm_recvbufferd(ibuffer)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = ppm_recvbufferd(ibuffer)
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(2,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(3,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(4,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 1
               pdata(5,ipart) = REAL(ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = REAL(ppm_recvbuffers(ibuffer),       &
     &                ppm_kind_double)
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2d_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2di_d(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      INTEGER , DIMENSION(:,:), POINTER    :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_integer) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-integer into integer ',241,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbufferd(ibuffer))
               ibuffer = ibuffer + 1
               pdata(5,ipart) = INT(ppm_recvbufferd(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = INT(ppm_recvbufferd(ibuffer))
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               pdata(1,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(2,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(3,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(4,ipart) = INT(ppm_recvbuffers(ibuffer))
               ibuffer = ibuffer + 1
               pdata(5,ipart) = INT(ppm_recvbuffers(ibuffer))
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  pdata(k,ipart) = INT(ppm_recvbuffers(ibuffer))
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2di_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2dl_d(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      LOGICAL , DIMENSION(:,:), POINTER    :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      edim = bdim
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_logical) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-logical into logical ',248,info)
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbufferd(ibuffer) .GT.     &
     &            (1.0_ppm_kind_double-ppm_myepsd)) THEN
                  pdata(5,ipart) = .TRUE.
               ELSE
                  pdata(5,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  IF (ppm_recvbufferd(ibuffer) .GT.     &
     &               (1.0_ppm_kind_double-ppm_myepsd)) THEN
                     pdata(k,ipart) = .TRUE.
                  ELSE
                     pdata(k,ipart) = .FALSE.
                  ENDIF 
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(1,ipart) = .TRUE.
               ELSE
                  pdata(1,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(2,ipart) = .TRUE.
               ELSE
                  pdata(2,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(3,ipart) = .TRUE.
               ELSE
                  pdata(3,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(4,ipart) = .TRUE.
               ELSE
                  pdata(4,ipart) = .FALSE.
               ENDIF 
               ibuffer = ibuffer + 1
               IF (ppm_recvbuffers(ibuffer) .GT.      &
     &            (1.0_ppm_kind_single-ppm_myepss)) THEN
                  pdata(5,ipart) = .TRUE.
               ELSE
                  pdata(5,ipart) = .FALSE.
               ENDIF 
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 1
                  IF (ppm_recvbuffers(ibuffer) .GT.      &
     &               (1.0_ppm_kind_single-ppm_myepss)) THEN
                     pdata(k,ipart) = .TRUE.
                  ELSE
                     pdata(k,ipart) = .FALSE.
                  ENDIF 
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2dl_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_pop
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------


      SUBROUTINE map_part_pop_2dc_d(Pc,mapID,pdata,lda,info)
      !!! This routine pops the contents of the receive buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor
      !!! data. The packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! Maybe remove the `lda` from the argument list (since
      !!! it is only used to check against ppm_buffer_dim
      !!! anyway) and check size(pdata,1) against
      !!! ppm_buffer_dim. _(does the size(,) stuff
      !!! also work if the array was allocated in a C client?)_
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)        :: Pc
      INTEGER                              :: mapID
      COMPLEX(MK), DIMENSION(:,:), POINTER :: pdata
      !!! Particle data to be popped.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   ) :: lda
      !!! The leading dimension of pdata.
      INTEGER                 , INTENT(  OUT) :: info
      !!! Returns status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(2) :: ldu
      INTEGER               :: k,ipart,bdim,ibuffer,btype
      INTEGER               :: iopt,edim,istart
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller = 'map_part_pop'
      REAL(MK)              :: t0
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart('map_part_pop',t0,info)


      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
     IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,'map_part_pop',    &
     &          'Buffer is empty: skipping pop!',166,info)
        ENDIF
        GOTO 9999
      ENDIF


      !-------------------------------------------------------------------------
      !  Check that the required dimension fits the dimension of the buffer
      !-------------------------------------------------------------------------
      bdim = ppm_buffer_dim(ppm_buffer_set)
      ! for complex, the effective dimension is half the data dimension
      edim = bdim/2
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I3))') 'bdim=',edim,'    lda=',lda
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (edim.NE.lda) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_dim,caller,    &
     &       'leading dimension LDA is in error',191,info)
         GOTO 9999
      ENDIF 

      !-------------------------------------------------------------------------
      !  Check that the required type is identical to the type of the buffer
      !-------------------------------------------------------------------------
      btype = ppm_buffer_type(ppm_buffer_set)
      IF (btype.NE.ppm_kind_single) THEN
         info = ppm_error_error
         CALL ppm_error(ppm_err_wrong_prec,caller,    &
     &       'trying to pop a non-single-complex into single-complex',  &
     &       226,info)
         GOTO 9999
      ENDIF
      !-------------------------------------------------------------------------
      !  (Re)allocate the particle data (if necessary)
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow_preserve
      ldu(1) = edim
      ldu(2) = newNpart
      CALL ppm_alloc(pdata,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle data PDATA',265,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the receive buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'ppm_nrecvbuffer = ',ppm_nrecvbuffer,   &
     &        'newNpart*bdim = ',newNpart*bdim
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ppm_nrecvbuffer = ppm_nrecvbuffer - (newNpart - Npart)*bdim 
      ELSE
         ppm_nrecvbuffer = ppm_nrecvbuffer - newNpart*bdim 
      ENDIF 

      !-------------------------------------------------------------------------
      !  Decrement the pointer into the send buffer to allow reuse by
      !  multiple sequential push-send-pop cycles.
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ppm_nsendbuffer - ppm_buffer_dim(ppm_buffer_set)*  &
     &    (ppm_psendbuffer(ppm_nsendlist+1)-1)

      ibuffer = ppm_nrecvbuffer 

      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ibuffer = ',ibuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  compute the start of the loop: when ghosts are popped, we need to add
      !  them at the end of the current particle list, otherwise we overwrite  
      !  the current particle list
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         istart = Npart + 1
      ELSE
         istart = 1
      ENDIF 
      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  Unrolled version of edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled version of edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
               ibuffer = ibuffer + 2
               pdata(5,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &             ppm_recvbufferd(ibuffer),ppm_kind_single)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 2
                  pdata(k,ipart) = CMPLX(ppm_recvbufferd(ibuffer-1),    &
     &                ppm_recvbufferd(ibuffer),ppm_kind_single)
               ENDDO
            ENDDO
         ENDIF
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=1
         !----------------------------------------------------------------------
         IF (edim .EQ. 1) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=2
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 2) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=3
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 3) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=4
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 4) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  Unrolled verion for edim=5
         !----------------------------------------------------------------------
         ELSEIF (edim .EQ. 5) THEN
            DO ipart=istart,newNpart
               ibuffer = ibuffer + 2
               pdata(1,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(2,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(3,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(4,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
               ibuffer = ibuffer + 2
               pdata(5,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &             ppm_recvbuffers(ibuffer),ppm_kind_double)
            ENDDO
         !----------------------------------------------------------------------
         !  For edim.GT.5 the vector length will be edim !!
         !----------------------------------------------------------------------
         ELSE
            DO ipart=istart,newNpart
               DO k=1,edim
                  ibuffer = ibuffer + 2
                  pdata(k,ipart) = CMPLX(ppm_recvbuffers(ibuffer-1),    &
     &                ppm_recvbuffers(ibuffer),ppm_kind_double)
               ENDDO
            ENDDO
         ENDIF
      ENDIF       ! ppm_kind
      ! finish MPI

      !-------------------------------------------------------------------------
      !  Decrement the set counter
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set - 1  

      !-------------------------------------------------------------------------
      !  Deallocate the receive buffer if all sets have been poped
      !-------------------------------------------------------------------------
      IF (ppm_buffer_set .LT. 1) THEN
          iopt = ppm_param_dealloc
          IF (ppm_kind .EQ. ppm_kind_single) THEN
              CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
          ELSE
              CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
          ENDIF
          IF (info .NE. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'receive buffer PPM_RECVBUFFER',1325,info)
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1340,info)
              GOTO 8888
          ENDIF
          IF (newNpart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'newNpart must be >=0',1346,info)
              GOTO 8888
          ENDIF
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1353,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_pop_2dc_d


      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1d_d(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      REAL(MK), DIMENSION(:  ), INTENT(IN   )    :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_double

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = pdata(ipart)
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(pdata(ipart),ppm_kind_single)
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1d_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1di_d(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      INTEGER , DIMENSION(:  ), INTENT(IN   )    :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_integer

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(pdata(ipart),ppm_kind_double)
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(pdata(ipart),ppm_kind_single)
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1di_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1dl_d(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      LOGICAL , DIMENSION(:  ), INTENT(IN   )    :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_logical

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               IF (pdata(ipart)) THEN
                  ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
               ELSE
                  ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
               ENDIF
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               IF (pdata(ipart)) THEN
                  ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
               ELSE
                  ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
               ENDIF
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1dl_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_1dc_d(Pc,mapID,pdata,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      COMPLEX(MK), DIMENSION(:  ), INTENT(IN   ) :: pdata

      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      INTEGER, PARAMETER    :: lda = 1
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = 2*lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_single

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(pdata(ipart),ppm_kind_double)
               ibuffer = ibuffer + 1
               ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(ipart)),  &
     &             ppm_kind_double)
            ENDDO
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Scalar version
            !-------------------------------------------------------------------
            DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
               !----------------------------------------------------------------
               !  Get the particle id 
               !----------------------------------------------------------------
               ipart = ppm_buffer2part(j)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(pdata(ipart),ppm_kind_single)
               ibuffer = ibuffer + 1
               ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(ipart)),  &
     &             ppm_kind_single)
            ENDDO
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .NE. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be =1 for scalar data',1432,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_1dc_d


      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2d_d(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      REAL(MK), DIMENSION(:,:), INTENT(IN   )    :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_double

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(1,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(2,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(2,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(3,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(2,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(3,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(4,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(1,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(2,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(3,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(4,ipart)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = pdata(5,ipart)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) = pdata(k,ipart)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(5,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(pdata(k,ipart),   &
     &                   ppm_kind_single)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2d_d
      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2di_d(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      INTEGER , DIMENSION(:,:), INTENT(IN   )    :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_integer

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(4,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(1,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(2,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(3,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(4,ipart),    &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(pdata(5,ipart),    &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) = REAL(pdata(k,ipart),    &
     &                   ppm_kind_double)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(5,ipart),   &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(pdata(k,ipart),   &
     &                   ppm_kind_single)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2di_d
      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2dl_d(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_double
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      LOGICAL , DIMENSION(:,:), INTENT(IN   )    :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_logical

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(5,ipart)) THEN
                     ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                  ELSE
                     ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     IF (pdata(k,ipart)) THEN
                        ppm_sendbufferd(ibuffer) = 1.0_ppm_kind_double
                     ELSE
                        ppm_sendbufferd(ibuffer) = 0.0_ppm_kind_double
                     ENDIF
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  IF (pdata(1,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(2,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(3,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(4,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
                  ibuffer = ibuffer + 1
                  IF (pdata(5,ipart)) THEN
                     ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                  ELSE
                     ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                  ENDIF
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     IF (pdata(k,ipart)) THEN
                        ppm_sendbuffers(ibuffer) = 1.0_ppm_kind_single
                     ELSE
                        ppm_sendbuffers(ibuffer) = 0.0_ppm_kind_single
                     ENDIF
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2dl_d
      !-------------------------------------------------------------------------
      !  Subroutine   :                  map_part_push
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_push_2dc_d(Pc,mapID,pdata,lda,info,pushpp)
      !!! This routine pushes particle data onto the send buffer.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data.
      !!! The packing could be performed more efficiently.
      !!!
      !!! [WARNING]
      !!! DIM is the dimension of the pdata array and not the space
      !!! dimension ppm_dim!
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      IMPLICIT NONE
      INTEGER, PARAMETER :: MK = ppm_kind_single
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)              :: Pc
      INTEGER,                  INTENT(IN   )    :: mapID
      COMPLEX(MK), DIMENSION(:,:), INTENT(IN   ) :: pdata
      !!! Particle data.
      !!! Can be either 1D or 2D array.
      INTEGER                 , INTENT(IN   )    :: lda
      !!! The leading dimension of the pdata.
      INTEGER                 , INTENT(  OUT)    :: info
      !!! Returns 0 upon success
      LOGICAL, OPTIONAL       , INTENT(IN   )    :: pushpp
      !!! If `TRUE` then pdata is assumed to contain the particle positions
      !!! (xp)
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldu
      INTEGER               :: i,j,k,ipart,ibuffer,icount
      INTEGER               :: iopt,ldb,incr
      REAL(MK)              :: t0
      LOGICAL               :: lpushpp
      CHARACTER(LEN=ppm_char) :: caller ='map_part_push'
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)

      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 0) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  The default is that we do not push the particle positions
      !-------------------------------------------------------------------------
      IF (PRESENT(pushpp)) THEN
         lpushpp = pushpp
      ELSE
         lpushpp = .FALSE.
      ENDIF 

      !-------------------------------------------------------------------------
      !  Increment the buffer set 
      !-------------------------------------------------------------------------
      ppm_buffer_set = ppm_buffer_set + 1

      !-------------------------------------------------------------------------
      !  Allocate memory for the buffer dimension and type
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow_preserve
      ldu(1)  = ppm_buffer_set
      CALL ppm_alloc(ppm_buffer_dim ,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer dimensions PPM_BUFFER_DIM',177,info)
          GOTO 9999
      ENDIF
      CALL ppm_alloc(ppm_buffer_type,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'buffer types PPM_BUFFER_TYPE',184,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  A complex number is treated as two reals. Cannot change lda
      !  because it is INTENT(IN)
      !-------------------------------------------------------------------------
      ldb = 2*lda

      !-------------------------------------------------------------------------
      !  Store the dimension and type
      !-------------------------------------------------------------------------
      ppm_buffer_dim(ppm_buffer_set)  = ldb
      ppm_buffer_type(ppm_buffer_set) = ppm_kind_single

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist() 
      !-------------------------------------------------------------------------
      ibuffer = ppm_nsendbuffer

      !-------------------------------------------------------------------------
      !  DOUBLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERD',234,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(3,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(3,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(4,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(1,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(2,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(3,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(4,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) =         &
     &                       REAL(pdata(5,ipart),ppm_kind_double)
                  ibuffer = ibuffer + 1
                  ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(5,ipart)),  &
     &                ppm_kind_double)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled for the rest. Vector length will be lda!!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) =         &
     &                          REAL(pdata(k,ipart),ppm_kind_double)
                     ibuffer = ibuffer + 1
                     ppm_sendbufferd(ibuffer) = REAL(AIMAG(pdata(k,ipart)),  &
     &                   ppm_kind_double)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO                ! i=1,ppm_nsendlist
      !-------------------------------------------------------------------------
      !  SINGLE PRECISION BUFFER
      !-------------------------------------------------------------------------
      ELSE
         !----------------------------------------------------------------------
         !  (Re)allocate memory for the buffer 
         !----------------------------------------------------------------------
         incr = 0 
         DO i=1,ppm_nsendlist
            incr = incr + (ppm_psendbuffer(i+1)-ppm_psendbuffer(i))*ldb
         ENDDO
         ldu(1) = ppm_nsendbuffer + incr
         iopt   = ppm_param_alloc_grow_preserve
         CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global send buffer PPM_SENDBUFFERS',774,info)
             GOTO 9999
         ENDIF

         DO i=1,ppm_nsendlist
            !-------------------------------------------------------------------
            !  access the particles belonging to the i-th processor in the 
            !  sendlist
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Store the particle data in the buffer
            !-------------------------------------------------------------------
            !-------------------------------------------------------------------
            !  Unrolled for lda=1
            !-------------------------------------------------------------------
            IF (lda .EQ. 1) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=2
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 2) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=3
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 3) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=4
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 4) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Unrolled for lda=5
            !-------------------------------------------------------------------
            ELSEIF (lda .EQ. 5) THEN
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(1,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(1,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(2,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(2,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(3,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(3,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(4,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(4,ipart)),  &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(pdata(5,ipart),   &
     &                ppm_kind_single)
                  ibuffer = ibuffer + 1
                  ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(5,ipart)),  &
     &                ppm_kind_single)
               ENDDO
            !-------------------------------------------------------------------
            !  Not unrolled. Vector length will be lda !!
            !-------------------------------------------------------------------
            ELSE
               DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                  !-------------------------------------------------------------
                  !  Get the particle id 
                  !-------------------------------------------------------------
                  ipart = ppm_buffer2part(j)
                  DO k=1,lda
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(pdata(k,ipart),   &
     &                   ppm_kind_single)
                     ibuffer = ibuffer + 1
                     ppm_sendbuffers(ibuffer) = REAL(AIMAG(pdata(k,ipart)),  &
     &                   ppm_kind_single)
                  ENDDO
               ENDDO
            ENDIF
         ENDDO         ! i=1,ppm_nsendlist
      ENDIF         ! ppm_kind

      !-------------------------------------------------------------------------
      !  If we are pushing particle positions (if lpushpp is true) we need to
      !  add the offset to the particles; pushing the particles can only occur
      !  for 2D arrays in single or double precions: xp is USUALLY stored as
      !  xp(1:ppm_dim,1:Npart)
      !-------------------------------------------------------------------------
      IF (lpushpp) THEN
         !----------------------------------------------------------------------
         !  the particle positions are per construction (by a call to ghost_get) 
         !  ALWAYS stored from ibuffer = 1 to nsendbuffer(2) - 1 and the 
         !  ppm_ghost_offset is therefore also stored from 1 - nsendbuffer(2)-1
         !  thus icount = 1 and ibuffer = ppm_nsendlist (which has not yet been
         !  updated (see below)
         !----------------------------------------------------------------------
         icount  = 0 
         ibuffer = ppm_nsendbuffer
         IF (ppm_kind.EQ.ppm_kind_double) THEN
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) &
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbufferd(ibuffer) = ppm_sendbufferd(ibuffer) & 
     &                                        + ppm_ghost_offsetd(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ELSE ! buffers are single precision 
            DO i=1,ppm_nsendlist
               IF (lda.EQ.2) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=2
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ELSEIF (lda.EQ.3) THEN
                  !-------------------------------------------------------------
                  !  Unrolled for lda=3
                  !-------------------------------------------------------------
                  DO j=ppm_psendbuffer(i),ppm_psendbuffer(i+1)-1
                     !----------------------------------------------------------
                     !  Get the particle id 
                     !----------------------------------------------------------
                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) &
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 

                     ibuffer = ibuffer + 1
                     icount  = icount  + 1
                     ppm_sendbuffers(ibuffer) = ppm_sendbuffers(ibuffer) & 
     &                                        + ppm_ghost_offsets(icount) 
                  ENDDO
               ENDIF ! end of lda = 3
            ENDDO ! enddo of nsendlist
         ENDIF ! end of single/double precision buffers
      ENDIF ! end of lpushpp

      !-------------------------------------------------------------------------
      !  Update the particle buffer count
      !-------------------------------------------------------------------------
      ppm_nsendbuffer = ibuffer

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
          IF (lda .LT. 1) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'lda must be >0 for vector data',1425,info)
              GOTO 8888
          ENDIF
          IF (Npart .LT. 0) THEN
              info = ppm_error_error
              CALL ppm_error(ppm_err_argument,caller,  &
     &            'Npart must be >=0',1439,info)
              GOTO 8888
          ENDIF
 8888     CONTINUE
      END SUBROUTINE check

      END SUBROUTINE map_part_push_2dc_d

      !-------------------------------------------------------------------------
      !  Subroutine   :                 map_part_send
      !-------------------------------------------------------------------------
      ! Copyright (c) 2010 CSE Lab (ETH Zurich), MOSAIC Group (ETH Zurich), 
      !                    Center for Fluid Dynamics (DTU)
      !
      !
      ! This file is part of the Parallel Particle Mesh Library (PPM).
      !
      ! PPM is free software: you can redistribute it and/or modify
      ! it under the terms of the GNU Lesser General Public License 
      ! as published by the Free Software Foundation, either 
      ! version 3 of the License, or (at your option) any later 
      ! version.
      !
      ! PPM is distributed in the hope that it will be useful,
      ! but WITHOUT ANY WARRANTY; without even the implied warranty of
      ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
      ! GNU General Public License for more details.
      !
      ! You should have received a copy of the GNU General Public License
      ! and the GNU Lesser General Public License along with PPM. If not,
      ! see <http://www.gnu.org/licenses/>.
      !
      ! Parallel Particle Mesh Library (PPM)
      ! ETH Zurich
      ! CH-8092 Zurich, Switzerland
      !-------------------------------------------------------------------------

      SUBROUTINE map_part_send_d(Pc,mapID,info)
      !!! This routine performs the actual send/recv of the particles and all
      !!! pushed data.
      !!!
      !!! [NOTE]
      !!! The first part of the buffer contains the on processor data. The
      !!! packing could be performed more efficiently.
      !!!
      !!! [NOTE]
      !!! The two send/recv of the integers should be combined into one
      !!! send/receive

      !-------------------------------------------------------------------------
      !  Modules 
      !-------------------------------------------------------------------------
      USE ppm_module_data
      USE ppm_module_substart
      USE ppm_module_substop
      USE ppm_module_error
      USE ppm_module_alloc
      USE ppm_module_write
      IMPLICIT NONE
      !-------------------------------------------------------------------------
      !  Includes
      !-------------------------------------------------------------------------
      INCLUDE 'mpif.h'
      !-------------------------------------------------------------------------
      !  Arguments     
      !-------------------------------------------------------------------------
      CLASS(ppm_t_particles_d)           :: Pc
      !!! Particle set
      INTEGER                 , INTENT(IN   ) :: mapID
      !!! mapping ID
      INTEGER                 , INTENT(  OUT) :: info
      !!! Return status, 0 upon success
      !-------------------------------------------------------------------------
      !  Local variables 
      !-------------------------------------------------------------------------
      INTEGER, DIMENSION(3) :: ldl,ldu
      INTEGER               :: i,j,k,idom,nbuffer,ibuffer,jbuffer,bdim,sbdim
      INTEGER               :: iopt,count,tag1,qpart,msend,mrecv
      INTEGER               :: npart_send,npart_recv
      CHARACTER(ppm_char)   :: mesg
      CHARACTER(ppm_char)   :: caller ='map_part_send'
      REAL(ppm_kind_double) :: t0
      INTEGER, DIMENSION(MPI_STATUS_SIZE) :: status
      !-------------------------------------------------------------------------
      !  Externals 
      !-------------------------------------------------------------------------
      
      !-------------------------------------------------------------------------
      !  Initialise 
      !-------------------------------------------------------------------------
      CALL substart(caller,t0,info)
      !-------------------------------------------------------------------------
      !  Check arguments
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 3) THEN
        CALL check
        IF (info .NE. 0) GOTO 9999
      ENDIF

      ! skip if the buffer is empty
      IF (ppm_buffer_set .LT. 1) THEN
        info = ppm_error_notice
        IF (ppm_debug .GT. 1) THEN
            CALL ppm_error(ppm_err_buffer_empt,caller,    &
     &          'Buffer is empty: skipping send!',101,info)
        ENDIF
        GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Allocate
      !-------------------------------------------------------------------------
      iopt = ppm_param_alloc_grow
      ldu(1) = MAX(ppm_nsendlist,1)
      IF ((ppm_nsendlist.NE.old_nsendlist) .OR.  &
     &    (ppm_buffer_set.NE.old_buffer_set)) THEN
          old_nsendlist = ppm_nsendlist
          old_buffer_set = ppm_buffer_set
          CALL ppm_alloc(nsend,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'send counter NSEND',119,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(nrecv,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'receive counter NRECV',126,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(psend,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle send counter PSEND',133,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(precv,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &        'particle receive counter PRECV',140,info)
              GOTO 9999
          ENDIF
          ldu(2) = ppm_buffer_set 
          CALL ppm_alloc(pp,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'work buffer PP',148,info)
              GOTO 9999
          ENDIF
          CALL ppm_alloc(qq,ldu,iopt,info)
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'work buffer QQ',155,info)
              GOTO 9999
          ENDIF
      ENDIF
      !-------------------------------------------------------------------------
      !  Count the total size of the buffer dimensions 
      !  It is handy... simplifies many summations, avoids loops, etc...
      !-------------------------------------------------------------------------
      sbdim = 0
      DO j=1,ppm_buffer_set
         sbdim    = sbdim + ppm_buffer_dim(j)
      ENDDO
      !-------------------------------------------------------------------------
      !  Count the size of the buffer that will NOT be sent
      !-------------------------------------------------------------------------
      qpart   = (ppm_psendbuffer(2) - ppm_psendbuffer(1))
      ibuffer = sbdim*qpart

      !-------------------------------------------------------------------------
      !  Initialize the counter for the total set of new particles 
      !JHW 20060928     IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get.OR. &
          ppm_map_type.EQ.ppm_param_map_ghost_put) THEN
         Mpart = qpart + Npart
      ELSE
         Mpart = qpart
      ENDIF

      !-------------------------------------------------------------------------
      !  Count the size of the buffer that WILL be sent
      !-------------------------------------------------------------------------
      ppm_nrecvbuffer = ibuffer
      nsend(1)        = ibuffer
      nrecv(1)        = ibuffer
      psend(1)        = qpart
      precv(1)        = qpart
      mrecv           = -1
      msend           = -1

      DO k=2,ppm_nsendlist

         !----------------------------------------------------------------------
         !  The number of particles send off to the k-th processor in the 
         !  sendlist
         !----------------------------------------------------------------------
         qpart    = (ppm_psendbuffer(k+1) - ppm_psendbuffer(k))

         !----------------------------------------------------------------------
         !  Store the number of particles to send
         !----------------------------------------------------------------------
         psend(k) = qpart ! store the number of particles to send 

         !----------------------------------------------------------------------
         !  Store the size of the data to be send
         !----------------------------------------------------------------------
         nsend(k) = sbdim*qpart

         !----------------------------------------------------------------------
         !  Make a send/recv of the number of particles and data size to that 
         !  has to be send/recv
         !----------------------------------------------------------------------
         ! The following IF is needed in order to skip "dummy"
         ! communication rounds where the current processor has to wait
         ! (only needed in the partial mapping).
         IF (ppm_isendlist(k) .GE. 0 .AND. ppm_irecvlist(k) .GE. 0) THEN
             tag1 = 100
             IF (ppm_debug .GT. 1) THEN
                 WRITE(mesg,'(A,I5,2(A,I9))') 'sending to ',   &
     &               ppm_isendlist(k),', nsend=',nsend(k),', psend=',psend(k)
                 CALL ppm_write(ppm_rank,caller,mesg,info)
             ENDIF
             CALL MPI_SendRecv(psend(k),1,MPI_INTEGER,ppm_isendlist(k),tag1, &
     &                         precv(k),1,MPI_INTEGER,ppm_irecvlist(k),tag1, &
     &                         ppm_comm,status,info)
     
             ! Compute nrecv(k) from precv(k)
             nrecv(k) = sbdim*precv(k)

             IF (ppm_debug .GT. 1) THEN
                 WRITE(mesg,'(A,I5,2(A,I9))') 'received from ',   &
     &               ppm_irecvlist(k),', nrecv=',nrecv(k),', precv=',precv(k)
                 CALL ppm_write(ppm_rank,caller,mesg,info)
             ENDIF
         ELSE
             ! skip this round, i.e. neither send nor receive any
             ! particles.
             nrecv(k) = 0
             precv(k) = 0
         ENDIF

      ENDDO
      !----------------------------------------------------------------------
      !  Find the required (maximum) size of the send/recv buffers
      !----------------------------------------------------------------------
      DO k=2,ppm_nsendlist
         IF (mrecv.LE.nrecv(k)) mrecv = nrecv(k)
      ENDDO
      DO k=2,ppm_nsendlist
         IF (msend.LE.nsend(k)) msend = nsend(k)
      ENDDO
      !----------------------------------------------------------------------
      !  Increment the total receive buffer
      !----------------------------------------------------------------------
      DO k=2,ppm_nsendlist
         ppm_nrecvbuffer = ppm_nrecvbuffer + nrecv(k)
      ENDDO
      !----------------------------------------------------------------------
      !  Increment the total number of particle to receive
      !----------------------------------------------------------------------
      DO k=2,ppm_nsendlist
         Mpart           = Mpart           + precv(k)
      ENDDO
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(2(A,I9))') 'mrecv=',mrecv,', msend=',msend
          CALL ppm_write(ppm_rank,caller,mesg,info)
          WRITE(mesg,'(A,I9)') 'ppm_nrecvbuffer=',ppm_nrecvbuffer
          CALL ppm_write(ppm_rank,caller,mesg,info)
          WRITE(mesg,'(A,I9)') 'Mpart=',Mpart
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF


      !-------------------------------------------------------------------------
      !  Allocate the memory for the copy of the particle buffer
      !-------------------------------------------------------------------------
      iopt   = ppm_param_alloc_grow
      ldu(1) = ppm_nrecvbuffer 
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         CALL ppm_alloc(ppm_recvbufferd,ldu,iopt,info)
      ELSE
         CALL ppm_alloc(ppm_recvbuffers,ldu,iopt,info)
      ENDIF 
      IF (info .NE. 0) THEN
          info = ppm_error_fatal
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'global receive buffer PPM_RECVBUFFER',293,info)
          GOTO 9999
      ENDIF

      !-------------------------------------------------------------------------
      !  Allocate memory for the smaller send and receive buffer
      !-------------------------------------------------------------------------
      ! only allocate if there actually is anything to be sent/recvd with
      ! other processors. Otherwise mrecv and msend would both still be -1
      ! (as initialized above) and the alloc would throw a FATAL. This was
      ! Bug ID 000012.
      IF (ppm_nsendlist .GT. 1) THEN
          iopt   = ppm_param_alloc_grow
          ldu(1) = MAX(mrecv,1)
          IF (ppm_kind.EQ.ppm_kind_double) THEN
             CALL ppm_alloc(recvd,ldu,iopt,info)
          ELSE
             CALL ppm_alloc(recvs,ldu,iopt,info)
          ENDIF 
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'local receive buffer RECV',315,info)
              GOTO 9999
          ENDIF

          ldu(1) = MAX(msend,1)
          IF (ppm_kind.EQ.ppm_kind_double) THEN
             CALL ppm_alloc(sendd,ldu,iopt,info)
          ELSE
             CALL ppm_alloc(sends,ldu,iopt,info)
          ENDIF 
          IF (info .NE. 0) THEN
              info = ppm_error_fatal
              CALL ppm_error(ppm_err_alloc,caller,     &
     &            'local send buffer SEND',328,info)
              GOTO 9999
          ENDIF
      ENDIF

      !-------------------------------------------------------------------------
      !  Debugging print of the number of sets in the buffer
      !-------------------------------------------------------------------------
      IF (ppm_debug .GT. 1) THEN
          WRITE(mesg,'(A,I9)') 'ppm_buffer_set=',ppm_buffer_set
          CALL ppm_write(ppm_rank,caller,mesg,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  Compute the total number of particles to send 
      !  As it is now, this should be equal to Npart
      !-------------------------------------------------------------------------
      npart_send = 0
      DO j=1,ppm_nsendlist
         npart_send = npart_send + psend(j)
      ENDDO

      !-------------------------------------------------------------------------
      !  Compute the pointer to the position of the data in the main send 
      !  buffer 
      !-------------------------------------------------------------------------
      DO k=1,ppm_buffer_set
         IF (k.EQ.1) THEN
            qq(1,k) = 1
         ELSE
            qq(1,k) = qq(1,k-1) + npart_send*ppm_buffer_dim(k-1)
         ENDIF
         bdim    = ppm_buffer_dim(k)
         DO j=2,ppm_nsendlist
            qq(j,k) = qq(j-1,k) + psend(j-1)*bdim
            IF (ppm_debug .GT. 1) THEN
                WRITE(mesg,'(A,I9)') 'qq(j,k)=',qq(j,k)
                CALL ppm_write(ppm_rank,caller,mesg,info)
            ENDIF
         ENDDO
      ENDDO


      !-------------------------------------------------------------------------
      !  Compute the total number of particles to receive
      !  As it is now, this should be equal to Mpart
      !-------------------------------------------------------------------------
      npart_recv = 0
      DO j=1,ppm_nsendlist
         npart_recv = npart_recv + precv(j)
      ENDDO

      !-------------------------------------------------------------------------
      !  Compute the pointer to the position of the data in the main receive 
      !  buffer 
      !-------------------------------------------------------------------------
      DO k=1,ppm_buffer_set
         IF (k.EQ.1) THEN
            pp(1,k) = 1 
         ELSE
            pp(1,k) = pp(1,k-1) + npart_recv*ppm_buffer_dim(k-1)
         ENDIF
         bdim    = ppm_buffer_dim(k)
         DO j=2,ppm_nsendlist
            pp(j,k) = pp(j-1,k) + precv(j-1)*bdim
            IF (ppm_debug .GT. 1) THEN
                WRITE(mesg,'(A,I9)') 'pp(j,k)=',pp(j,k)
                CALL ppm_write(ppm_rank,caller,mesg,info)
                WRITE(mesg,'(A,I9,A,I4)') 'precv(j-1)=',precv(j-1),', bdim=',bdim
                CALL ppm_write(ppm_rank,caller,mesg,info)
            ENDIF
         ENDDO
      ENDDO

      !-------------------------------------------------------------------------
      !  First copy the on processor data - which is in the first buffer
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         DO k=1,ppm_buffer_set
            ibuffer = pp(1,k) - 1
            jbuffer = qq(1,k) - 1
            DO j=1,psend(1)*ppm_buffer_dim(k)
               ibuffer                  = ibuffer + 1
               jbuffer                  = jbuffer + 1
               ppm_recvbufferd(ibuffer) = ppm_sendbufferd(jbuffer)
            ENDDO 
         ENDDO 
      ELSE
         DO k=1,ppm_buffer_set
            ibuffer = pp(1,k) - 1
            jbuffer = qq(1,k) - 1
            DO j=1,psend(1)*ppm_buffer_dim(k)
               ibuffer                  = ibuffer + 1
               jbuffer                  = jbuffer + 1
               ppm_recvbuffers(ibuffer) = ppm_sendbuffers(jbuffer)
            ENDDO 
         ENDDO 
      ENDIF 

      !-------------------------------------------------------------------------
      !  loop over the processors in the ppm_isendlist(); skip the first entry
      !  which is the local processor
      !-------------------------------------------------------------------------
      IF (ppm_kind.EQ.ppm_kind_double) THEN
         !----------------------------------------------------------------------
         !  For each send/recv 
         !----------------------------------------------------------------------
         DO k=2,ppm_nsendlist
            !-------------------------------------------------------------------
            !  Collect each data type (xp, vp, etc)
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = qq(k,j) - 1
               !----------------------------------------------------------------
               !  Collect the data into the send buffer
               !----------------------------------------------------------------
               DO i=1,psend(k)*ppm_buffer_dim(j)
                  ibuffer        = ibuffer + 1
                  jbuffer        = jbuffer + 1
                  sendd(ibuffer) = ppm_sendbufferd(jbuffer)
               ENDDO 
            ENDDO 

            !-------------------------------------------------------------------
            !  Perform the actual send/recv
            !-------------------------------------------------------------------
            ! The following IF is needed in order to skip "dummy"
            ! communication rounds where the current processor has to wait
            ! (only needed in the partial mapping).
            IF (ppm_isendlist(k) .GE. 0 .AND. ppm_irecvlist(k) .GE. 0) THEN
                tag1 = 300
                CALL MPI_SendRecv( &
     &             sendd,nsend(k),ppm_mpi_kind,ppm_isendlist(k),tag1, &
     &             recvd,nrecv(k),ppm_mpi_kind,ppm_irecvlist(k),tag1, &
     &             ppm_comm,status,info)
            ENDIF
            !-------------------------------------------------------------------
            !  Store the data back in the recv buffer
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = pp(k,j) - 1
               DO i=1,precv(k)*ppm_buffer_dim(j)
                  ibuffer                  = ibuffer + 1
                  jbuffer                  = jbuffer + 1
                  ppm_recvbufferd(jbuffer) = recvd(ibuffer)
               ENDDO 
            ENDDO 
         ENDDO
      ELSE
         !----------------------------------------------------------------------
         !  For each send/recv 
         !----------------------------------------------------------------------
         DO k=2,ppm_nsendlist
            !-------------------------------------------------------------------
            !  Collect each data type (xp, vp, etc)
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = qq(k,j) - 1 
               !----------------------------------------------------------------
               !  Collect the data into the send buffer
               !----------------------------------------------------------------
               DO i=1,psend(k)*ppm_buffer_dim(j)
                  ibuffer        = ibuffer + 1
                  jbuffer        = jbuffer + 1
                  sends(ibuffer) = ppm_sendbuffers(jbuffer)
               ENDDO 
            ENDDO 

            !-------------------------------------------------------------------
            !  Perform the actual send/recv
            !-------------------------------------------------------------------
            ! The following IF is needed in order to skip "dummy"
            ! communication rounds where the current processor has to wait
            ! (only needed in the partial mapping).
            IF (ppm_isendlist(k) .GE. 0 .AND. ppm_irecvlist(k) .GE. 0) THEN
                tag1 = 400
                CALL MPI_SendRecv(                                    &
     &             sends,nsend(k),ppm_mpi_kind,ppm_isendlist(k),tag1, & 
     &             recvs,nrecv(k),ppm_mpi_kind,ppm_irecvlist(k),tag1, &
     &             ppm_comm,status,info)
            ENDIF

            !-------------------------------------------------------------------
            !  Store the data back in the recv buffer
            !-------------------------------------------------------------------
            ibuffer = 0
            DO j=1,ppm_buffer_set
               jbuffer = pp(k,j) - 1
               DO i=1,precv(k)*ppm_buffer_dim(j)
                  ibuffer                  = ibuffer + 1
                  jbuffer                  = jbuffer + 1
                  ppm_recvbuffers(jbuffer) = recvs(ibuffer)
               ENDDO 
            ENDDO
         ENDDO
      ENDIF 

      !-------------------------------------------------------------------------
      !  before we through away the precv() data let us store it for later use:
      !  when sending ghosts back (ppm_map_part_ghost_put())
      !-------------------------------------------------------------------------
      IF (ppm_map_type.EQ.ppm_param_map_ghost_get) THEN
         ldu(1) = ppm_nsendlist + 1
         iopt   = ppm_param_alloc_grow
         CALL ppm_alloc(ppm_precvbuffer,ldu,iopt,info)
         IF (info .NE. 0) THEN
             info = ppm_error_fatal
             CALL ppm_error(ppm_err_alloc,caller,     &
     &           'global recv buffer pointer PPM_PRECVBUFFER',547,info)
             GOTO 9999
         ENDIF
         ppm_precvbuffer(1) = Npart + 1
         DO k=1,ppm_nsendlist
            ppm_precvbuffer(k+1) = ppm_precvbuffer(k) + precv(k)
         ENDDO

      ENDIF

      !-------------------------------------------------------------------------
      !  low level debugging
      !-------------------------------------------------------------------------
!write(mesg,'(a,i4.4)') 'recvbuf',ppm_rank
!open(10,file=mesg)
!do i=1,ppm_nrecvbuffer,2
!   write(10,*) ppm_recvbuffers(i),ppm_recvbuffers(i+1)
!enddo
!close(10)

      !-------------------------------------------------------------------------
      !  Deallocate the send buffer to save memory
      !-------------------------------------------------------------------------
      iopt = ppm_param_dealloc
      IF (ppm_kind .EQ. ppm_kind_single) THEN
          CALL ppm_alloc(ppm_sendbuffers,ldu,iopt,info)
      ELSE
          CALL ppm_alloc(ppm_sendbufferd,ldu,iopt,info)
      ENDIF
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_alloc,caller,     &
     &        'send buffer PPM_SENDBUFFER',579,info)
      ENDIF
    
      !-------------------------------------------------------------------------
      !  Deallocate
      !-------------------------------------------------------------------------
      iopt = ppm_param_dealloc
!      CALL ppm_alloc(nsend,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'send counter NSEND',590,info)
!      ENDIF
!      CALL ppm_alloc(nrecv,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'receive counter NRECV',596,info)
!      ENDIF
!      CALL ppm_alloc(psend,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'particle send counter PSEND',602,info)
!      ENDIF
!      CALL ppm_alloc(precv,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'particle receive counter PRECV',608,info)
!      ENDIF
!      CALL ppm_alloc(   pp,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'work array PP',614,info)
!      ENDIF
!      CALL ppm_alloc(   qq,ldu,iopt,info)
!      IF (info .NE. 0) THEN
!          info = ppm_error_error
!          CALL ppm_error(ppm_err_dealloc,caller,     &
!     &        'work array QQ',620,info)
!      ENDIF
      CALL ppm_alloc(recvd,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local receive buffer RECVD',626,info)
      ENDIF
      CALL ppm_alloc(recvs,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local receive buffer RECVS',632,info)
      ENDIF
      CALL ppm_alloc(sendd,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local send buffer SENDD',638,info)
      ENDIF
      CALL ppm_alloc(sends,ldu,iopt,info)
      IF (info .NE. 0) THEN
          info = ppm_error_error
          CALL ppm_error(ppm_err_dealloc,caller,     &
     &        'local send buffer SENDS',644,info)
      ENDIF

      !-------------------------------------------------------------------------
      !  Return 
      !-------------------------------------------------------------------------
 9999 CONTINUE
      CALL substop(caller,t0,info)
      RETURN
      CONTAINS
      SUBROUTINE check
        IF (Npart .LT. 0) THEN
            info = ppm_error_error
            CALL ppm_error(ppm_err_argument,caller,  &
     &          'Npart must be >=0',658,info)
            GOTO 8888
        ENDIF
 8888   CONTINUE
      END SUBROUTINE check
      END SUBROUTINE map_part_send_d

END MODULE ppm_module_particles_typedef

