client plankton
  USE ppm_module_topo_get
  INTEGER, DIMENSION(6) :: bcdef = ppm_param_bcdef_periodic
  INTEGER, DIMENSION(2) :: seed
  REAL(MK), PARAMETER   :: pi = ACOS(-1.0_MK)
  REAL(MK), DIMENSION(:,:), POINTER :: displace
  INTEGER               :: istage = 1
  INTEGER               :: interval
  CLASS(ppm_t_part_prop_d_), POINTER :: prop => NULL()
  ! mesh stuff
  REAL(MK), DIMENSION(2), PARAMETER :: offset = (/0.0_MK, 0.0_MK/)
  INTEGER, DIMENSION(2)   :: gl = (/1,1/)

  global_parameter(a,<#REAL(MK)#>,1.0_MK)
  global_parameter(b,<#REAL(MK)#>,2.5_MK)
  global_parameter(gam,<#REAL(MK)#>,1.5_MK)
  global_parameter(lambda1,<#REAL(MK)#>,4.0_MK)
  global_parameter(lambda2,<#REAL(MK)#>,4.0_MK)
  global_parameter(psi0,<#REAL(MK)#>,0.1_MK)
  global_parameter(k,<#REAL(MK)#>,1.5_MK)
  global_var(np_global,<#INTEGER#>,0)
  global_var(mesh,<#TYPE(ppm_t_equi_mesh), POINTER#>,<#NULL()#>)


  add_arg(Dcp,<#REAL(MK)#>,1.0_MK,0.0_MK,'Dcp_param','Diffusion constant of P')
  add_arg(Dcz,<#REAL(MK)#>,1.0_MK,0.0_MK,'Dcz_param','Diffusion constant of Z')
  add_arg(nm,<#INTEGER, DIMENSION(2)#>,<#(/33,33,33/)#>,ctrl_name='nm',help_txt='Grid DIMENSIONs')

  ppm_init()

  P = create_field(1, "P")
  Z = create_field(1, "Z")

  s = create_field(2, "stream")

  topo = create_topology(bcdef)

  create_mesh(topo,offset,nm=nm,ghost_size=gl,mesh=mesh)
  add_patch(mesh,[0.0_MK,0.0_MK,<#2.0_MK*pi#>,<#2.0_MK*pi#>])

  np_global = PRODUCT(nm(1:2)-1)
  stdout(np_global)
  ! create particles
  parts = create_particles(topo,np_global)
  ALLOCATE(displace(ppm_dim,parts%Npart))
  CALL RANDOM_NUMBER(displace)
  displace = (displace - 0.5_MK) * parts%h_avg * 0.15_MK
  CALL parts%move(displace, info)
  DEALLOCATE(displace)
  CALL parts%apply_bc(info)
  !CALL parts%set_cutoff(4._MK * parts%h_avg, info)
  stdout('4.0_MK * parts%h_avg')
  global_mapping(parts, topo)

  discretize(P,parts)
  discretize(Z,parts)
  discretize(s,parts)


  foreach p in particles(parts) with positions(x) sca_fields(P,Z)
    P_p = 1.0_MK
    Z_p = 0.0_MK
    IF ((x_p(1).gt.(7.0_MK/10.0_MK)*pi).and.(x_p(1).lt.(13.0_MK/10.0_MK)*pi).and.&
    &   (x_p(2).gt.(5.0_MK/6.0_MK)*pi).and.(x_p(2).lt.(7.0_MK/6.0_MK)*pi)) THEN
      Z_p = 0.1_MK
    ENDIF
  end foreach
  ghost_mapping(parts)

  n = create_neighlist(parts,cutoff=<#4.0_MK * parts%h_avg#>)

  ! this problem is only defined in 2D
  Lap = define_op(2, [2,0, 0,2], [1.0_MK, 1.0_MK], "Laplacian")
  Jac = define_op(2, [0,1, 1,0], [-1.0_MK, 1.0_MK], "Jacobian")

  L = discretize_op(Lap, parts, ppm_param_op_dcpse,[order=>2,c=>1.0_MK])
  J = discretize_op(Jac, parts, ppm_param_op_dcpse,[order=>2,c=>1.0_MK])

  o, nstages = create_ode([parts,P,Z], plankton_rhs, [P=>parts,Z,s], rk4)
  !interval = int(stop_time/time_step)/1000

  o, nstages = create_ode([parts,P,Z], plankton_rhs, [P=>parts,Z,s], rk4)
  t = timeloop()
    DO istage=1,nstages
       parts%flags(ppm_part_partial) = .true. ! hack
       parts%flags(ppm_part_areinside) = .true.
       parts%flags(ppm_part_ghosts) = .true.
       prop => parts%props%begin()
       DO WHILE (ASSOCIATED(prop))
          prop%flags(ppm_ppt_partial) = .true.
          prop => parts%props%next()
       enddo
       CALL parts%map_ghost_push_positions(info)
       ghost_mapping(parts)
       CALL parts%map_ghost_pop_positions(info)

       ode_step(o, t, time_step, istage)
    ENDDO
    print([P=>parts, Z=>parts],10 )
  end timeloop

  !print([U=>parts, V=>parts],1 )
  ppm_finalize()
END client

rhs plankton_rhs(P=>parts,Z,s)
  REAL(MK), DIMENSION(:,:), pointer :: displace
  get_fields(dx,dP,dZ)

  stdout("remesh")
  ! remesh
  CALL parts%remesh(mesh,ppm_param_rmsh_kernel_mp4,info)

  ! a little hack until Sylvain's patch ships :)
  ALLOCATE(displace(ppm_dim,parts%Npart))
  CALL RANDOM_NUMBER(displace)
  displace = (displace - 0.5_MK) * parts%h_avg * 1.0e-5_MK
  CALL parts%move(displace, info)
  DEALLOCATE(displace)
  CALL parts%apply_bc(info)
  partial_mapping(parts)

  stdout("remesh done")

  ! recreate ghosts and neighlists
  ghost_mapping(parts)

  comp_neighlist(parts)

  ! recompute operator weights
  SELECT TYPE(L)
  CLASS is (ppm_t_dcop_d)
    CALL L%comp_weights(info)
  END SELECT

  SELECT TYPE(J)
  CLASS is (ppm_t_dcop_d)
    CALL J%comp_weights(info)
  END SELECT

  stdout("ghost map done")
  stdout('parts%npart')

  stdout("diffusion")
  ! diffusion
  dP = apply_op(L, P)
  dZ = apply_op(L, Z)

  stdout("reaction")
  ! reaction terms
  foreach p in particles(parts) with sca_fields(P,Z,dP,dZ)
    dP_p = Dcp*dP_p + P_p*(1 - P_p) - a*Z_p*(1 - EXP(-lambda1*P_p))
    dZ_p = Dcz*dZ_p - gam*Z_p + b*Z_p*(1 - EXP(-lambda2*P_p))
  end foreach

  stdout("advection")
  ! advection
  dx = apply_op(J,s)

  stdout("comp streamline func")
  foreach p in particles(parts) with positions(x) vec_fields(s)
    s_p(1) = psi0*SIN(k*x_p(1))*SIN(k*x_p(2))
    s_p(2) = psi0*SIN(k*x_p(1))*SIN(k*x_p(2))
  end foreach

  stdout("all done")
end rhs
