Feature: Right hand side definition

  In order to allow the user to easily define the right hand sides (rhs) of 
  the governing equations, the system should provide an extendable template
  in the form of a right hand side statement. The rhs can then be called in
  the main time loop or passed as function pointers to the ppm ODE module.

  Background: use standard macros
    Given the standard macro path is "lib/macros/defs"

  Scenario: basic rhs definition
    Given there is a rhs call to "testrhs"
    And setting predictable_mangle_prefix is on
    And rhs call args are (:ppm_t_field_,:ppm_t_field_,:ppm_t_field_) (:ppm_t_equi_mesh,nil,nil)
    And rhs call results are (:ppm_t_part_prop_d_,:ppm_t_field_,:ppm_t_field_,:ppm_t_field_) (:ppm_t_particles_d,nil,nil,nil)
    When I preprocess
    """
    rhs testrhs(f=>a,g,h)
      integer :: test
      get_fields(dx=>x,df,dg,dh)
      dgdata = get_data(dg)
    end rhs

    """
    Then the rhs module outputs
    """
    module ppm_autogenerated_rhs
      implicit none
      contains
      function testrhs(vars_discr, time, changes)
        use ppm_autogenerated_global
        implicit none
        real(ppm_kind_double) :: testrhs
        class(ppm_v_var_discr_pair), pointer :: vars_discr
        real(ppm_kind_double) :: time
        class(ppm_v_main_abstr), pointer :: changes
        class(ppm_t_main_abstr), pointer :: change => null()
        class(ppm_t_var_discr_pair), pointer :: vd_pair => null()
        class(ppm_t_discr_info_), pointer :: di => null()
        character(len=21) :: caller='ppm_autogenerated_rhs'
        class(ppm_t_field_), pointer :: f
        class(ppm_t_equi_mesh), pointer :: a
        class(ppm_t_field_), pointer :: g
        class(ppm_t_field_), pointer :: h
        class(ppm_t_part_prop_d_), pointer :: dx
        class(ppm_t_particles_d), pointer :: x
        class(ppm_t_field_), pointer :: df
        class(ppm_t_field_), pointer :: dg
        class(ppm_t_field_), pointer :: dh
        REAL(MK), dimension(:), pointer :: mangled_dgdata
        integer :: test
        testrhs = 0
        vd_pair => vars_discr%at(1)
        select type(vdpairvar => vd_pair%var)
        class is (ppm_t_field_)
          f => vdpairvar
        end select
        select type(vdpairdiscr => vd_pair%discr)
        class is (ppm_t_equi_mesh)
          a => vdpairdiscr
        end select
        vd_pair => vars_discr%at(2)
        select type(vdpairvar => vd_pair%var)
        class is (ppm_t_field_)
          g => vdpairvar
        end select
        vd_pair => vars_discr%at(3)
        select type(vdpairvar => vd_pair%var)
        class is (ppm_t_field_)
          h => vdpairvar
        end select
        change => changes%at(1)
        select type(change)
        class is (ppm_t_part_prop_d_)
          dx => change
        end select
        di => dx%discr_info%begin()
        select type(discrptr => di%discr_ptr)
        class is (ppm_t_particles_d)
          x => discrptr
        end select
        change => changes%at(2)
        select type(change)
        class is (ppm_t_field_)
          df => change
        end select
        change => changes%at(3)
        select type(change)
        class is (ppm_t_field_)
          dg => change
        end select
        change => changes%at(4)
        select type(change)
        class is (ppm_t_field_)
          dh => change
        end select
        mangled_dgdata = b%get_wp(dg)
      9999 continue
      end function testrhs
      
    end module ppm_autogenerated_rhs

    """

    # program test
    #   ppm_init()
    #   f=create_field()
    #   c=create_particles()
    #   discretize_on(f,c)
    #   call rhs test_rhs(f)
    #   ode = init_ode(f,c,g,h)
    #   time loop
    #     do step(ode,testrhs(f,g,h=>m))
    #   end time loop
    #   ppm_finalize()
    # end program

  # Scenario: file format
  #   Given a rhs file with the following structure
  #   """
  #   rhs name(topology=t,discretization=pset1,rhs=wp,drhs=dwp,idata=idata,ldata=ldata,rdata=rdata)
  #   ! the body of rhs is in fortran
  #   ! arguments cannot be changed but erb templates are allowed
  #   PRINT*,topo_id, <%= conf.ppm.dim %>
  #   end rhs

  #   """
  #   When the file is loaded
  #   Then a rhs named "name" should be created
  #   And the source of the rhs should be
  #   """
  #   function name(t, pset1, wp, dwp, idata, ldata, rdata)
  #     implicit none
  #     integer :: name
  #     integer, intent(in) :: t
  #     REAL(MK), dimension(:,:), pointer :: pset1
  #     REAL(MK), dimension(:,:), pointer :: wp
  #     REAL(MK), dimension(:,:), pointer :: dwp
  #     integer, dimension(:,:), intent(in), optional :: idata
  #     logical, dimension(:,:), intent(in), optional :: ldata
  #     REAL(MK), dimension(:,:), intent(in), optional :: rdata
  #     ! the body of rhs is in fortran
  #     ! arguments cannot be changed but erb templates are allowed
  #     PRINT*,topo_id, <%= conf.ppm.dim %>
      
  #   end function name

  #   """

