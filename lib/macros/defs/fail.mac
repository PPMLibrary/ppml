macro ppm_fail(message, type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
CALL ppm_error(<%= type %>, &
  <%= message %>,&
  <%= caller %>, <%= scope.line %> , <%= info %>)
GOTO <%= exit_point %>
end macro

macro fail(message, type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
<%= info %> = ppm_error_error
$ppm_fail(message,type,info,exit_point,caller)
end macro

macro or_fail(message, type=ppm_err_sub_failed,info=info)
IF (<%= info %>.NE.0) THEN
  $fail(message,type,info)
END IF
end macro

macro or_fail_MPI(message, type=ppm_err_mpi_fail,info=info)
IF (<%= info %>.NE.MPI_SUCCESS) THEN
  $fail(message,type,info)
END IF
end macro

macro or_fail_alloc(message, type=ppm_err_alloc,info=info)
IF (<%= info %>.NE.0) THEN
  $fail(message,type,info)
END IF
end macro

macro or_fail_dealloc(message, type=ppm_err_dealloc,info=info)
IF (<%= info %>.NE.0) THEN
  $fail(message,type,info)
END IF
end macro


macro check_associated(p,message="",type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
% scope.raw_var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% p_s = p.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (.NOT.ASSOCIATED(<%= p_s %>)) THEN
    WRITE(cbuf,*) &
       & "check failed:",   CHAR(10),&
       & "    <%= p_s %> is not associated.", CHAR(10),&
       & <%= message %> 
   $fail("cbuf","ppm_err_argument",info,exit_point) 
ENDIF
end macro

macro check_associated_noscope(p,message="default",type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
% p_s = p.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (.NOT.ASSOCIATED(<%= p_s %>)) THEN
   $fail("\"#{p_s} is not associated. \"","ppm_err_argument",info,exit_point) 
ENDIF
end macro

macro check_equal(a,b,message="",info=info,exit_point=9999)
% scope.raw_var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% a_s = a.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% b_s = b.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (<%= a_s %> .NE. <%= b_s%>) THEN
   WRITE(cbuf,*) &
       & "equality check failed:",   CHAR(10),&
       & "    <%= a_s %> = ",<%= a_s %>, CHAR(10),&
       & "    <%= b_s %> = ",<%= b_s %>, CHAR(10),&
       & <%= message %> 
   $fail("cbuf","ppm_err_argument",info,exit_point) 
ENDIF
end macro

macro check_true(a,message="",info=info,exit_point=9999)
% scope.raw_var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% a_s = a.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (.NOT.<%= a_s %>) THEN
   WRITE(cbuf,*) &
       & "check failed:",   CHAR(10),&
       & "    <%= a_s %> is not true. ", CHAR(10),&
       & <%= message %> 
   $fail("cbuf","ppm_err_argument",info,exit_point) 
ENDIF
end macro

macro check_false(a,message="",info=info,exit_point=9999)
% scope.raw_var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% a_s = a.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (<%= a_s %>) THEN
   WRITE(cbuf,*) &
       & "check failed:",   CHAR(10),&
       & "    <%= a_s %> is not false", CHAR(10),&
       & <%= message %> 
   $fail("cbuf","ppm_err_argument",info,exit_point) 
ENDIF
end macro

macro start_subroutine(name=default_name)
REAL(KIND(1.D0))                   :: t0
CHARACTER(LEN=ppm_char)            :: caller = "<%= name.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )%>"

!-------------------------------------------------------------------------
!  Initialise
!-------------------------------------------------------------------------
CALL substart(caller,t0,info)
end macro

macro end_subroutine(exit_point=9999)
    CALL substop(caller,t0,info)
    <%= exit_point %> CONTINUE
end macro

macro start_function(name="default_name")
% scope.raw_var info: "INTEGER                 :: info"
    CHARACTER(LEN=ppm_char)            :: caller = <%= name %>

    info = 0
end macro

macro end_function(exit_point=9999)
    <%= exit_point %> CONTINUE
end macro

macro destroy_collection_ptr(collection_pointer)
% coll_ptr = collection_pointer
IF (ASSOCIATED(<%= coll_ptr %>)) THEN
    CALL <%= coll_ptr %>%destroy(info)
        $or_fail_dealloc("\"#{coll_ptr} object\"")
    DEALLOCATE(<%= coll_ptr %>,STAT=info)
        $or_fail_dealloc("\"#{coll_ptr} pointer\"")
ENDIF
end macro

macro stdout(*message)
% #writes to standard output using ppm_write
% #double-quoted arguments are printed as strings
% #single-quoted ones are first evaluated in Fortran, then printed
% scope.raw_var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% if message.is_a? Array
% message.map! {|p| p.to_s.gsub( /\A'/m, "" ).gsub( /'\Z/m, "" )}
    WRITE(cbuf,*) <%=message.join(",&\n")%>
% end
    CALL ppm_write(ppm_rank,caller,cbuf,info)
end macro

macro stdout_f(format,*message)
% #Like stdout(), except that the first argument is the argument
% #for Fortran formatted output.
% #double-quoted arguments are printed as strings
% #single-quoted ones are first evaluated in Fortran, then printed
% scope.raw_var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% if message.is_a? Array
% message.map! {|p| p.to_s.gsub( /\A'/m, "" ).gsub( /'\Z/m, "" )}
    WRITE(cbuf,<%= format %>) <%=message.join(",&\n")%>
% end
    CALL ppm_write(ppm_rank,caller,cbuf,info)
end macro


macro dealloc_pointer(pointer,info=info)
% p = pointer.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% p = p.to_s.gsub( /\A'/m, "" ).gsub( /'\Z/m, "" )
IF (ASSOCIATED(<%= p %>)) DEALLOCATE(<%= p %>,stat=<%= info %>)
$or_fail_dealloc("\"#{p}\"")
end macro

macro dealloc_allocatable(allocatable,info=info)
% p = allocatable.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% p = p.to_s.gsub( /\A'/m, "" ).gsub( /'\Z/m, "" )
IF (ALLOCATED(<%= p %>)) DEALLOCATE(<%= p %>,stat=<%= info %>)
$or_fail_dealloc("\"#{p}\"")
end macro

macro dealloc_pointers(*list)
% if list.is_a? Array
% list.each do |ptr|
% p = ptr.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% p = p.to_s.gsub( /\A'/m, "" ).gsub( /'\Z/m, "" )
$dealloc_pointer(p)
% end
% end
end macro



macro alloc_pointer(pointer,dim,info=info)
% p = pointer.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% d = dim.to_s.gsub( /\A'/m, "" ).gsub( /'\Z/m, "" )
    $check_false("\"ASSOCIATED(#{p})\"","\"pointer already associated\"")
    ALLOCATE(<%= p %>(<%= d %>),STAT=<%=info%>)
    $or_fail_alloc("\"#{p}\"")
end macro

macro alloc_pointer_with_bounds1(pointer,lo,hi,info=info)
% p = pointer.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
    $check_false("\"ASSOCIATED(#{p})\"","\"pointer already associated\"")
    ALLOCATE(<%= p %>(<%=lo%>(1):<%=hi%>(1)),STAT=<%=info%>)
    $or_fail_alloc("\"#{p}\"")
end macro
macro alloc_pointer_with_bounds2(pointer,lo,hi,info=info)
% p = pointer.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
    $check_false("\"ASSOCIATED(#{p})\"","\"pointer already associated\"")
    ALLOCATE(<%= p %>(<%=lo%>(1):<%=hi%>(1),<%=lo%>(2):<%=hi%>(2)),STAT=<%=info%>)
    $or_fail_alloc("\"#{p}\"")
end macro
macro alloc_pointer_with_bounds3(pointer,lo,hi,info=info)
% p = pointer.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
    $check_false("\"ASSOCIATED(#{p})\"","\"pointer already associated\"")
    ALLOCATE(<%= p %>(<%=lo%>(1):<%=hi%>(1),<%=lo%>(2):<%=hi%>(2),&
                      <%=lo%>(3):<%=hi%>(3)),STAT=<%=info%>)
    $or_fail_alloc("\"#{p}\"")
end macro
macro alloc_pointer_with_bounds4(pointer,lo,hi,info=info)
% p = pointer.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
    $check_false("\"ASSOCIATED(#{p})\"","\"pointer already associated\"")
    ALLOCATE(<%= p %>(<%=lo%>(1):<%=hi%>(1),<%=lo%>(2):<%=hi%>(2),&
                      <%=lo%>(3):<%=hi%>(3),<%=lo%>(4):<%=hi%>(4)),STAT=<%=info%>)
    $or_fail_alloc("\"#{p}\"")
end macro


